{"meta":{"title":"DD_XIE的学习笔记","subtitle":"^_^","description":"前端学习","author":"I'm xiedandan","url":"http://xdd7130.github.io","root":"/"},"pages":[{"title":"书单","date":"2022-11-02T11:15:20.839Z","updated":"2022-11-02T11:15:20.839Z","comments":false,"path":"books/index.html","permalink":"http://xdd7130.github.io/books/index.html","excerpt":"","text":"书单链接"},{"title":"分类","date":"2018-12-26T09:25:11.000Z","updated":"2022-11-02T11:15:20.840Z","comments":true,"path":"categories/index.html","permalink":"http://xdd7130.github.io/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2018-12-27T02:36:14.000Z","updated":"2022-11-02T11:15:20.838Z","comments":true,"path":"about/index.html","permalink":"http://xdd7130.github.io/about/index.html","excerpt":"","text":"1.Markdown引用音频(自定义) ### 3.Markdown视频(引用爱奇艺) 4.Markdown视频(引用腾讯） 5.插入Markdown gif"},{"title":"友情链接","date":"2022-11-02T11:15:20.842Z","updated":"2022-11-02T11:15:20.842Z","comments":true,"path":"links/index.html","permalink":"http://xdd7130.github.io/links/index.html","excerpt":"","text":"友情链接"},{"title":"Repositories","date":"2022-11-02T11:15:20.842Z","updated":"2022-11-02T11:15:20.842Z","comments":false,"path":"repository/index.html","permalink":"http://xdd7130.github.io/repository/index.html","excerpt":"","text":"友情链接"},{"title":"标签云","date":"2018-12-26T09:28:15.000Z","updated":"2022-11-02T11:15:20.843Z","comments":true,"path":"tags/index.html","permalink":"http://xdd7130.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"JSON 和 excel之间的转换","slug":"JSON和excel之间的转换","date":"2025-02-08T06:34:15.000Z","updated":"2025-02-15T04:02:15.961Z","comments":true,"path":"2025/02/08/JSON和excel之间的转换/","link":"","permalink":"http://xdd7130.github.io/2025/02/08/JSON和excel之间的转换/","excerpt":"","text":"依赖包安装1yarn add fs xlsx json转excel1234567891011121314151617const fs = require('fs')const XLSX = require('xlsx')// 读取JSON文件const jsonData = JSON.parse(fs.readFileSync('public/static/i18n/zh_CN/index.json', 'utf-8'))const handleArr = Object.entries(jsonData).map(item =&gt; &#123; return &#123; key: item[0], value: item[1] &#125;&#125;)// 转换为工作表const worksheet = XLSX.utils.json_to_sheet(handleArr)// 创建工作簿并添加工作表const workbook = XLSX.utils.book_new()XLSX.utils.book_append_sheet(workbook, worksheet, 'Sheet1')// 写入文件XLSX.writeFile(workbook, 'hbmLang.xlsx') excel转json123456789101112131415161718const XLSX = require('xlsx')const fs = require('fs')// 读取 Excel 文件const workbook = XLSX.readFile('hbmLang.xlsx')// 选择要转换的工作表const sheetName = workbook.SheetNames[0] // 假设我们只转换第一个工作表const worksheet = workbook.Sheets[sheetName]// 将工作表转换为 JSONconst jsonData = XLSX.utils.sheet_to_json(worksheet)let objectData = jsonData.reduce((pre, cur) =&gt; &#123; return &#123; ...pre, [cur.key]: cur.value &#125;&#125;, &#123;&#125;)// 将 JSON 数据写入文件或控制台输出fs.writeFileSync('hbmLang.json', JSON.stringify(objectData, null, 2))","categories":[{"name":"笔记","slug":"笔记","permalink":"http://xdd7130.github.io/categories/笔记/"}],"tags":[{"name":"node","slug":"node","permalink":"http://xdd7130.github.io/tags/node/"}]},{"title":"D3(1)","slug":"D3-1","date":"2025-02-08T03:35:15.000Z","updated":"2025-02-15T04:02:15.959Z","comments":true,"path":"2025/02/08/D3-1/","link":"","permalink":"http://xdd7130.github.io/2025/02/08/D3-1/","excerpt":"","text":"简介 D3.js 是一个 JavaScript 库，用于在 Web 上创建图表、地图等可视化效果。 D3 是 Data-Driven Documents(数据驱动文档) 的简称 它使用可缩放矢量图形 （SVG）、HTML5 和级联样式表（CSS） 标准 与许多其他提供现成图表的数据可视化库不同，D3 为您提供了很大的创作自由，因为您可以完全控制您创建的可视化。D3 还使用 HTML、CSS、SVG 和 JavaScript 等 Web 技术。 数据绑定 Data-Join将数据与 DOM 元素（如 SVG 元素）关联起来。数据绑定是 D3 实现数据驱动文档（Data-Driven Documents）的关键机制数据绑定是指将数据数组与 DOM 元素进行关联，并根据数据的长度和内容动态创建、更新或删除 DOM 元素。D3 通过以下三个步骤实现数据绑定： Enter：为新增数据创建新元素。 Update：更新现有元素以反映数据的变化。 Exit：移除不再需要的元素。 数据绑定的核心方法D3 提供了 .data() 方法来实现数据绑定，并结合 .enter()、.exit() 和 .merge() 来处理数据的增删改。 .data(data)将数据数组绑定到选中的 DOM 元素。 返回一个绑定数据的对象，包含 enter、exit 和 _groups 等属性。 .enter()返回一个“占位符”选择集，表示需要新增的元素。 通常与 .append() 结合使用，为新增数据创建 DOM 元素。 .exit()返回一个选择集，表示需要移除的元素。 通常与 .remove() 结合使用，删除多余的元素。 .merge(selection)将 enter 和 update 选择集合并，以便同时对新增和更新的元素进行操作。 data().data(data, keyFunction)data来绑定数据，keyFunction定义数据如何去索引e.g d3.selectAll(‘rect’).data(data, d =&gt; data.name).attr(‘width’, d =&gt; xScale(d.value)) 理解Update、Enter、Exit 与 添加、删除元素在使用data()绑定数据时，例如：现在我们有一个数组[3,6,9,12,15],我们可以将数组每一项与一个绑定，但是，现在就有一个问题——数据集个数和选择集个数不匹配怎么办？这样就需要理解Update、Enter、Exit通过以下图可以理解 Update、Enter、Exit 数组[3,6,9,12,15]绑定到三个上。可以想象到，数组的最后两个元素没有可以绑定的元素，这时D3会建立两个空的元素与数组最后的两个数据相对于，那么这部分就称为Enter。而有元素与数据对应的部分就称为Update 如果数组[3]绑定到三个上，可以想象，最后两个没有可绑定的数据，那么没有数据绑定的部分就称为Exit Update与Enter的使用12345678910111213141516171819202122232425262728293031323334&lt;body&gt; &lt;p&gt;name1&lt;/p&gt; &lt;p&gt;name2&lt;/p&gt; &lt;p&gt;name3&lt;/p&gt; &lt;script&gt; var dataset = [3,6,9,12,15]; var p = d3.selectAll(\"p\"); var update = p.data(dataset)//绑定数据,并得到update部分 var enter = update.enter();//得到enter部分 //下面检验是否真的得到 //对于update的处理 // 匿名函数第一个参数 d 为每个元素所绑定的对应数据 data // 匿名函数第一个参数 i 为每个元素的索引，从 0 开始递增 update.text(function(d,i)&#123; return \"update: \"+d+\",index: \"+i; &#125;) //对于enter的处理 //注意，这里需要先添加足够多的&lt;p&gt;，然后在添加文本 var pEnter = enter.append(\"p\")//添加足够多的&lt;p&gt; pEnter.text(function(d,i)&#123; return \"enter: \"+d+\",index: \"+i; &#125;) /* 运行结果如下： update: 3,index: 0 update: 6,index: 1 update: 9,index: 2 enter: 12,index: 3 enter: 15,index: 4 */ &lt;/script&gt; &lt;/body&gt; Update与Exit的使用 123456789101112131415161718192021222324252627282930 &lt;body&gt;&lt;p&gt;name1&lt;/p&gt; &lt;p&gt;name2&lt;/p&gt; &lt;p&gt;name3&lt;/p&gt; &lt;script&gt; var dataset = [3,6]; var p = d3.select(\"body\") .selectAll(\"p\"); var update = p.data(dataset)//绑定数据,并得到update部分 var exit = update.exit();//得到exit部分 //下面检验是否真的得到 //对于update的处理 update.text(function(d,i)&#123; return \"update: \"+d+\",index: \"+i; &#125;) //对于exit的处理通常是删除 ，但在这里我并没有这么做 // 删除操作为 exit.remove() exit.text(function(d,i)&#123; return \"exit\"; &#125;) /* 运行结果如下： update: 3,index: 0 update: 6,index: 1 exit */ &lt;/script&gt;&lt;/body&gt; selection.join(enter[, update][, exit])1234567这是V5版本的新特性，这种方法很方便，可以代替selection.enter, selection.exit, selection.append, selection.remove, selection.order.svg.selectAll(\"circle\") .data(data) .join(\"circle\") .attr(\"fill\", \"none\") .attr(\"stroke\", \"black\"); 1234567891011简写相当于:svg.selectAll(\"circle\") .data(data) .join( enter =&gt; enter.append(\"circle\"), update =&gt; update, exit =&gt; exit.remove() ) .attr(\"fill\", \"none\") .attr(\"stroke\", \"black\"); 通过在进入、更新和退出上传递单独的函数，您可以更好地控制发生的事情。通过指定选择的关键函数、数据，您可以尽量减少对DOM的更改以优化性能。例如，为输入和更新设置不同的填充颜色: 1234567svg.selectAll(\"circle\") .data(data) .join( enter =&gt; enter.append(\"circle\").attr(\"fill\", \"green\"), update =&gt; update.attr(\"fill\", \"blue\") ) .attr(\"stroke\", \"black\"); data和datum 数据绑定对象：data() 用于将一个数组绑定到多个 DOM 元素。datum() 用于将单个数据项绑定到单个 DOM 元素。 返回值：data() 返回一个更新的选择集，可以用于进一步的操作（如进入、更新、退出）。datum() 不返回更新的选择集，而是直接将数据绑定到当前选择的元素。 应用场景data()：适用于需要将多个数据项绑定到多个 DOM 元素的场景，如绘制多个圆圈、柱状图等。datum()：适用于需要将单个数据项绑定到单个 DOM 元素的场景，如绘制单个矩形、文本等。 extent和max，mind3.extent 用于计算数据集的最小值和最大值，返回一个包含这两个值的数组。d3.max 用于计算数据集中的最大值，返回一个单个值。d3.min 用于计算数据集中的最小值，返回一个单个值。1234const data = [4, 8, 15, 16, 23, 42];const extent = d3.extent(data);console.log(extent); // 输出: [4, 42] d3.pathSVG 基本形状中最强大的一个，是一个用于生成 SVG 路径数据字符串的工具。它提供了一系列方法来绘制线条、曲线等。123456789101112131415161718const pathGenerator = d3.path();// 移动到起始点pathGenerator.moveTo(10, 10);// 画一条线到 (100, 100)pathGenerator.lineTo(100, 100);// 画一条曲线到 (150, 50)pathGenerator.quadraticCurveTo(125, 75, 150, 50);// 关闭路径pathGenerator.closePath();// 获取生成的路径数据字符串const pathData = pathGenerator.toString();console.log(pathData); // 输出: \"M10,10L100,100Q125,75,150,50Z\" d3.lined3.line 是一个生成器，用于创建线条路径。它可以处理多个数据点，并生成相应的路径数据字符串。12345678910111213const data = [ &#123; x: 10, y: 10 &#125;, &#123; x: 100, y: 100 &#125;, &#123; x: 150, y: 50 &#125;];const lineGenerator = d3.line() .x(d =&gt; d.x) .y(d =&gt; d.y);const pathData = lineGenerator(data);console.log(pathData); // 输出: \"M10,10L100,100L150,50\" d3.aread3.area 是一个生成器，用于创建区域路径。它可以处理多个数据点，并生成相应的路径数据字符串，用于绘制区域图。1234567891011121314const data = [ &#123; x: 10, y: 10 &#125;, &#123; x: 100, y: 100 &#125;, &#123; x: 150, y: 50 &#125;];const areaGenerator = d3.area() .x(d =&gt; d.x) .y0(0) .y1(d =&gt; d.y);const pathData = areaGenerator(data);console.log(pathData); // 输出: \"M10,10L100,100L150,50L150,0L10,0Z\" d3.arc().innerRadius().outerRadius()用于饼图 interaction在 D3.js 中，交互（interaction）是创建动态和响应式数据可视化的重要部分。D3.js 提供了多种方法来处理用户交互，包括鼠标事件、触摸事件、键盘事件等. 鼠标事件：mouseover、mouseout、click、dblclick、mousemove 等。 触摸事件：touchstart、touchmove、touchend 等。 键盘事件：keydown、keyup 等。 拖动事件：d3.drag 方法","categories":[{"name":"D3","slug":"D3","permalink":"http://xdd7130.github.io/categories/D3/"}],"tags":[{"name":"D3","slug":"D3","permalink":"http://xdd7130.github.io/tags/D3/"}]},{"title":"hexo学习","slug":"hexo","date":"2022-11-02T11:15:20.551Z","updated":"2022-11-02T11:15:20.551Z","comments":true,"path":"2022/11/02/hexo/","link":"","permalink":"http://xdd7130.github.io/2022/11/02/hexo/","excerpt":"","text":"https://xdd7130.github.io若存储在master中,xdd7130不可更改,必须和github的username一致. 为博客添加访问量参考：https://blog.csdn.net/qw8880000/article/details/80235391这里使用的是不蒜子提供的阅读统计功能，使用的hexo主题是stage。 添加是否开启统计功能的配置找到stage主题的配置文件themes/stage/_config.yml，找到原来的footer字段，加入一个配置，这里我们叫它counter吧，即1234footer: # ------------------------------------------------------------- # visitors count counter: true 修改stage主题的模板文件由于是把访问量统计放在网页的footer，所以我们需要修改的模板文件是theme/stage/layout/_partials/footer.ejs。我们在合适的位置加入：123456789&#123;% if theme.footer.counter %&#125; &lt;script async src=\"//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js\"&gt;&lt;/script&gt; &lt;span id=\"busuanzi_container_site_pv\"&gt;总访问量&lt;span id=\"busuanzi_value_site_pv\"&gt;&lt;/span&gt;次&lt;/span&gt; &lt;span class=\"post-meta-divider\"&gt;|&lt;/span&gt; &lt;span id=\"busuanzi_container_site_uv\"&gt;总访客&lt;span id=\"busuanzi_value_site_uv\"&gt;&lt;/span&gt;人&lt;/span&gt; &lt;span class=\"post-meta-divider\"&gt;|&lt;/span&gt;&#123;% endif %&#125; Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment Hexo+github搭建博客1、 npm install -g hexo错误：npm WARN deprecated titlecase@1.1.2: no longer maintained解决：安装淘宝镜像12npm config set registry https://registry.npm.taobao.orgnpm install -g cnpm --registry=https://registry.npm.taobao.org 2、 初始化(hexo init)Hexo文件夹必须为空。3、 hexo g 生成静态文件1hexo s 搭建本地服务查看localhost:4000 4、 hexo d问题：$ hexo d： ERROR Deployer not found: git1npm install --save hexo-deployer-git 部署本地文件到github既然Repository已经创建了，当然是先把博客放到Github上去看看效果。编辑E：\\hexo下的_config.yml文件，建议使用Notepad++。在_config.yml最下方，添加如下配置(命令中的第一个tengj为Github的用户名,第二个tengj为之前New的Repository的名字,记得改成自己的。另外记得一点，hexo的配置文件中任何’:’后面都是带一个空格的),如果配置以下命令出现ERROR Deployer not found : github，则参考上文的解决方法1234deploy: type: git repository: https://github.com/tengj/tengj.github.io.git branch: master 配置_config.yml并保存。如果你是第一次使用Github或者是已经使用过，但没有配置过SSH，则可能需要配置一下:在Git Bash输入以下指令（任意位置点击鼠标右键），检查是否已经存在了SSH keys。ls -al ~/.ssh如果不存在就没有关系，如果存在的话，直接删除.ssh文件夹里面所有文件：输入以下指令（邮箱就是你注册Github时候的邮箱）后，回车，出现提示让你输入的时候直接先回车，好像需要3次，如下图所示：1ssh-keygen -t rsa -C \"2621324849@qq.com\" 然后键入以下指令：1ssh-agent -s 继续输入指令：1ssh-add ~/.ssh/id_rsa 输入之后，在我这里是出错了，不知道你的有没有出错。如果你的也是这样子出错了的话，就输入以下指令：12eval `ssh-agent -s`ssh-add 到了这一步，就可以添加SSH key到你的Github账户了。键入以下指令，拷贝Key（先拷贝了，等一下可以直接粘贴，不放心的在执行下面命令后，先黏贴在记事本上）：1clip &lt; ~/.ssh/id_rsa.pub 然后到Github里面，点击右上角的设置图标Settings,找到SSH keys,Ttile随便你命名，Key就黏贴上你刚才复制的key,然后点Add SSH key，最后会让你重新输入下gitHub的密码最后还是测试一下吧，键入以下命令：1ssh -T git@github.com 你可能会看到有警告，没事，输入“yes”就好以上就表示SSH配置好了，执行以下命令部署到Github上。hexo ghexo d如果执行hexo d命令报下名错：就先安装一下hexo-deployer-git这个模块：npm install hexo-deployer-git –save安装好了继续执行hexo d部署命令，输入gitHub的账号密码，就可以访问了。 问题：博客引入图片解决办法1.首先把blog（hexo）目录下的_config.yml里的psot_asset_folder:设置为true 2.在blog（hexo）目录下执行: npm install hexo-asset-image –save3.在blog（hexo）目录下Git Bash Here，运行hexo n “博客名”来生成md博客时，会在_post目录下看到一个与博客同名的文件夹。 4.将想要上传的图片先扔到文件夹下，然后在博客中使用markdown的格式引入图片： ps：因为博客名和文件夹名字相同，所以不需要绝对路径，只要xxxx是文件夹的名字就可以了。 5.然后，使用hexo g部署的时候，进入public\\2018\\04\\19\\index.html文件中查看相关字段，可以发现html标签内的语句是img src = “2018/04/19/xxxx/图片名.jpg”而不是img src=”xxxx.图片名.jpg”，这就成功了，当然前面步骤操作正确的话，这一步也不用检查。","categories":[{"name":"hexo","slug":"hexo","permalink":"http://xdd7130.github.io/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://xdd7130.github.io/tags/hexo/"}]},{"title":"Vue3引入element-plus","slug":"Vue3引入element-plus","date":"2022-10-20T12:33:12.000Z","updated":"2022-11-02T11:15:20.543Z","comments":true,"path":"2022/10/20/Vue3引入element-plus/","link":"","permalink":"http://xdd7130.github.io/2022/10/20/Vue3引入element-plus/","excerpt":"","text":"安装 element-plus1cnpm install element-plus --save 配置 main.ts123456import ElementPlus from &apos;element-plus&apos;;import &apos;element-plus/dist/index.css&apos;;import App from &apos;./App.vue&apos;createApp(App).use(ElementPlus).mount(&apos;#app&apos;); 安装 @element-plus/icons-vue 使用 icon1cnpm install @element-plus/icons-vue --save 组件局部按需引用123import &#123; Download &#125; from &apos;@element-plus/icons-vue&apos;;&lt;el-icon&gt;&lt;download /&gt;&lt;/el-icon&gt;","categories":[{"name":"Vue3","slug":"Vue3","permalink":"http://xdd7130.github.io/categories/Vue3/"}],"tags":[{"name":"Vue,Vue3,element-plus","slug":"Vue-Vue3-element-plus","permalink":"http://xdd7130.github.io/tags/Vue-Vue3-element-plus/"}]},{"title":"Cesium之3D Tiles","slug":"Cesium之3DTiles","date":"2022-10-20T12:22:12.000Z","updated":"2022-11-02T11:15:20.539Z","comments":true,"path":"2022/10/20/Cesium之3DTiles/","link":"","permalink":"http://xdd7130.github.io/2022/10/20/Cesium之3DTiles/","excerpt":"","text":"添加立方体12345678910111213var viewer = new Cesium.Viewer(&apos;cesiumContainer&apos;);var redBox = viewer.entities.add(&#123; name : &apos;Red box with black outline&apos;, position: Cesium.Cartesian3.fromDegrees(-107.0, 40.0, 300000.0), box : &#123; dimensions : new Cesium.Cartesian3(400000.0, 300000.0, 500000.0), material : Cesium.Color.RED.withAlpha(0.5), outline : true, outlineColor : Cesium.Color.BLACK &#125;&#125;);viewer.zoomTo(viewer.entities); 通过CZML添加1234567891011121314151617181920212223242526272829303132var czml = [&#123; &quot;id&quot; : &quot;document&quot;, &quot;name&quot; : &quot;box&quot;, &quot;version&quot; : &quot;1.0&quot;&#125;,&#123; &quot;id&quot; : &quot;shape2&quot;, &quot;name&quot; : &quot;Red box with black outline&quot;, &quot;position&quot; : &#123; &quot;cartographicDegrees&quot; : [-107.0, 40.0, 300000.0] &#125;, &quot;box&quot; : &#123; &quot;dimensions&quot; : &#123; &quot;cartesian&quot;: [400000.0, 300000.0, 500000.0] &#125;, &quot;material&quot; : &#123; &quot;solidColor&quot; : &#123; &quot;color&quot; : &#123; &quot;rgba&quot; : [255, 0, 0, 128] &#125; &#125; &#125;, &quot;outline&quot; : true, &quot;outlineColor&quot; : &#123; &quot;rgba&quot; : [0, 0, 0, 255] &#125; &#125;&#125;];var viewer = new Cesium.Viewer(&apos;cesiumContainer&apos;);var dataSourcePromise = Cesium.CzmlDataSource.load(czml);viewer.dataSources.add(dataSourcePromise);viewer.zoomTo(dataSourcePromise);","categories":[{"name":"Cesium","slug":"Cesium","permalink":"http://xdd7130.github.io/categories/Cesium/"}],"tags":[{"name":"Cesium","slug":"Cesium","permalink":"http://xdd7130.github.io/tags/Cesium/"}]},{"title":"Cesium+Vue3 搭建第一个项目","slug":"Cesium+Vue3","date":"2022-10-20T12:22:12.000Z","updated":"2022-11-02T11:15:20.538Z","comments":true,"path":"2022/10/20/Cesium+Vue3/","link":"","permalink":"http://xdd7130.github.io/2022/10/20/Cesium+Vue3/","excerpt":"","text":"搭建 Vite 项目1234# yarnyarn create vite my-vue-app --template vue-ts# npm npm init vite my-vue-app --template vue-ts 安装 cesium123yarn add cesium # 这个是给开发时 vite 的 esbuild 找模块用的yarn add @types/cesium -D # 这个是给智能提示用的，例如 import &#123; Viewer &#125; from &apos;cesium&apos; yarn add -D vite-plugin-cesium # 安装vite-plugin-cesium插件 配置 vite.config.ts12345import cesium from &apos;vite-plugin-cesium&apos; // 引入插件 // 在plugin 里增加plugins: [ cesium()], 完整代码实例1234567891011121314151617181920212223242526272829303132333435363738&lt;template&gt; &lt;div id=&quot;mainMap&quot;&gt;&lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup&gt;import &#123; onMounted &#125; from &apos;vue&apos;import * as Cesium from &apos;cesium&apos;onMounted(() =&gt; &#123; Cesium.Ion.defaultAccessToken = &apos;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiIxNTFlNWVmMC1jOWRhLTQyMDktOTY4Ny02YTU5YWFlMGYwY2IiLCJpZCI6OTQzNDQsImlhdCI6MTY1Mjg4ODEyNn0.g2vq1qq_rdfZeRTy73nBkEDzhMIM4upkYcbIdFYnCiQ&apos; const viewer = new Cesium.Viewer(&apos;mainMap&apos;, &#123; infoBox: false, homeButton: false, timeline: false, navigationHelpButton: false, geocoder: false, sceneModePicker: false, animation: false, fullscreenButton: false &#125;) const buildingTileset = viewer.scene.primitives.add(Cesium.createOsmBuildings()) viewer.camera.flyTo(&#123; destination: Cesium.Cartesian3.fromDegrees(116.405419, 39.926666, 3000), orientation: &#123; heading: Cesium.Math.toRadians(0.0), pitch: Cesium.Math.toRadians(-25.0) &#125; &#125;) // viewer.cesiumWidget.creditContainer.style.display = &apos;none&apos;&#125;)&lt;/script&gt;&lt;style scoped&gt;#mainMap &#123; width: 800px; height: 800px; background: #aabbcc;&#125;&lt;/style&gt;","categories":[{"name":"Cesium","slug":"Cesium","permalink":"http://xdd7130.github.io/categories/Cesium/"}],"tags":[{"name":"Cesium,Vue,Vite","slug":"Cesium-Vue-Vite","permalink":"http://xdd7130.github.io/tags/Cesium-Vue-Vite/"}]},{"title":"Cesium之绘制形状","slug":"Cesium之绘制形状","date":"2022-10-20T12:22:12.000Z","updated":"2022-11-02T11:15:20.539Z","comments":true,"path":"2022/10/20/Cesium之绘制形状/","link":"","permalink":"http://xdd7130.github.io/2022/10/20/Cesium之绘制形状/","excerpt":"","text":"添加立方体12345678910111213var viewer = new Cesium.Viewer(&apos;cesiumContainer&apos;);var redBox = viewer.entities.add(&#123; name : &apos;Red box with black outline&apos;, position: Cesium.Cartesian3.fromDegrees(-107.0, 40.0, 300000.0), box : &#123; dimensions : new Cesium.Cartesian3(400000.0, 300000.0, 500000.0), material : Cesium.Color.RED.withAlpha(0.5), outline : true, outlineColor : Cesium.Color.BLACK &#125;&#125;);viewer.zoomTo(viewer.entities); 通过CZML添加1234567891011121314151617181920212223242526272829303132var czml = [&#123; &quot;id&quot; : &quot;document&quot;, &quot;name&quot; : &quot;box&quot;, &quot;version&quot; : &quot;1.0&quot;&#125;,&#123; &quot;id&quot; : &quot;shape2&quot;, &quot;name&quot; : &quot;Red box with black outline&quot;, &quot;position&quot; : &#123; &quot;cartographicDegrees&quot; : [-107.0, 40.0, 300000.0] &#125;, &quot;box&quot; : &#123; &quot;dimensions&quot; : &#123; &quot;cartesian&quot;: [400000.0, 300000.0, 500000.0] &#125;, &quot;material&quot; : &#123; &quot;solidColor&quot; : &#123; &quot;color&quot; : &#123; &quot;rgba&quot; : [255, 0, 0, 128] &#125; &#125; &#125;, &quot;outline&quot; : true, &quot;outlineColor&quot; : &#123; &quot;rgba&quot; : [0, 0, 0, 255] &#125; &#125;&#125;];var viewer = new Cesium.Viewer(&apos;cesiumContainer&apos;);var dataSourcePromise = Cesium.CzmlDataSource.load(czml);viewer.dataSources.add(dataSourcePromise);viewer.zoomTo(dataSourcePromise);","categories":[{"name":"Cesium","slug":"Cesium","permalink":"http://xdd7130.github.io/categories/Cesium/"}],"tags":[{"name":"Cesium","slug":"Cesium","permalink":"http://xdd7130.github.io/tags/Cesium/"}]},{"title":"Cesium之鹰眼图","slug":"Cesium之鹰眼图","date":"2022-10-20T12:22:12.000Z","updated":"2022-11-02T11:15:20.540Z","comments":true,"path":"2022/10/20/Cesium之鹰眼图/","link":"","permalink":"http://xdd7130.github.io/2022/10/20/Cesium之鹰眼图/","excerpt":"","text":"地图右下角放div容器1234567891011&lt;div id=&quot;eye&quot;&gt;&lt;/div&gt;#eye &#123; position: absolute; width: 20%; height:20%; bottom: 0; right: 0; z-index: 999; background: red; border: solid blue 1px;&#125; 创建 两个地球123//1.创建双球var viewer = new Cesium.Viewer(&apos;cesiumContainer&apos;, &#123;&#125;);var viewer1 = new Cesium.Viewer(&apos;eye&apos;, &#123;&#125;); 设置鹰眼图中球属性123456789101112131415161718//2.设置鹰眼图中球属性let control = viewer1.scene.screenSpaceCameraController;control.enableRotate = false;control.enableTranslate = false;control.enableZoom = false;control.enableTilt = false;control.enableLook = false;let syncViewer = function() &#123; viewer1.camera.flyTo(&#123; destination: viewer.camera.position, orientation: &#123; heading: viewer.camera.heading, pitch: viewer.camera.pitch, roll: viewer.camera.roll &#125;, duration: 0.0 &#125;);&#125; 同步通过添加了一个空字符串的label，利用它的CallbackProperty实现了每时每刻调用syncViewer方法来同步两个球的相机视角 12345678910//3. 同步viewer.entities.add(&#123; position : Cesium.Cartesian3.fromDegrees(0, 0), label : &#123; text : new Cesium.CallbackProperty(function()&#123; syncViewer(); return &quot;&quot;; &#125;, true) &#125;&#125;); 代码地址：gitHub","categories":[{"name":"Cesium","slug":"Cesium","permalink":"http://xdd7130.github.io/categories/Cesium/"}],"tags":[{"name":"Cesium","slug":"Cesium","permalink":"http://xdd7130.github.io/tags/Cesium/"}]},{"title":"Vue3+Router4.X","slug":"Vue3配置路由","date":"2022-10-20T12:22:12.000Z","updated":"2022-11-02T11:15:20.544Z","comments":true,"path":"2022/10/20/Vue3配置路由/","link":"","permalink":"http://xdd7130.github.io/2022/10/20/Vue3配置路由/","excerpt":"","text":"安装 Vue Router1npm install vue-router@4 创建router文件1234567891011121314151617// router.tsimport &#123; createRouter, createWebHistory &#125; from &quot;vue-router&quot;;import HelloWorld from &quot;./components/HelloWorld.vue&quot;;const routes = [ &#123; path: &quot;/&quot;, component: HelloWorld &#125;, &#123; path: &quot;/cesium&quot;, component: () =&gt; import(&quot;./components/Cesium.vue&quot;) &#125;];const router = createRouter(&#123; history: createWebHistory(), routes&#125;);export default router; App.vue配置菜单123&lt;router-link to=&quot;/cesium&quot;&gt; ...&lt;/router-link&gt; 配置 main.ts1234import Router from &apos;./router&apos;createApp(App).use(Router).mount(&apos;#app&apos;);","categories":[{"name":"Cesium","slug":"Cesium","permalink":"http://xdd7130.github.io/categories/Cesium/"}],"tags":[{"name":"Vue Router4.X,Vue,Vue3","slug":"Vue-Router4-X-Vue-Vue3","permalink":"http://xdd7130.github.io/tags/Vue-Router4-X-Vue-Vue3/"}]},{"title":"nginx配置https","slug":"nginx配置https","date":"2022-10-17T12:22:12.000Z","updated":"2022-11-02T11:15:20.553Z","comments":true,"path":"2022/10/17/nginx配置https/","link":"","permalink":"http://xdd7130.github.io/2022/10/17/nginx配置https/","excerpt":"","text":"nginx开启 SSL模块Nginx如果未开启SSL模块，配置Https时提示错误：1nginx: [emerg] the “ssl“ parameter requires ngx_http_ssl_module in /usr/local/ 开启: 切换到源码包,配置https环境1.找打nginx的安装环境 ，如nginx的安装目录是/usr/local/nginx,源包在 /opt/nginx-1.22.0 目录下2.切换到源码包：1cd /opt/nginx-1.22.0 3.进行编译1./configure --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module 4.配置完成后，运行命令：1make 5.make命令执行后，不要进行make install，否则会覆盖安装。6.备份原有已安装好的nginx：1cp /usr/local/nginx/sbin/nginx /usr/local/nginx/sbin/nginx.bak 7.停止nginx状态：1/usr/local/nginx/sbin/nginx -s stop 8.将编译好的nginx覆盖掉原有的nginx：123# cd /root/nginx-1.10.1/# cp ./objs/nginx /usr/local/nginx/sbin/ 9.提示是否覆盖，输入yes即可。10.然后启动nginx：1# /usr/local/nginx/sbin/nginx 11.进入nginx/sbin目录下，通过命令查看模块是否已经加入成功：123# cd /usr/local/nginx/sbin/# ./nginx -V openSSL 制作证书一般来说，主流的Web服务软件，通常都基于两种基础密码库：OpenSSL和Java。Tomcat、Weblogic、JBoss等，使用Java提供的密码库。通过Java的Keytool工具，生成Java Keystore（JKS）格式的证书文件。Apache、Nginx等，使用OpenSSL提供的密码库，生成PEM、KEY、CRT等格式的证书文件。此外，IBM的产品，如Websphere、IBM Http Server（IHS）等，使用IBM产品自带的iKeyman工具，生成KDB格式的证书文件。微软Windows Server中的Internet Information Services（IIS），使用Windows自带的证书库生成PFX格式的证书文件。 X.509#DER 二进制格式证书，常用后缀.cer .crtX.509#PEM 文本格式证书，常用后缀.pem有的证书内容是只包含公钥（服务器的公钥），如.crt、.cer、.pem有的证书既包含公钥又包含私钥（服务器的私钥），如.pfx、.p12 在开发和测试环境一般我们使用openssl或keytool等ssl的密码库工具制作证书 生成私钥1openssl genrsa -out rsa_private.key 2048 genrsa： 表示使用rsa算法,openssl还支持RSA, DSA, ECDSA, and EdDSA，2048：表示私钥的大小，单位为位私钥生成后可使用cat 命令查看，其内容为pem格式如果生成的私钥需要密码保护，则可在生成私钥时指定加密算法（后续每次使用私钥时都会要求输入访问秘钥的密码）,其中 passout 代替shell 进行密码输入，否则会提示输入密码:1openssl genssl -aes256 -passout pass:123456 -out rsa_private.key 2048 生成公钥1openssl rsa in rsa_private.key -pubout -out rsa_public.key 生成自签名证书（不基于csr）1openssl req -new -x509 -days 1095 -key private.key -out cert.crt -x509:表示证书格式-day: 表示证书的有效天数根据提示输入相关信息，Common Name 可绑定域名或ip地址，域名可配通配符。 配置nginx123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#user nobody;worker_processes 1;#error_log logs/error.log;#error_log logs/error.log notice;#error_log logs/error.log info;#pid logs/nginx.pid;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; #log_format main &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos; # &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos; # &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;; #access_log logs/access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #gzip on; server &#123; listen 80; server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; location / &#123; root html; index index.html index.htm; &#125; location /tm &#123; proxy_pass http://&#123;host.ip&#125;:3010/mock/167/tm; &#125; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \\.php$ &#123; # proxy_pass http://127.0.0.1; #&#125; # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \\.php$ &#123; # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #&#125; # deny access to .htaccess files, if Apache&apos;s document root # concurs with nginx&apos;s one # #location ~ /\\.ht &#123; # deny all; #&#125; &#125; # another virtual host using mix of IP-, name-, and port-based configuration # #server &#123; # listen 8000; # listen somename:8080; # server_name somename alias another.alias; # location / &#123; # root html; # index index.html index.htm; # &#125; #&#125; # HTTPS server # server &#123; listen 443 ssl; server_name localhost; ssl_certificate /usr/local/nginx/conf/tm_https.pem; # openssl req -new -x509 -days 1095 -key private.key -out tm_https.pem ssl_certificate_key /usr/local/nginx/conf/tm_https.key; # openssl genrsa -out tm_https.key 2048 ssl_session_cache shared:SSL:1m; ssl_session_timeout 5m; ssl_ciphers HIGH:!aNULL:!MD5; ssl_prefer_server_ciphers on; location / &#123; root html; index index.html index.htm; &#125; location /tm &#123; proxy_pass http://&#123;host.ip&#125;:3010/mock/167/tm; &#125; &#125;&#125;","categories":[{"name":"nginx","slug":"nginx","permalink":"http://xdd7130.github.io/categories/nginx/"}],"tags":[{"name":"nginx,linux","slug":"nginx-linux","permalink":"http://xdd7130.github.io/tags/nginx-linux/"}]},{"title":"webgis 常用框架","slug":"webgis","date":"2022-10-12T12:22:12.000Z","updated":"2022-11-02T11:15:20.679Z","comments":true,"path":"2022/10/12/webgis/","link":"","permalink":"http://xdd7130.github.io/2022/10/12/webgis/","excerpt":"","text":"LeafletLeaflet 是最著名的前端地图可视化库，它开源、体积小、结构清晰、简单易用。 Mapbox GL JSMapbox GL JS 是目前最新潮的前端地图库，它的矢量压缩、动态样式和三维性能令人印象深刻。它本身是开源的，但一般依赖于Mapbox公司提供的底图服务。 ArcGIS API for JSArcGIS API for JS 是较为学院派的前端地图库，它是ArcGIS开发套件中的一部分，和桌面端和服务器端ArcGIS软件有较好的协作。它不开源且收费不低，在学术场景下较为常用。 OpenlayersOpenlayers 也是常用的前端地图库，它开源，相比于Leaflet更加复杂和完备。 CesiumCesium 是三维地理可视化的常用库，在大尺度的可视化（地形、建筑、地球）中十分常用。 百度地图 JS API /百度地图 API GL百度地图 JS API 是传统的二维地图，百度地图 API GL 是三维地图，它们依赖百度地图提供的后台服务。除了地图服务外还有检索、导航、实时交通等关联服务。开发者有免费的限额。 高德地图 JS API高德地图 JS API 与百度类似。 Google Maps JS API谷歌地图 JS API 在境外有更好的数据。 AntV L7AntV L7 是空间数据可视化库，它可以使用高德地图等协作构建地图可视化。 Mapbox.jsMapbox.js 是 Leaflet 的一个扩展插件（与 Mapbox GL JS 不同）。","categories":[{"name":"webgis","slug":"webgis","permalink":"http://xdd7130.github.io/categories/webgis/"}],"tags":[{"name":"webgis","slug":"webgis","permalink":"http://xdd7130.github.io/tags/webgis/"}]},{"title":"服务器渲染SSR","slug":"SSR","date":"2022-10-10T03:11:11.000Z","updated":"2022-11-02T11:15:20.543Z","comments":true,"path":"2022/10/10/SSR/","link":"","permalink":"http://xdd7130.github.io/2022/10/10/SSR/","excerpt":"","text":"服务端渲染，就是服务器返回一堆html字符串，然后让浏览器显示。与客户端渲染CSR对应，CSR和SSR最大的区别在于前者的页面渲染是JS负责进行的，而后者是服务器端直接返回HTML让浏览器直接渲染。","categories":[{"name":"笔记","slug":"笔记","permalink":"http://xdd7130.github.io/categories/笔记/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://xdd7130.github.io/tags/笔记/"}]},{"title":"linux部署nginx","slug":"linux部署nginx","date":"2022-09-14T12:22:12.000Z","updated":"2025-02-15T04:02:15.962Z","comments":true,"path":"2022/09/14/linux部署nginx/","link":"","permalink":"http://xdd7130.github.io/2022/09/14/linux部署nginx/","excerpt":"","text":"下载nginx linux版本1地址： http://nginx.org/en/download.html 下载nginx tar包 通过 mobaXterms/xftp上传到linux服务器 解压1tar -zxvf nginx-1.20.2.tar.gz 进入nginx-1.20.2目录，运行configure文件12cd nginx-1.20.2./configure make –&gt; make install12makemake install 查看nginx所在目录1whereis nginx // /usr/local/nginx 进入sbin目录启动12cd sbin./nginx 进入conf查看端口1cat nginx.conf nginx 常用命令12345./nginx // 启动nginx./nginx -s stop // 停止nginx./nginx -s reload // 重新加载配置./nginx -v // 查看版本号ps -ef | grep nginx 查看nginx进程 其他HTTP 全局跳转 HTTPS 的设置代码 497 是 nginx 在遇到 HTTP 请求发到 HTTPS 时会产生的内部错误代码，因此我们将返回一个 307 的回复（307 Temporary Redirect是HTTP协议中的一个状态码（Status Code）。可以理解为一个临时的重定向1error_page 497 =307 https://$host:$server_port$request_uri;","categories":[{"name":"nginx","slug":"nginx","permalink":"http://xdd7130.github.io/categories/nginx/"}],"tags":[{"name":"nginx,linux","slug":"nginx-linux","permalink":"http://xdd7130.github.io/tags/nginx-linux/"}]},{"title":"linux部署yapi","slug":"linux部署yapi","date":"2022-09-14T12:22:12.000Z","updated":"2022-11-02T11:15:20.553Z","comments":true,"path":"2022/09/14/linux部署yapi/","link":"","permalink":"http://xdd7130.github.io/2022/09/14/linux部署yapi/","excerpt":"","text":"yapi解压1unzip yapi20220224.zip 安装node官网下载node(略)解压压缩包1tar -xvf node-v16.17.0-linux-x64.tar.xz 将解压的 node 文件进行重命名，方便后续的操作1mv node-v16.17.0-linux-x64 nodejs 全局引用12引入npm：ln -s /opt/yapiMock/nodejs/bin/npm /usr/local/bin引入node：ln -s /opt/yapiMock/nodejs/bin/node /usr/local/bin 查看全局是否生效12npm –vnode -v 安装pm21npm install pm2 -g 安装mongodb下载安装包(略)下载完成后解压缩压缩包1tar zxf mongodb-linux-x86_64-rhel70-5.0.3.tgz 安装准备将mongodb移动到/usr/local/server/mongdb文件夹1mv mongodb-linux-i686-2.2.3 /usr/local/mongodb 创建数据库文件夹与日志文件12mkdir /usr/local/mongodb/datatouch /usr/local/mongodb/logs 设置开机自启动1echo &quot;/usr/local/mongodb/bin/mongod --dbpath=/usr/local/mongodb/data –logpath=/usr/local/mongodb/logs –logappend --auth –port=27017&quot; &gt;&gt; /etc/rc.local 启动mongodb1/usr/local/mongodb/bin/mongod --dbpath=/usr/local/mongodb/data --logpath=/usr/local/mongodb/logs/mongodb.log --logappend --port=27017 --bind_ip=10.40.128.3 --fork","categories":[{"name":"笔记","slug":"笔记","permalink":"http://xdd7130.github.io/categories/笔记/"}],"tags":[{"name":"mock,linux","slug":"mock-linux","permalink":"http://xdd7130.github.io/tags/mock-linux/"}]},{"title":"Redux-saga","slug":"redux-saga","date":"2021-01-30T06:27:51.000Z","updated":"2022-11-02T11:15:20.673Z","comments":true,"path":"2021/01/30/redux-saga/","link":"","permalink":"http://xdd7130.github.io/2021/01/30/redux-saga/","excerpt":"","text":"","categories":[{"name":"React","slug":"React","permalink":"http://xdd7130.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://xdd7130.github.io/tags/React/"}]},{"title":"Hooks","slug":"react-hooks","date":"2021-01-23T07:25:06.000Z","updated":"2022-11-02T11:15:20.670Z","comments":true,"path":"2021/01/23/react-hooks/","link":"","permalink":"http://xdd7130.github.io/2021/01/23/react-hooks/","excerpt":"","text":"hooks常用api有：useState、useEffect、useContext、useReducer、useRef,useMemo,useCallback,等。 React Hook是React 16.8版本之后添加的新属性，用最简单的话来说，React Hook就是一些React提供的内置函数，这些函数可以让Function Component和Class Component一样能够拥有组件状态（state）以及进行副作用（side effect）。 🌴useState作用useState和Class Component的this.state一样，用来管理组件状态。在React Hook没出来之前，Function Component也叫做Functional Stateless Component（FSC），这是因为Function Component每次执行的时候都会生成新的函数作用域所以同一个组件的不同渲染（render）之间是不能够共用状态的，因此开发者一旦需要在组件中引入状态就需要将原来的Function Component改成Class Component，这使得开发者的体验十分不好。useState就是用来解决这个问题的，它允许Function Component将自己的状态持久化到React运行时（runtime）的某个地方（memory cell），这样在组件每次重新渲染的时候都可以从这个地方拿到该状态，而且当该状态被更新的时候，组件也会重渲染。 用法1const [state, setState] = useState(initialState) useState接收一个initialState变量作为状态的初始值，返回值是一个数组。返回数组的第一个元素代表当前state的最新值，第二个元素是一个用来更新state的函数。这里要注意的是state和setState这两个变量的命名不是固定的，应该根据你业务的实际情况选择不同的名字，可以是text和setText，也可以是width和setWidth这类的命名。 我们在实际开发中，一个组件可能不止一个state，如果组件有多个state，则可以在组件内部多次调用useState，以下是一个简单的例子：12345678910111213141516171819202122232425262728import React, &#123; useState &#125; from &apos;react&apos;import ReactDOM from &apos;react-dom&apos;const App = () =&gt; &#123; const [counter, setCounter] = useState(0) const [text, setText] = useState(&apos;&apos;) const handleTextChange = (event) =&gt; &#123; setText(event.target.value) &#125; return ( &lt;&gt; &lt;div&gt;Current counter: &#123;counter&#125;&lt;/div&gt; &lt;button onClick=&#123;() =&gt; setCounter(counter + 1)&#125; &gt; Increase counter &lt;/button&gt; &lt;input onChange=&#123;handleTextChange&#125; value=&#123;text&#125; /&gt; &lt;/&gt; )&#125;ReactDOM.render(&lt;App /&gt;, document.getElementById(&apos;root&apos;)) 和Class Component的this.setState API类似，setCounter和setText都可以接收一个函数为参数，这个函数叫做updater，updater接收的参数是当前状态的最新值，返回值是下一个状态。例如setCounter的参数可以改成一个函数： 1234567&lt;button onClick=&#123;() =&gt; &#123; setCounter(counter =&gt; counter + 1) &#125;&#125;&gt; Increase counter&lt;/button&gt; useState的initialState也可以是一个用来生成状态初始值的函数，这种做法主要是避免组件每次渲染的时候initialState需要被重复计算。下面是个简单的例子： [state, setState] 123 const initialState = someExpensiveComputation(props) return initialState&#125;) 注意事项: setState是全量替代 Function Component的setState和Class Component的this.setState函数的一个重要区别是this.setState函数是将当前设置的state浅归并（shallowly merge）到旧state的操作。而setState函数则是将新state直接替换旧的state（replace）。因此我们在编写Function Component的时候，就要合理划分state，避免将没有关系的状态放在一起管理， 设置相同的state值时setState会bailing out of update 如果setState接收到的新的state和当前的state是一样的（判断方法是Object.is），React将不会重新渲染子组件或者触发side effect。这里要注意的是虽然React不会渲染子组件，不过它还是会重新渲染当前的组件的，如果你的组件渲染有些很耗性能的计算的话，可以考虑使用useMemo来优化性能 setState没有回调函数 无论是useState还是Class Component的this.setState都是异步调用的，也就是说每次组件调用完它们之后都不能拿到最新的state值。为了解决这个问题，Class Component的this.setState允许你通过一个回调函数来获取到最新的state值，用法如下：123this.setState(newState, state =&gt; &#123; console.log(\"I get new state\", state)&#125;) 🌴useEffect作用useEffect是用来使Function Component也可以进行副作用的，何为副作用，函数的副作用就是函数除了返回值外对外界环境造成的其它影响。在React的世界里，我们的副作用大体可以分为两类，一类是调用浏览器的API，例如使用addEventListener来添加事件监听函数等，另外一类是发起获取服务器数据的请求。Function Component中使用useEffect来定义副作用了。虽然useEffect基本可以覆盖componentDidMount， componentDidUpdate，componentWillUnmount等生命周期函数组合起来使用的所有场景，但是useEffect和生命周期函数的设计理念还是存在本质上的区别的 用法dependencies?)```1234567891011121314151617181920212223useEffect的第一个参数effect是要执行的副作用函数，它可以是任意的用户自定义函数，用户可以在这个函数里面操作一些浏览器的API或者和外部环境进行交互，这个函数会在每次组件渲染完成之后被调用，例如下面是一个简单的例子：```bashimport React, &#123; useState, useEffect &#125; from &apos;react&apos;import ReactDOM from &apos;react-dom&apos;const UserDetail = (&#123; userId &#125;) =&gt; &#123; const [userDetail, setUserDetail] = useState(&#123;&#125;) useEffect(() =&gt; &#123; fetch(`https://myapi/users/$&#123;userId&#125;`) .then(response =&gt; response.json()) .then(user =&gt; setUserDetail(userDetail)) &#125;) return ( &lt;div&gt; &lt;div&gt;User Name: &#123;userDetail.name&#125;&lt;/div&gt; &lt;/div&gt; )&#125;ReactDOM.render(&lt;UserDetail /&gt;, document.getElementById(&apos;root&apos;)) 上面定义的获取用户详情信息的副作用会在UserDetail组件每次完成渲染后执行，所以当该组件第一次挂载的时候就会向服务器发起获取用户详情信息的请求然后更新userDetail的值，这里的第一次挂载我们可以类比成Class Component的componentDidMount。可是如果试着运行一下上面的代码的话，你会发现代码进入了死循环：组件会不断向服务端发起请求。出现这个死循环的原因是useEffect里面调用了setUserDetail，这个函数会更新userDetail的值，从而使组件重渲染，而重渲染后useEffect的effect继续被执行，进而组件再次重渲染。。。为了避免重复的副作用执行，useEffect允许我们通过第二个参数dependencies来限制该副作用什么时候被执行：指明了dependencies的副作用，只有在dependencies数组里面的元素的值发生变化时才会被执行，因此如果要避免上面的代码进入死循环我们就要将userId指定为我们定义的副作用的dependencies：1234567891011121314151617181920import React, &#123; useState, useEffect &#125; from 'react'import ReactDOM from 'react-dom'const UserDetail = (&#123; userId &#125;) =&gt; &#123; const [userDetail, setUserDetail] = useState(&#123;&#125;) useEffect(() =&gt; &#123; fetch(`https://myapi/users/$&#123;userId&#125;`) .then(response =&gt; response.json()) .then(user =&gt; setUserDetail(userDetail)) &#125;, [userId]) return ( &lt;div&gt; &lt;div&gt;User Name: $&#123;userDetail.name&#125;&lt;/div&gt; &lt;/div&gt; )&#125;ReactDOM.render(&lt;UserDetail /&gt;, document.getElementById('root')) 除了发起服务端的请求外，我们往往还需要在useEffect里面调用浏览器的API，例如使用addEventListener来添加浏览器事件的监听函数等。我们一旦使用了addEventListener就必须在合适的时候调用removeEventListener来移除对事件的监听，否则会有性能问题，useEffect允许我们在副作用函数里面返回一个cleanup函数，这个函数会在组件重新渲染之前被执行，我们可以在这个返回的函数里面移除对事件的监听，下面是一个具体的例子： 12345678910111213141516171819202122import React, &#123; useEffect &#125; from 'react'import ReactDOM from 'react-dom'const WindowScrollListener = () =&gt; &#123; useEffect(() =&gt; &#123; const handleWindowScroll = () =&gt; console.log('yean, window is scrolling!') window.addEventListener('scroll', handleWindowScroll) // this is clean up function return () =&gt; &#123; window.removeEventListener(handleWindowScroll) &#125; &#125;, []) return ( &lt;div&gt; I can listen to the window scroll event! &lt;/div&gt; )&#125;ReactDOM.render(&lt;WindowScrollListener /&gt;, document.getElementById('root')) 上面的代码中我们会在WindowScrollListener组件首次渲染完成后注册一个监听页面滚动事件的函数，并在组件下一次渲染前移除该监听函数。由于我们指定了一个空数组作为这个副作用的dependencies，所以这个副作用只会在组件首次渲染时被执行一次，而它的cleanup函数只会在组件unmount时才被执行，这就避免了频繁注册页面监听函数从而影响页面的性能。 注意事项 避免使用“旧的”变量","categories":[{"name":"React","slug":"React","permalink":"http://xdd7130.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://xdd7130.github.io/tags/React/"}]},{"title":"Redux","slug":"react-redux","date":"2021-01-17T14:25:42.000Z","updated":"2022-11-02T11:15:20.671Z","comments":true,"path":"2021/01/17/react-redux/","link":"","permalink":"http://xdd7130.github.io/2021/01/17/react-redux/","excerpt":"","text":"🌴 Redux🌴 React-Reduxdemo代码 UI组件只负责 UI 的呈现，不带有任何业务逻辑没有状态（即不使用this.state这个变量）所有数据都由参数（this.props）提供不使用任何 Redux 的 API 容器组件负责管理数据和业务逻辑，不负责 UI 的呈现带有内部状态使用 Redux 的 APIUI 组件负责 UI 的呈现，容器组件负责管理数据和逻辑。 如果一个组件既有 UI 又有业务逻辑，那怎么办？回答是，将它拆分成下面的结构：外面是一个容器组件，里面包了一个UI 组件。前者负责与外部的通信，将数据传给后者，由后者渲染出视图。 React-Redux 规定，所有的 UI 组件都由用户提供，容器组件则是由 React-Redux 自动生成。也就是说，用户负责视觉层，状态管理则是全部交给它。 connect()12import &#123; connect &#125; from 'react-redux'const VisibleTodoList = connect()(TodoList); 上面VisibleTodoList 便是通过UI组件TodoList,通过connect方法自动生成的容器组件。但需要定义业务逻辑，组件才有意义。123456import &#123; connect &#125; from 'react-redux'const VisibleTodoList = connect( mapStateToProps, mapDispatchToProps)(TodoList) connect方法接受两个参数：mapStateToProps和mapDispatchToProps。它们定义了 UI 组件的业务逻辑。前者负责输入逻辑，即将state映射到 UI 组件的参数（props），后者负责输出逻辑，即将用户对 UI 组件的操作映射成 Action。 mapStateToProps()它是一个函数，建立一个从（外部的）state对象到（UI 组件的）props对象的映射关系。mapStateToProps执行后应该返回一个对象，里面的每一个键值对就是一个映射。12345const mapStateToProps = (state) =&gt; &#123; return &#123; todos: getVisibleTodos(state.todos, state.visibilityFilter) &#125;&#125; mapStateToProps是一个函数，它接受state作为参数，返回一个对象。这个对象有一个todos属性，代表 UI 组件的同名参数，后面的getVisibleTodos也是一个函数，可以从state算出 todos 的值。 mapDispatchToProps()mapDispatchToProps是connect函数的第二个参数，用来建立 UI 组件的参数到store.dispatch方法的映射。它定义了哪些用户的操作应该当作 Action，传给 Store。它可以是一个函数，也可以是一个对象。 是函数则会得到dispatch和ownProps（容器组件的props对象）两个参数。12345678910111213const mapDispatchToProps = ( dispatch, ownProps) =&gt; &#123; return &#123; onClick: () =&gt; &#123; dispatch(&#123; type: &apos;SET_VISIBILITY_FILTER&apos;, filter: ownProps.filter &#125;); &#125; &#125;;&#125; 从上面代码可以看到，mapDispatchToProps作为函数，应该返回一个对象，该对象的每个键值对都是一个映射，定义了 UI 组件的参数怎样发出 Action。 是一个对象，它的每个键名也是对应 UI 组件的同名参数，键值应该是一个函数，会被当作 Action creator ，返回的 Action 会由 Redux 自动发出。123456const mapDispatchToProps = &#123; onClick: (filter) =&gt; &#123; type: 'SET_VISIBILITY_FILTER', filter: filter &#125;;&#125; Provider 组件connect方法生成容器组件以后，需要让容器组件拿到state对象，才能生成 UI 组件的参数。React-Redux 提供Provider组件，可以让容器组件拿到state。12345678910111213import &#123; Provider &#125; from 'react-redux'import &#123; createStore &#125; from 'redux'import todoApp from './reducers'import App from './components/App'let store = createStore(todoApp);render( &lt;Provider store=&#123;store&#125;&gt; &lt;App /&gt; &lt;/Provider&gt;, document.getElementById('root'))","categories":[{"name":"React","slug":"React","permalink":"http://xdd7130.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://xdd7130.github.io/tags/React/"}]},{"title":"路由","slug":"react路由","date":"2021-01-14T01:21:19.000Z","updated":"2022-11-02T11:15:20.671Z","comments":true,"path":"2021/01/14/react路由/","link":"","permalink":"http://xdd7130.github.io/2021/01/14/react路由/","excerpt":"","text":"demo代码 基本概念 react-ruter: 核心库 react-router-dom: 基于核心库在 web端 使用的库 react-router-native: 基于核心库在 React Native 使用的库 react-router-config: 用于配置静态路由的库,随着 React Router v4 的引入，不再有集中式路由配置 react-router-redux: 集成 Redux 的库,已经不推荐使用，推荐使用 connected-react-router 和 Redux 进行配合使用 如果只在浏览器端使用，直接安装 react-router-dom. 基本组件 React Router有三大组件： router components 路由器，&lt;BrowserRouter&gt;、&lt;HashRouter&gt; route matching components 路线匹配器，&lt;Route&gt;、&lt;Switch&gt; navigation components 导航，&lt;Link&gt;、&lt;NavLink&gt;、&lt;Redirect&gt; 其他还有 &lt;MemoryRouter&gt; 内存路由组件、&lt;NativeRouter&gt; Native的路由组件、&lt;StaticRouter&gt; 静态路由组件这些路由组件，其中 MemoryRouter 主要用在 ReactNative 这种非浏览器的环境中，因此直接将 URL 的 history 保存在了内容中。StaticRouter 主要用于服务器端渲染 路由器react-router-dom 提供了BrowserRouter 和 HashRouter 两个路由，这两个路由都会创建一个专门的 history 对象。两者之间的主要区别是它们存储 URL 和与 Web 服务器通信的方式 BrowserRouter http://localhost:3000/bydHashRouter http://localhost:3000/#/byd 两者生成的 URL 区别在于有没有 1import &#123; BrowserRouter, Route, Link &#125; from \"react-router-dom\"; BrowserRouter 容器，用来存放 Router、LinkBrowserRouter 提供了如下属性: basename (string) 当前位置的基准 URL forceRefresh (boolean)，在导航的过程中整个页面是否刷新 getUserConfirmation (func)，当导航需要确认时执行的函数。默认是：window.confirm keyLength (number) location.key 的长度。默认是 6 children (node) 要渲染的子节点 HashRouter 不支持 location.key 和 location.state ，所以在浏览器中建议使用 BrowserRouter 路线匹配器 Route： location 与 Route 的 path 匹配时，渲染 Route 中的 Component Route 接受三种渲染方式：&lt;Route component&gt;、&lt;Route render&gt;、&lt;Route children&gt;。(1)render: function 类型，Route 会渲染这个 function 的返回值，可以在函数中附加一些额外的逻辑，所以你可以在render中添加一些逻辑判断，再返回一个要渲染的 component。(2)children: function 类型，比 render 多了 match参数，可以根据 match参数来决定匹配的时候渲染什么，不匹配的时候渲染什么Route 经常用的是 exact、path 以及 component 属性。 exact 是否进行精确匹配，路由 /a 可以和 /a/、/a 匹配。 strict 是否进行严格匹配，指明路径只匹配以斜线结尾的路径，路由/a可以和/a匹配，不能和/a/匹配，相比 exact 会更严格些。 path (string) 标识路由的路径，没有 path 属性的 Route 总是会匹配。 component 表示路径对应显示的组件。 location (object) 除了通过 path 传递路由路径，也可以通过传递 location 对象可以匹配。 sensitive (boolean) 匹配路径时，是否区分大小写。 Route 组件都接收 location、history、match三个 props：三个 props 比较常用的是 match，通过 match.params 可以取到动态参数的值。 Swtich:就近匹配路由，仅渲染一个路由，路由的默认行为是匹配了就直接渲染，大部分场景下这个逻辑是没有问题的，但考虑下面的场景 导航Link 声明路由要跳转的地方 to（string | object | function） 需要跳转到的路径(pathname) 或地址（location）(1)为 string 时 就是一个明确的路径地址(2)为 object 时有如下属性（就是一个location对象）pathname：URL路径。search：URl中查询字符串。hash：URL的hash分段，例如#a-hash。state：表示location中的状态(3)为 function 时，就是一个函数接收当前 location 为参数，然后以字符串或对象的形式返回位置形式 replace (boolean) 为 true 是替换历史记录，false 是新增历史记录 NavLink 功能与 Link 类似不过参数更多，并且可以设置被选中时的样式或者类 exact (boolean) 是否进行精确匹配 strict (boolean) 是否进行严格匹配 to（string | object） 需要跳转到的路径(pathname)或地址（location） activeClassName (string) 是选中状态的类名，我们可以为其添加样式 activeStyle (Object) 元素处于选中状态时，应用于元素的样式 isActive(function) 添加额外逻辑以确定链接是否处于活动状态 Redirect 重定向组件 from (string) 需要重定向的路径，可以包括动态参数 push (boolean) 为 true 时，重定向会将新条目推入历史记录，而不是替换当前条目 to (string | object) 重定向到的路径 exact (boolean) 是否要对 from 进行精确匹配 strict (boolean) 是否要对 from 进行严格匹配 sensitive (boolean) 匹配 from 时是否区分大小写 react-router与react-router-domAPIReact-router：提供了router的核心api。如Router、Route、Switch等，但没有提供有关dom操作进行路由跳转的ap； React-router-dom：提供了BrowserRouter、HashRouter、Link等api，可以通过dom操作触发事件控制路由。 功能React-router：实现了路由的核心功能 React-router-dom：基于React-router，加入了一些在浏览器运行下的一些功能. 例如：Link组件会渲染一个a标签， BrowserRouter使用 HTML5 提供的 history API可以保证你的 UI 界面和 URL 保持同步， HashRouter使用 URL 的 hash 部分保证你的 UI 界面和 URL 保持同步 写法React-router不能通过操作dom控制路由，此时还需引入React-router-dom12mport &#123;Switch, Route, Router&#125; from 'react-router';import &#123;HashHistory, Link&#125; from 'react-router-dom'; React-router-dom在React-router的基础上扩展了可操作dom的api 1import &#123;Swtich, Route, Router, HashHistory, Link&#125; from 'react-router-dom'; 路由跳转React-router：router4.0以上版本用this.props.history.push(‘/path’)实现跳转； router3.0以上版本用this.props.router.push(‘/path’)实现跳转 React-router-dom：直接用this.props.history.push(‘/path’)就可以实现跳转 ####","categories":[{"name":"React","slug":"React","permalink":"http://xdd7130.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://xdd7130.github.io/tags/React/"}]},{"title":"ES6(六) async","slug":"es6-async","date":"2021-01-08T02:25:20.000Z","updated":"2022-11-02T11:15:20.549Z","comments":true,"path":"2021/01/08/es6-async/","link":"","permalink":"http://xdd7130.github.io/2021/01/08/es6-async/","excerpt":"","text":"###","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://xdd7130.github.io/categories/Web前端/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://xdd7130.github.io/tags/ES6/"}]},{"title":"ES6(五) Generator","slug":"es6-generator","date":"2021-01-06T01:13:36.000Z","updated":"2022-11-02T11:15:20.550Z","comments":true,"path":"2021/01/06/es6-generator/","link":"","permalink":"http://xdd7130.github.io/2021/01/06/es6-generator/","excerpt":"","text":"🌴 概述Generator 函数是一个状态机，可以封装多个内部状态。两个特征：1、function关键字与函数名之间有一个星号2、函数体内部使用yield表达式，定义不同的内部状态1234567function* helloWorldGenerator() &#123; yield 'hello'; yield 'world'; return 'ending';&#125;var hw = helloWorldGenerator(); Generator 函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号。不同的是，调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象。必须调用遍历器对象的next方法，使得指针移向下一个状态。也就是说，每次调用next方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个yield表达式（或return语句）为止。换言之，Generator 函数是分段执行的，yield表达式是暂停执行的标记，而next方法可以恢复执行。1234567891011hw.next()// &#123; value: 'hello', done: false &#125;hw.next()// &#123; value: 'world', done: false &#125;hw.next()// &#123; value: 'ending', done: true &#125;hw.next()// &#123; value: undefined, done: true &#125; 综上，调用 Generator 函数，返回一个遍历器对象，代表 Generator 函数的内部指针。以后，每次调用遍历器对象的next方法，就会返回一个有着value和done两个属性的对象。value属性表示当前的内部状态的值，是yield表达式后面那个表达式的值；done属性是一个布尔值，表示是否遍历结束。 🌴 yield 表达式1、yield表达式就是暂停标志。2、yield表达式与return语句相似点：都能返回紧跟在语句后面的那个表达式的值区别：每次遇到yield，函数暂停执行，下一次再从该位置继续向后执行，而return语句不具备位置记忆的功能。一个函数里面，只能执行一次（或者说一个）return语句，但是可以执行多次（或者说多个）yield表达式。正常函数只能返回一个值，因为只能执行一次return；Generator 函数可以返回一系列的值，因为可以有任意多个yield。3、Generator 函数可以不用yield表达式，这时就变成了一个单纯的暂缓执行函数。123456789function* f() &#123; console.log('执行了！')&#125;var generator = f();setTimeout(function () &#123; generator.next()&#125;, 2000); 4、yield表达式只能用在 Generator 函数里面，用在其他地方都会报错。5、yield表达式如果用在另一个表达式之中，必须放在圆括号里面。1234567function* demo() &#123; console.log('Hello' + yield); // SyntaxError console.log('Hello' + yield 123); // SyntaxError console.log('Hello' + (yield)); // OK console.log('Hello' + (yield 123)); // OK&#125; 6、yield表达式用作函数参数或放在赋值表达式的右边，可以不加括号。1234function* demo() &#123; foo(yield 'a', yield 'b'); // OK let input = yield; // OK&#125; 🌴 next 方法的参数1、yield表达式本身没有返回值，或者说总是返回undefined。2、next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值。123456789101112131415function* foo(x) &#123; var y = 2 * (yield (x + 1)); var z = yield (y / 3); return (x + y + z);&#125;var a = foo(5);a.next() // Object&#123;value:6, done:false&#125;a.next() // Object&#123;value:NaN, done:false&#125;a.next() // Object&#123;value:NaN, done:true&#125;var b = foo(5);b.next() // &#123; value:6, done:false &#125;b.next(12) // &#123; value:8, done:false &#125;b.next(13) // &#123; value:42, done:true &#125; 🌴 for…offor…of循环可以自动遍历 Generator 函数运行时生成的Iterator对象，且此时不再需要调用next方法。一旦next方法的返回对象的done属性为true，for…of循环就会中止，且不包含该返回对象，所以上面代码的return语句返回的6，不包括在for…of循环之中。12345678910111213function* foo() &#123; yield 1; yield 2; yield 3; yield 4; yield 5; return 6;&#125;for (let v of foo()) &#123; console.log(v);&#125;// 1 2 3 4 5 🌴 Generator.prototype.throw()Generator 函数返回的遍历器对象，都有一个throw方法，可以在函数体外抛出错误，然后在 Generator 函数体内捕获。123456789101112131415161718 try &#123; yield; &#125; catch (e) &#123; console.log(&apos;内部捕获&apos;, e); &#125;&#125;;var i = g();i.next();try &#123; i.throw(&apos;a&apos;); i.throw(&apos;b&apos;);&#125; catch (e) &#123; console.log(&apos;外部捕获&apos;, e);&#125;// 内部捕获 a// 外部捕获 b 上面代码中，遍历器对象i连续抛出两个错误。第一个错误被 Generator 函数体内的catch语句捕获。i第二次抛出错误，由于 Generator 函数内部的catch语句已经执行过了，不会再捕捉到这个错误了，所以这个错误就被抛出了 Generator 函数体，被函数体外的catch语句捕获。 throw方法可以接受一个参数，该参数会被catch语句接收，建议抛出Error对象的实例。123456789101112var g = function* () &#123; try &#123; yield; &#125; catch (e) &#123; console.log(e); &#125;&#125;;var i = g();i.next();i.throw(new Error(&apos;出错了！&apos;));// Error: 出错了！(…) 注意，不要混淆遍历器对象的throw方法和全局的throw命令。上面代码的错误，是用遍历器对象的throw方法抛出的，而不是用throw命令抛出的。后者只能被函数体外的catch语句捕获。 123456789101112131415161718192021var g = function* () &#123; while (true) &#123; try &#123; yield; &#125; catch (e) &#123; if (e != &apos;a&apos;) throw e; console.log(&apos;内部捕获&apos;, e); &#125; &#125;&#125;;var i = g();i.next();try &#123; throw new Error(&apos;a&apos;); throw new Error(&apos;b&apos;);&#125; catch (e) &#123; console.log(&apos;外部捕获&apos;, e);&#125;// 外部捕获 [Error: a] 上面代码之所以只捕获了a，是因为函数体外的catch语句块，捕获了抛出的a错误以后，就不会再继续try代码块里面剩余的语句了。 如果 Generator 函数内部没有部署try…catch代码块，那么throw方法抛出的错误，将被外部try…catch代码块捕获。1234567891011121314151617var g = function* () &#123; while (true) &#123; yield; console.log(&apos;内部捕获&apos;, e); &#125;&#125;;var i = g();i.next();try &#123; i.throw(&apos;a&apos;); i.throw(&apos;b&apos;);&#125; catch (e) &#123; console.log(&apos;外部捕获&apos;, e);&#125;// 外部捕获 a 上面代码中，Generator 函数g内部没有部署try…catch代码块，所以抛出的错误直接被外部catch代码块捕获。 如果 Generator 函数内部和外部，都没有部署try…catch代码块，那么程序将报错，直接中断执行。 12345678910var gen = function* gen()&#123; yield console.log(&apos;hello&apos;); yield console.log(&apos;world&apos;);&#125;var g = gen();g.next();g.throw();// hello// Uncaught undefined 上面代码中，g.throw抛出错误以后，没有任何try…catch代码块可以捕获这个错误，导致程序报错，中断执行。 throw方法抛出的错误要被内部捕获，前提是必须至少执行过一次next方法。1234567891011function* gen() &#123; try &#123; yield 1; &#125; catch (e) &#123; console.log(&apos;内部捕获&apos;); &#125;&#125;var g = gen();g.throw(1);// Uncaught 1 上面代码中，g.throw(1)执行时，next方法一次都没有执行过。这时，抛出的错误不会被内部捕获，而是直接在外部抛出，导致程序出错。这种行为其实很好理解，因为第一次执行next方法，等同于启动执行 Generator 函数的内部代码，否则 Generator 函数还没有开始执行，这时throw方法抛错只可能抛出在函数外部。throw方法被捕获以后，会附带执行下一条yield表达式。也就是说，会附带执行一次next方法。1234567891011121314var gen = function* gen()&#123; try &#123; yield console.log(&apos;a&apos;); &#125; catch (e) &#123; // ... &#125; yield console.log(&apos;b&apos;); yield console.log(&apos;c&apos;);&#125;var g = gen();g.next() // ag.throw() // bg.next() // c 上面代码中，g.throw方法被捕获以后，自动执行了一次next方法，所以会打印b。另外，也可以看到，只要 Generator 函数内部部署了try…catch代码块，那么遍历器的throw方法抛出的错误，不影响下一次遍历。另外，throw命令与g.throw方法是无关的，两者互不影响。123456789101112131415var gen = function* gen()&#123; yield console.log(&apos;hello&apos;); yield console.log(&apos;world&apos;);&#125;var g = gen();g.next();try &#123; throw new Error();&#125; catch (e) &#123; g.next();&#125;// hello// world 上面代码中，throw命令抛出的错误不会影响到遍历器的状态，所以两次执行next方法，都进行了正确的操作。 这种函数体内捕获错误的机制，大大方便了对错误的处理。多个yield表达式，可以只用一个try…catch代码块来捕获错误。如果使用回调函数的写法，想要捕获多个错误，就不得不为每个函数内部写一个错误处理语句，现在只在 Generator 函数内部写一次catch语句就可以了。 Generator 函数体外抛出的错误，可以在函数体内捕获；反过来，Generator 函数体内抛出的错误，也可以被函数体外的catch捕获。 123456789101112131415function* foo() &#123; var x = yield 3; var y = x.toUpperCase(); yield y;&#125;var it = foo();it.next(); // &#123; value:3, done:false &#125;try &#123; it.next(42);&#125; catch (err) &#123; console.log(err);&#125; 🌴 Generator.prototype.return()Generator 函数返回的遍历器对象，还有一个return()方法，可以返回给定的值，并且终结遍历 Generator 函数。 1234567891011function* gen() &#123; yield 1; yield 2; yield 3;&#125;var g = gen();g.next() // &#123; value: 1, done: false &#125;g.return(&apos;foo&apos;) // &#123; value: &quot;foo&quot;, done: true &#125;g.next() // &#123; value: undefined, done: true &#125; 如果return()方法调用时，不提供参数，则返回值的value属性为undefined。 上面代码中，遍历器对象g调用return()方法后，返回值的value属性就是return()方法的参数foo。并且，Generator 函数的遍历就终止了，返回值的done属性为true，以后再调用next()方法，done属性总是返回true。 如果return()方法调用时，不提供参数，则返回值的value属性为undefined。 12345678910function* gen() &#123; yield 1; yield 2; yield 3;&#125;var g = gen();g.next() // &#123; value: 1, done: false &#125;g.return() // &#123; value: undefined, done: true &#125; 如果 Generator 函数内部有try…finally代码块，且正在执行try代码块，那么return()方法会导致立刻进入finally代码块，执行完以后，整个函数才会结束。1234567891011121314151617function* numbers () &#123; yield 1; try &#123; yield 2; yield 3; &#125; finally &#123; yield 4; yield 5; &#125; yield 6;&#125;var g = numbers();g.next() // &#123; value: 1, done: false &#125;g.next() // &#123; value: 2, done: false &#125;g.return(7) // &#123; value: 4, done: false &#125;g.next() // &#123; value: 5, done: false &#125;g.next() // &#123; value: 7, done: true &#125; 上面代码中，调用return()方法后，就开始执行finally代码块，不执行try里面剩下的代码了，然后等到finally代码块执行完，再返回return()方法指定的返回值。 🌴 next()、throw()、return() 的共同点next()、throw()、return()这三个方法本质上是同一件事，可以放在一起理解。它们的作用都是让 Generator 函数恢复执行，并且使用不同的语句替换yield表达式。 next()是将yield表达式替换成一个值。 1234567891011const g = function* (x, y) &#123; let result = yield x + y; return result;&#125;;const gen = g(1, 2);gen.next(); // Object &#123;value: 3, done: false&#125;gen.next(1); // Object &#123;value: 1, done: true&#125;// 相当于将 let result = yield x + y// 替换成 let result = 1; 上面代码中，第二个next(1)方法就相当于将yield表达式替换成一个值1。如果next方法没有参数，就相当于替换成undefined。 throw()是将yield表达式替换成一个throw语句。123gen.throw(new Error(&apos;出错了&apos;)); // Uncaught Error: 出错了// 相当于将 let result = yield x + y// 替换成 let result = throw(new Error(&apos;出错了&apos;)); return()是将yield表达式替换成一个return语句。 123gen.return(2); // Object &#123;value: 2, done: true&#125;// 相当于将 let result = yield x + y// 替换成 let result = return 2; 作为对象属性的 Generator 函数如果一个对象的属性是 Generator 函数，可以简写成下面的形式。12345let obj = &#123; * myGeneratorMethod() &#123; ··· &#125;&#125;; 上面代码中，myGeneratorMethod属性前面有一个星号，表示这个属性是一个 Generator 函数。 它的完整形式如下，与上面的写法是等价的。12345let obj = &#123; myGeneratorMethod: function* () &#123; // ··· &#125;&#125;; Generator 函数总是返回一个遍历器，ES6 规定这个遍历器是 Generator 函数的实例，也继承了 Generator 函数的prototype对象上的方法。 12345678910function* g() &#123;&#125;g.prototype.hello = function () &#123; return &apos;hi!&apos;;&#125;;let obj = g();obj instanceof g // trueobj.hello() // &apos;hi!&apos; Generator 函数的thisGenerator 函数总是返回一个遍历器，ES6 规定这个遍历器是 Generator 函数的实例，也继承了 Generator 函数的prototype对象上的方法。12345678910function* g() &#123;&#125;g.prototype.hello = function () &#123; return &apos;hi!&apos;;&#125;;let obj = g();obj instanceof g // trueobj.hello() // &apos;hi!&apos; 上面代码表明，Generator 函数g返回的遍历器obj，是g的实例，而且继承了g.prototype。但是，如果把g当作普通的构造函数，并不会生效，因为g返回的总是遍历器对象，而不是this对象。1234567function* g() &#123; this.a = 11;&#125;let obj = g();obj.next();obj.a // undefined 上面代码中，Generator 函数g在this对象上面添加了一个属性a，但是obj对象拿不到这个属性。 Generator 函数也不能跟new命令一起用，会报错。1234567function* F() &#123; yield this.x = 2; yield this.y = 3;&#125;new F()// TypeError: F is not a constructor 上面代码中，new命令跟构造函数F一起使用，结果报错，因为F不是构造函数。 那么，有没有办法让 Generator 函数返回一个正常的对象实例，既可以用next方法，又可以获得正常的this？ 下面是一个变通方法。首先，生成一个空对象，使用call方法绑定 Generator 函数内部的this。这样，构造函数调用以后，这个空对象就是 Generator 函数的实例对象了。123456789101112131415function* F() &#123; this.a = 1; yield this.b = 2; yield this.c = 3;&#125;var obj = &#123;&#125;;var f = F.call(obj);f.next(); // Object &#123;value: 2, done: false&#125;f.next(); // Object &#123;value: 3, done: false&#125;f.next(); // Object &#123;value: undefined, done: true&#125;obj.a // 1obj.b // 2obj.c // 3 上面代码中，首先是F内部的this对象绑定obj对象，然后调用它，返回一个 Iterator 对象。这个对象执行三次next方法（因为F内部有两个yield表达式），完成 F 内部所有代码的运行。这时，所有内部属性都绑定在obj对象上了，因此obj对象也就成了F的实例。 上面代码中，执行的是遍历器对象f，但是生成的对象实例是obj，有没有办法将这两个对象统一呢？ 一个办法就是将obj换成F.prototype。1234567891011121314function* F() &#123; this.a = 1; yield this.b = 2; yield this.c = 3;&#125;var f = F.call(F.prototype);f.next(); // Object &#123;value: 2, done: false&#125;f.next(); // Object &#123;value: 3, done: false&#125;f.next(); // Object &#123;value: undefined, done: true&#125;f.a // 1f.b // 2f.c // 3 再将F改成构造函数，就可以对它执行new命令了。12345678910111213141516171819function* gen() &#123; this.a = 1; yield this.b = 2; yield this.c = 3;&#125;function F() &#123; return gen.call(gen.prototype);&#125;var f = new F();f.next(); // Object &#123;value: 2, done: false&#125;f.next(); // Object &#123;value: 3, done: false&#125;f.next(); // Object &#123;value: undefined, done: true&#125;f.a // 1f.b // 2f.c // 3 🌴 Generator函数异步编程 回调函数 事件监听 发布/订阅 Promise 对象","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://xdd7130.github.io/categories/Web前端/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://xdd7130.github.io/tags/ES6/"}]},{"title":"ES6(三) Promise","slug":"Promise","date":"2021-01-05T02:25:07.000Z","updated":"2022-11-02T11:15:20.542Z","comments":true,"path":"2021/01/05/Promise/","link":"","permalink":"http://xdd7130.github.io/2021/01/05/Promise/","excerpt":"","text":"参考 🌴 概述首先，Promise 是一个对象，也是一个构造函数。1234function f1(resolve, reject) &#123; // 异步代码&#125;var p1 = new Promise(f1) 上面代码中，Promise构造函数接受一个回调函数f1作为参数，f1里面是异步操作的代码。然后，返回的p1就是一个 Promise 实例。 Promise 的设计思想是，所有异步任务都返回一个 Promise 实例。Promise 实例有一个then方法，用来指定下一步的回调函数。12var p1 = new Promise(f1);p1.then(f2); 上面代码中，f1的异步操作执行完成，就会执行f2。 传统的写法可能需要把f2作为回调函数传入f1，比如写成f1(f2)，异步操作完成后，在f1内部调用f2。Promise 使得f1和f2变成了链式写法。不仅改善了可读性，而且对于多层嵌套的回调函数尤其方便。12345678910111213141516// 传统写法step1(function (value1) &#123; step2(value1, function(value2) &#123; step3(value2, function(value3) &#123; step4(value3, function(value4) &#123; // ... &#125;); &#125;); &#125;);&#125;);// Promise 的写法(new Promise(step1)) .then(step2) .then(step3) .then(step4); 从上面代码可以看到，采用 Promise 以后，程序流程变得非常清楚，十分易读。注意，为了便于理解，上面代码的Promise实例的生成格式，做了简化，真正的语法请参照下文。 总的来说，传统的回调函数写法使得代码混成一团，变得横向发展而不是向下发展。Promise 就是解决这个问题，使得异步流程可以写成同步流程 🌴 关键词👉异步操作解决方案Promise 对象是 JavaScript 的异步操作解决方案，为异步操作提供统一接口。比传统的解决方案:回调函数和事件，更强大,它起到代理作用（proxy），充当异步操作与回调函数之间的中介，使得异步操作具备同步操作的接口。Promise 可以让异步操作写起来，就像在写同步操作的流程，而不必一层层地嵌套回调函数。 👉 三种状态Promise 对象通过自身的状态，来控制异步操作。Promise 实例具有三种状态。 异步操作未完成（pending） 异步操作成功（fulfilled） 异步操作失败（rejected） 上面三种状态里面，fulfilled和rejected合在一起称为resolved（已定型）。 这三种的状态的变化途径只有两种。 从“未完成”到“成功” 从“未完成”到“失败” 一旦状态发生变化，就凝固了，不会再有新的状态变化。这也是 Promise 这个名字的由来，它的英语意思是“承诺”，一旦承诺成效，就不得再改变了。这也意味着，Promise 实例的状态变化只可能发生一次。 因此，Promise 的最终结果只有两种。 异步操作成功，Promise 实例传回一个值（value），状态变为fulfilled。 异步操作失败，Promise 实例抛出一个错误（error），状态变为rejected 👉 Promise API Promise.prototype.catch() Promise.prototype.finally() Promise.all() Promise.race() promise.allSettled() promise.any() Promise.resolve() Promise.reject() Promise.try() 🌴 Promise 构造函数JavaScript 提供原生的Promise构造函数，用来生成 Promise 实例。123456789var promise = new Promise(function (resolve, reject) &#123; // ... if (/* 异步操作成功 */)&#123; resolve(value); &#125; else &#123; /* 异步操作失败 */ reject(new Error()); &#125;&#125;); 上面代码中，Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由 JavaScript 引擎提供，不用自己实现。 resolve函数的作用是，将Promise实例的状态从“未完成”变为“成功”（即从pending变为fulfilled），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去。reject函数的作用是，将Promise实例的状态从“未完成”变为“失败”（即从pending变为rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。 下面是一个例子。12345678910111213function timeout(ms) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(resolve, ms, 'done'); &#125;);&#125;timeout(100).then(function(val)&#123; console.log(val)&#125;)或timeout(100).then((val)=&gt;&#123; console.log(val)&#125;) 上面代码中，timeout(100)返回一个Promise实例。100毫秒以后，该实例的状态会变为fulfilled 🌴 Promise API用法Promise.prototype.then()Promise 实例的then方法，定义在原型对象上，用来添加回调函数。 then方法可以接受两个回调函数，第一个是异步操作成功时（变为fulfilled状态）时的回调函数，第二个是异步操作失败（变为rejected）时的回调函数（该参数可以省略）。一旦状态改变，就调用相应的回调函数。1234567891011var p1 = new Promise(function (resolve, reject) &#123; resolve('成功');&#125;);p1.then(console.log, console.error);// \"成功\"var p2 = new Promise(function (resolve, reject) &#123; reject(new Error('失败'));&#125;);p2.then(console.log, console.error);// Error: 失败 上面代码中，p1和p2都是Promise 实例，它们的then方法绑定两个回调函数：成功时的回调函数console.log，失败时的回调函数console.error（可以省略）。p1的状态变为成功，p2的状态变为失败，对应的回调函数会收到异步操作传回的值，然后在控制台输出。 then方法可以链式使用。12345678p1 .then(step1) .then(step2) .then(step3) .then( console.log, console.error ); 上面代码中，p1后面有四个then，意味依次有四个回调函数。只要前一步的状态变为fulfilled，就会依次执行紧跟在后面的回调函数。 最后一个then方法，回调函数是console.log和console.error，用法上有一点重要的区别。console.log只显示step3的返回值，而console.error可以显示p1、step1、step2、step3之中任意一个发生的错误。举例来说，如果step1的状态变为rejected，那么step2和step3都不会执行了（因为它们是resolved的回调函数）。Promise 开始寻找，接下来第一个为rejected的回调函数，在上面代码中是console.error。这就是说，Promise 对象的报错具有传递性。 Promise 的用法，简单说就是一句话：使用then方法添加回调函数。但是，不同的写法有一些细微的差别，请看下面四种写法，它们的差别在哪里？12345678910111213141516// 写法一f1().then(function () &#123; return f2();&#125;);// 写法二f1().then(function () &#123; f2();&#125;);// 写法三f1().then(f2());// 写法四f1().then(f2); 为了便于讲解，下面这四种写法都再用then方法接一个回调函数f3。写法一的f3回调函数的参数，是f2函数的运行结果。123f1().then(function () &#123; return f2();&#125;).then(f3); 写法二的f3回调函数的参数是undefined。1234f1().then(function () &#123; f2(); return;&#125;).then(f3); 写法三的f3回调函数的参数，是f2函数返回的函数的运行结果。12f1().then(f2()) .then(f3); 写法四与写法一只有一个差别，那就是f2会接收到f1()返回的结果。12f1().then(f2) .then(f3); Promise.prototype.catch()1、Promise.prototype.catch()方法是.then(null, rejection)或.then(undefined, rejection)的别名，用于指定发生错误时的回调函数。123456getJSON('/posts.json').then(function(posts) &#123; // ...&#125;).catch(function(error) &#123; // 处理 getJSON 和 前一个回调函数运行时发生的错误 console.log('发生错误！', error);&#125;); 2、Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个catch语句捕获。1234567getJSON('/post/1.json').then(function(post) &#123; return getJSON(post.commentURL);&#125;).then(function(comments) &#123; // some code&#125;).catch(function(error) &#123; // 处理前面三个Promise产生的错误&#125;); 上面代码中，一共有三个 Promise 对象：一个由getJSON()产生，两个由then()产生。它们之中任何一个抛出的错误，都会被最后一个catch()捕获。3、一般来说，不要在then()方法里面定义 Reject 状态的回调函数（即then的第二个参数），总是使用catch方法。4、catch()方法返回的还是一个 Promise 对象，因此后面还可以接着调用then()方法。 Promise.prototype.finally()1、finally()方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。不管promise最后的状态，在执行完then或catch指定的回调函数以后，都会执行finally方法指定的回调函数。2、不接受任何参数，不依赖promise执行结果。1234promise.then(result =&gt; &#123;···&#125;).catch(error =&gt; &#123;···&#125;).finally(() =&gt; &#123;···&#125;); Promise.all() Promise.all()方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。 1const p = Promise.all([p1, p2, p3]); 1、p1、p2、p3都是 Promise 实例，如果不是，就会先调用下面讲到的Promise.resolve方法，将参数转为 Promise 实例2、Promise.all()方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例3、只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。4、只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数 Promise.race() Promise.race()方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。1const p = Promise.race([p1, p2, p3]); 1、只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。2、Promise.race()方法的参数与Promise.all()方法一样，如果不是 Promise 实例，就会先调用下面讲到的Promise.resolve()方法，将参数转为 Promise 实例，再进一步处理。3、状态不可逆：如果指定时间内没有获得结果，就将 Promise 的状态变为reject，否则变为resolve12345678910const p = Promise.race([ fetch('/resource-that-may-take-a-while'), new Promise(function (resolve, reject) &#123; setTimeout(() =&gt; reject(new Error('request timeout')), 5000) &#125;)]);p.then(console.log).catch(console.error); Promise.allSettled()1、Promise.allSettled()方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例。只有等到所有这些参数实例都返回结果，不管是fulfilled还是rejected，包装实例才会结束2、Promise.allSettled()的返回值allSettledPromise，状态只可能变成fulfilled。、123456789101112const resolved = Promise.resolve(42);const rejected = Promise.reject(-1);const allSettledPromise = Promise.allSettled([resolved, rejected]);allSettledPromise.then(function (results) &#123; console.log(results);&#125;);// [// &#123; status: 'fulfilled', value: 42 &#125;,// &#123; status: 'rejected', reason: -1 &#125;// ] Promise.any()接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例返回。只要参数实例有一个变成fulfilled状态，包装实例就会变成fulfilled状态；如果所有参数实例都变成rejected状态，包装实例就会变成rejected状态。1234567891011const promises = [ fetch('/endpoint-a').then(() =&gt; 'a'), fetch('/endpoint-b').then(() =&gt; 'b'), fetch('/endpoint-c').then(() =&gt; 'c'),];try &#123; const first = await Promise.any(promises); console.log(first);&#125; catch (error) &#123; console.log(error);&#125; Promise.any()方法的参数数组包含三个 Promise 操作。其中只要有一个变成fulfilled，Promise.any()返回的 Promise 对象就变成fulfilled。如果所有三个操作都变成rejected，那么await命令就会抛出错误。 Promise.resolve()1、将现有对象转为 Promise 对象123Promise.resolve('foo')// 等价于new Promise(resolve =&gt; resolve('foo')) 2、Promise.resolve()方法的参数分成四种情况：（1）参数是一个 Promise 实例如果参数是 Promise 实例，那么Promise.resolve将不做任何修改、原封不动地返回这个实例。 （2）参数是一个thenable对象thenable对象指的是具有then方法的对象，比如下面这个对象。thenable对象的then()方法执行后，对象p1的状态就变为resolved，从而立即执行最后那个then()方法指定的回调函数，输出42。12345678910let thenable = &#123; then: function(resolve, reject) &#123; resolve(42); &#125;&#125;;let p1 = Promise.resolve(thenable);p1.then(function (value) &#123; console.log(value); // 42&#125;); (3)参数不是具有then()方法的对象，或根本就不是对象12345const p = Promise.resolve('Hello');p.then(function (s) &#123; console.log(s)&#125;); 生成一个新的 Promise 对象的实例p。由于字符串Hello不属于异步操作（判断方法是字符串对象不具有 then 方法），返回 Promise 实例的状态从一生成就是resolved，所以回调函数会立即执行。Promise.resolve()方法的参数，会同时传给回调函数。 （4）不带有任何参数Promise.resolve()方法允许调用时不带参数，直接返回一个resolved状态的 Promise 对象。 Promise.reject()Promise.reject(reason)方法也会返回一个新的 Promise 实例，该实例的状态为rejected。12345678const p = Promise.reject('出错了');// 等同于const p = new Promise((resolve, reject) =&gt; reject('出错了'))p.then(null, function (s) &#123; console.log(s)&#125;);// 出错了 🌴 小结Promise 的优点在于，让回调函数变成了规范的链式写法，程序流程可以看得很清楚。它有一整套接口，可以实现许多强大的功能，比如同时执行多个异步操作，等到它们的状态都改变以后，再执行一个回调函数；再比如，为多个回调函数中抛出的错误，统一指定处理方法等等。 而且，Promise 还有一个传统写法没有的好处：它的状态一旦改变，无论何时查询，都能得到这个状态。这意味着，无论何时为 Promise 实例添加回调函数，该函数都能正确执行。所以，你不用担心是否错过了某个事件或信号。如果是传统写法，通过监听事件来执行回调函数，一旦错过了事件，再添加回调函数是不会执行的。 Promise 的缺点是，编写的难度比传统写法高，而且阅读代码也不是一眼可以看懂。你只会看到一堆then，必须自己在then的回调函数里面理清逻辑。 🌴 微任务Promise 的回调函数属于异步任务，会在同步任务之后执行。1234567new Promise(function (resolve, reject) &#123; resolve(1);&#125;).then(console.log);console.log(2);// 2// 1 上面代码会先输出2，再输出1。因为console.log(2)是同步任务，而then的回调函数属于异步任务，一定晚于同步任务执行。 但是，Promise 的回调函数不是正常的异步任务，而是微任务（microtask）。它们的区别在于，正常任务追加到下一轮事件循环，微任务追加到本轮事件循环。这意味着，微任务的执行时间一定早于正常任务。123456789101112setTimeout(function() &#123; console.log(1);&#125;, 0);new Promise(function (resolve, reject) &#123; resolve(2);&#125;).then(console.log);console.log(3);// 3// 2// 1 上面代码的输出结果是321。这说明then的回调函数的执行时间，早于setTimeout(fn, 0)。因为then是本轮事件循环执行，setTimeout(fn, 0)在下一轮事件循环开始时执行。","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://xdd7130.github.io/categories/Web前端/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://xdd7130.github.io/tags/ES6/"},{"name":"Promise","slug":"Promise","permalink":"http://xdd7130.github.io/tags/Promise/"}]},{"title":"ES6(四) Iterator","slug":"es6-Iterator","date":"2021-01-05T01:52:51.000Z","updated":"2022-11-02T11:15:20.549Z","comments":true,"path":"2021/01/05/es6-Iterator/","link":"","permalink":"http://xdd7130.github.io/2021/01/05/es6-Iterator/","excerpt":"","text":"遍历器（Iterator）为某种数据结构提供一种统一的访问机制，遍历器本质是一个只针对象 1、JS中表示”集合“的数据结构有：数组（Array），对象（Object），Map和Set。但有的可直接遍历，有的在部署Iterator才可以遍历。2、遍历器为各种不同的数据提供访问机制，任何数据结构只要部署Iterator,就可以遍历处理该数据结构的所有成员。3、遍历器作用： （1）为各种数据结构，提供一个统一的、简便的访问接口； （2）使得数据结构的成员能够按某种次序排列； （3）ES6 创造了一种新的遍历命令for…of循环，Iterator 接口主要供for…of消费 4、遍历过程过程： （1）创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。 （2）第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员。 （3）第二次调用指针对象的next方法，指针就指向数据结构的第二个成员。 （4）不断调用指针对象的next方法，直到它指向数据结构的结束位置。 每一次调用next方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含value和done两个属性的对象。其中，value属性是当前成员的值，done属性是一个布尔值，表示遍历是否结束 默认Iterator接口1、Iterator 接口的目的，就是为所有数据结构，提供了一种统一的访问机制，即for…of循环；2、一种数据结构只要部署了 Iterator 接口，我们就称这种数据结构是“可遍历的”（iterable）3、ES6 规定，默认的 Iterator 接口部署在数据结构的 Symbol.iterator 属性，即，一个数据结构只要具有Symbol.iterator属性，就可以认为是“可遍历的”（iterable）。","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://xdd7130.github.io/categories/Web前端/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://xdd7130.github.io/tags/ES6/"}]},{"title":"生命周期","slug":"React生命周期","date":"2020-12-29T11:33:26.000Z","updated":"2022-11-02T11:15:20.543Z","comments":true,"path":"2020/12/29/React生命周期/","link":"","permalink":"http://xdd7130.github.io/2020/12/29/React生命周期/","excerpt":"","text":"在组件的整个生命周期中，随着该组件的props或者state发生改变，其DOM表现也会有相应的变化。 一个组件就是一个状态机，对于特定地输入，它总返回一致的输出。 一个React组件的生命周期分为三个部分：实例化、存在期和销毁时。 React应用中，组件加载顺序及生命周期如下图所示： constructor( )constructor是ES6对类的默认方法，通过 new 命令生成对象实例时自动调用该方法。并且，该方法是类中必须有的，如果没有显示定义，则会默认添加空的constructor( )方法。当存在constructor的时候⚠️必须手动调用super方法。 在constructor中如果要访问this.props需要传入props，示例如下：1234567891011121314151617class MyClass extends React.component&#123; constructor(props)&#123; super(props); // 声明constructor时必须调用super方法 console.log(this.props); // 可以正常访问this.props &#125;&#125;constructor 常用来初始化stateclass MyClass extends React.Component &#123; constructor(props)&#123; super(props); this.state = &#123; list: this.props.List &#125;; &#125;&#125; componentWillMount()该方法在组件挂载之前生效。 在组件挂载之前调用且全局只调用一次。如果在这个钩子里可以setState，render后可以看到更新后的state，不会触发重复渲染。该生命周期可以发起异步请求，并setState。（React v16.3后废弃该生命周期，可以在constructor中完成设置state） render()render是一个React组件必须定义的生命周期，用来渲染dom。⚠️不要在render里面修改state，会触发死循环导致栈溢出。render必须返回reactDom。123456789render() &#123; const &#123;nodeResultData: &#123;res&#125; = &#123;&#125;&#125; = this.props; if (isEmpty(res)) return noDataInfo; const nodeResult = this.getNodeResult(res); return ( &lt;div className=\"workspace-dialog-result\"&gt; &#123;nodeResult&#125; &lt;/div&gt; ); componentDidMount()在组件挂载完成后调用，且全局只调用一次。可以在这里使用refs，获取真实dom元素。该钩子内也可以发起异步请求，并在异步请求中可以进行setState。123456componentDidMount() &#123; axios.get('/auth/getTemplate').then(res =&gt; &#123; const &#123;TemplateList = []&#125; = res; this.setState(&#123;TemplateList&#125;); &#125;);&#125; componentWillReceiveProps (nextProps )props发生变化以及父组件重新渲染时都会触发该生命周期，在该钩子内可以通过参数nextProps获取变化后的props参数，通过this.props访问之前的props。该生命周期内可以进行setState。(React v16.3后废弃该生命周期，可以用新的周期 static getDerivedStateFromProps 代替) shouldComponentUpdate(nextProps, nextState)用于判断是否重新渲染，组件挂载之后，每次调用setState后都会调用shouldComponentUpdate判断是否需要重新渲染组件。默认返回true，需要重新render。返回false则不触发渲染。在比较复杂的应用里，有一些数据的改变并不影响界面展示，可以在这里做判断，优化渲染效率。 componentWillUpdate(nextProps, nextState)shouldComponentUpdate返回true或者调用forceUpdate之后，componentWillUpdate会被调用。不能在该钩子中setState，会触发重复循环。(React v16.3后废弃该生命周期，可以用新的周期 getSnapshotBeforeUpdate) componentDidUpdate()完成组件渲染，除了首次render之后调用componentDidMount，其它render结束之后都是调用componentDidUpdate。该钩子内setState有可能会触发重复渲染，需要自行判断，否则会进入死循环。1234567componentDidUpdate() &#123; if(condition) &#123; this.setState(&#123;..&#125;) // 设置state &#125; else &#123; // 不再设置state &#125;&#125; componentWillUnmount()组件被卸载的时候调用。一般在componentDidMount里面注册的事件需要在这里删除。","categories":[{"name":"React","slug":"React","permalink":"http://xdd7130.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://xdd7130.github.io/tags/React/"}]},{"title":"ES6(二) Set和Map","slug":"ES6-setmap","date":"2020-11-23T11:18:34.000Z","updated":"2022-11-02T11:15:20.541Z","comments":true,"path":"2020/11/23/ES6-setmap/","link":"","permalink":"http://xdd7130.github.io/2020/11/23/ES6-setmap/","excerpt":"","text":"🌴 Set 和 WeakSet数据结构👉 Set：1、ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。 12345678910111213141516//add方法const s = new Set();[2, 3, 5, 4, 5, 2, 2].forEach(x =&gt; s.add(x));for (let i of s) &#123;console.log(i);&#125;// 2 3 5 4// 一、 数组去重[...new Set(array)]// 二、Array.from方法可以将 Set 结构转为数组。const items = new Set([1, 2, 3, 4, 5]);const array = Array.from(items); 2、Set 实例的属性和方法 实例属性：Set.prototype.constructor：构造函数，默认就是Set函数。Set.prototype.size：返回Set实例的成员总数。 实例方法:Set.prototype.add(value)：添加某个值，返回 Set 结构本身。Set.prototype.delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。Set.prototype.has(value)：返回一个布尔值，表示该值是否为Set的成员。Set.prototype.clear()：清除所有成员，没有返回值。 例：1234567891011s.add(1).add(2).add(2);// 注意2被加入了两次s.size // 2s.has(1) // trues.has(2) // trues.has(3) // falses.delete(2);s.has(2) // false 3、遍历操作 四个遍历方法： Set.prototype.keys()：返回键名的遍历器Set.prototype.values()：返回键值的遍历器Set.prototype.entries()：返回键值对的遍历器Set.prototype.forEach()：使用回调函数遍历每个成员 WeakSetWeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别:1、WeakSet 的成员只能是对象，而不能是其他类型的值。2、WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用 WeakSet 结构有以下三个方法： WeakSet.prototype.add(value)：向 WeakSet 实例添加一个新成员。WeakSet.prototype.delete(value)：清除 WeakSet 实例的指定成员。WeakSet.prototype.has(value)：返回一个布尔值，表示某个值是否在 WeakSet 实例之中 🌴 Map 和 WeakMap数据结构MapJavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键123456789const m = new Map();const o = &#123;p: 'Hello World'&#125;;m.set(o, 'content')m.get(o) // \"content\"m.has(o) // truem.delete(o) // truem.has(o) // false 如果对同一个键多次赋值，后面的值将覆盖前面的值：1234567const map = new Map();map.set(1, 'aaa').set(1, 'bbb');map.get(1) // \"bbb\" 如果读取一个未知的键，则返回undefined。12new Map().get('asfddfsasadf')// undefined 注意，只有对同一个对象的引用，Map 结构才将其视为同一个键。1234const map = new Map();map.set(['a'], 555);map.get(['a']) // undefined 上面代码的set和get方法，表面是针对同一个键，但实际上这是两个不同的数组实例，内存地址是不一样的，因此get方法无法读取该键，返回undefined。同样的值的两个实例，在 Map 结构中被视为两个键。1234567891011const map = new Map();const k1 = ['a'];const k2 = ['a'];map.set(k1, 111).set(k2, 222);map.get(k1) // 111map.get(k2) // 222 另外：123456789101112131415let map = new Map();map.set(-0, 123);map.get(+0) // 123map.set(true, 1);map.set('true', 2);map.get(true) // 1map.set(undefined, 3);map.set(null, 4);map.get(undefined) // 3map.set(NaN, 123);map.get(NaN) // 123 实例的属性和操作方法1、size 属性size属性返回 Map 结构的成员总数2、Map.prototype.set(key, value)set方法设置键名key对应的键值为value，然后返回整个 Map 结构。如果key已经有值，则键值会被更新，否则就新生成该键。set方法返回的是当前的Map对象，因此可以采用链式写法。3、Map.prototype.get(key)get方法读取key对应的键值，如果找不到key，返回undefined。4、Map.prototype.has(key)has方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。5、Map.prototype.delete(key)delete方法删除某个键，返回true。如果删除失败，返回false。6、Map.prototype.clear()clear方法清除所有成员，没有返回值。 遍历方法Map.prototype.keys()：返回键名的遍历器。Map.prototype.values()：返回键值的遍历器。Map.prototype.entries()：返回所有成员的遍历器。Map.prototype.forEach()：遍历 Map 的所有成员。 Map 结构转为数组结构，比较快速的方法是使用扩展运算符（…）。1234567891011121314151617const map = new Map([ [1, 'one'], [2, 'two'], [3, 'three'],]);[...map.keys()]// [1, 2, 3][...map.values()]// ['one', 'two', 'three'][...map.entries()]// [[1,'one'], [2, 'two'], [3, 'three']][...map]// [[1,'one'], [2, 'two'], [3, 'three']] 与其他数据结构的互相转换1、Map 转为数组12345const myMap = new Map() .set(true, 7) .set(&#123;foo: 3&#125;, ['abc']);[...myMap]// [ [ true, 7 ], [ &#123; foo: 3 &#125;, [ 'abc' ] ] ] 2、数组 转为 Map将数组传入 Map 构造函数，就可以转为 Map。12345678new Map([ [true, 7], [&#123;foo: 3&#125;, ['abc']]])// Map &#123;// true =&gt; 7,// Object &#123;foo: 3&#125; =&gt; ['abc']// &#125; 3、Map 转为对象如果所有 Map 的键都是字符串，它可以无损地转为对象12345678910111213function strMapToObj(strMap) &#123; let obj = Object.create(null); for (let [k,v] of strMap) &#123; obj[k] = v; &#125; return obj;&#125;const myMap = new Map() .set('yes', true) .set('no', false);strMapToObj(myMap)// &#123; yes: true, no: false &#125; 如果有非字符串的键名，那么这个键名会被转成字符串，再作为对象的键名。 4、对象转为 Map对象转为 Map 可以通过Object.entries()。12345678910111213141516let obj = &#123;\"a\":1, \"b\":2&#125;;let map = new Map(Object.entries(obj));//此外，也可以自己实现一个转换函数。function objToStrMap(obj) &#123; let strMap = new Map(); for (let k of Object.keys(obj)) &#123; strMap.set(k, obj[k]); &#125; return strMap;&#125;objToStrMap(&#123;yes: true, no: false&#125;)// Map &#123;\"yes\" =&gt; true, \"no\" =&gt; false&#125; 5、Map 转为 JSONMap 转为 JSON 要区分两种情况:一种情况是，Map 的键名都是字符串，这时可以选择转为对象 JSON。1234567function strMapToJson(strMap) &#123; return JSON.stringify(strMapToObj(strMap));&#125;let myMap = new Map().set('yes', true).set('no', false);strMapToJson(myMap)// '&#123;\"yes\":true,\"no\":false&#125;' 另一种情况是，Map 的键名有非字符串，这时可以选择转为数组 JSON。1234567function mapToArrayJson(map) &#123; return JSON.stringify([...map]);&#125;let myMap = new Map().set(true, 7).set(&#123;foo: 3&#125;, ['abc']);mapToArrayJson(myMap)// '[[true,7],[&#123;\"foo\":3&#125;,[\"abc\"]]]' 6、JSON 转为 Map JSON 转为 Map，正常情况下，所有键名都是字符串。123456function jsonToStrMap(jsonStr) &#123; return objToStrMap(JSON.parse(jsonStr));&#125;jsonToStrMap('&#123;\"yes\": true, \"no\": false&#125;')// Map &#123;'yes' =&gt; true, 'no' =&gt; false&#125; 但是，有一种特殊情况，整个 JSON 就是一个数组，且每个数组成员本身，又是一个有两个成员的数组。这时，它可以一一对应地转为 Map。这往往是 Map 转为数组 JSON 的逆操作。123456function jsonToMap(jsonStr) &#123; return new Map(JSON.parse(jsonStr));&#125;jsonToMap('[[true,7],[&#123;\"foo\":3&#125;,[\"abc\"]]]')// Map &#123;true =&gt; 7, Object &#123;foo: 3&#125; =&gt; ['abc']&#125;","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://xdd7130.github.io/categories/Web前端/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://xdd7130.github.io/tags/ES6/"}]},{"title":"ES6(一)","slug":"ES6","date":"2020-10-25T11:18:34.000Z","updated":"2022-11-02T11:15:20.541Z","comments":true,"path":"2020/10/25/ES6/","link":"","permalink":"http://xdd7130.github.io/2020/10/25/ES6/","excerpt":"","text":"🌴 let 与 const👉 总结： let :声明的变量只在 let 命令所在的代码块内有效，且只能声明一次，多次声明，报错：“Identifier XX has already been declared”,for循环很适合let。 const:声明一个只读的常量，一旦声明，常量的值就不能改变。 👉 比较：1、不存在变量提升：let没有预解析，不存在变量提升，var 会变量提升。 12345678console.log(a); // undefined ===&gt; a已声明还没赋值，默认得到undefined值var a = 100;console.log(b); // 报错：b is not defined ===&gt; 找不到b这个变量let b = 10;console.log(c); // 报错：c is not defined ===&gt; 找不到c这个变量const c = 10; 2、const 声明一个只读变量，声明之后不允许改变。意味着，一旦声明必须初始化，否则会报错。3、暂时性死区：代码块内如果存在 let 或者 const，代码块会对这些命令声明的变量从块的开始就形成一个封闭作用域。4、var声明的变量会挂载在window上，而let和const声明的变量不会。 12345678var a = 100;console.log(a,window.a); // 100 100let b = 10;console.log(b,window.b); // 10 undefinedconst c = 1;console.log(c,window.c); // 1 undefined 👉 注意:对于简单类型（数值 number、字符串 string 、布尔值 boolean）,值就保存在变量指向的那个内存地址，因此 const 声明的简单类型变量等同于常量。复杂类型（对象 object，数组 array，函数 function），变量指向的内存地址其实是保存了一个指向实际数据的指针，所以 const 只能保证指针是固定的，至于指针指向的数据结构变不变就无法控制了，所以使用 const 声明复杂类型对象时要慎重。 🌴 解构赋值解构赋值是对赋值运算符的扩展。 他是一种针对数组或者对象进行模式匹配，然后对其中的变量进行赋值。 在代码书写上简洁且易读，语义更加清晰明了；也方便了复杂对象中数据字段获取。在解构中，有下面两部分参与： 解构的源，解构赋值表达式的右边部分。解构的目标，解构赋值表达式的左边部分。 一一对应的关系 123456789101112131415161718192021222324let [a,b,c] = [1,2,3];let [a,[b,c]] = [1,[2,3]];let json = &#123; name:'DANDAN', age:18, job:\"打工人\"&#125;let &#123;name,age,job&#125; = &#123; nama:\"DANDAN\", age:18, job:\"打工人\"&#125;//别名let &#123;name:n,age:g,job:b&#125; = jsonconsole.log(n,g,b)//解构可以给默认值let [a,b,c=\"暂无数据\"] = [1,2,undefined];//let = a;(&#123;a&#125; = &#123;a:\"apple\",b:\"banana\"&#125;);console.log(a) 🌴 字符串模板代替字符串拼接1234let name = \"DANDAN\";let age = 18;let str = `我是$&#123;name&#125;,年龄永远$&#123;age&#125;岁`; 🌴 函数默认参数函数参数默认已经定义，不能再用let,const声明123function(a=0,b=0)&#123; console.log(a,b)&#125; 箭头函数()=&gt;{ 语句 return}注: this问题，定义函数所在的对象，不是运行时所在对象。 箭头函数里没有arguments；用“…”。 箭头函数不能作构造函数 剩余参数扩展运算符，reset运算符(…)：剩余参数必须放到最后 12345678let arr = [a,b,c]console.log(...arr);function show(...a)&#123; console.log(a)&#125;show(1,2,3,4,5) 🌴 热闹的数组循环 forEach() 代替for,两个参数 map() filter() some() every() 1、arr.forEach(function(){},指向)、arr.map(function(){},指向),接受两个参数，第一个：循环回调函数，第二个：this指向。 123arr.forEach(function(val,index,arr)&#123; console.log(this,val,index,arr);&#125;,windows) 2、arr.map(function(){},指向),和forEach()一样，接受两个参数，第一个：循环回调函数，第二个：this指向。 一般用来做数据交互映射，正常情况下，需要配合return,返回一个新的数组 若没有return相当于forEach, 日常用return返回目标数据。3、arr.filter(),过滤掉“不合格”数据. 12345678let arr = [ &#123;type:true&#125;, &#123;type:false&#125;]let newArr = arr.filter(function(item,index,arr)&#123; return item.type === true;&#125;)console.log(newArr); 4、arr.some(),类似查找，数组里面有一个元素符合条件，返回true. 1234let arr = [1,2,3,4,5,6];let r = arr.some((val,index,arr) =&gt;&#123; return val%2 = 1;&#125;) 5、arr.every(),数组里面所有元素符合条件，返回true。6、arr.reduce(),与上面的不同，有四个参数,从左往右。123let r = arr.reduce((pre,cur,index,arr)=&gt;&#123; return pre+cur; //求和&#125;) 7、arr.reduceRight(),有四个参数,从右往左。8、for…of 123456789101112for(let val of arr)&#123; console.log(val);&#125;for(let index of arr.keys())&#123; console.log(val);&#125;for(let item of arr.entries())&#123; console.log(val);&#125;for(let [key,val] of arr.entries())&#123; console.log(key,val);&#125; 🌴 数组新增1、Array.from():把类数组对象转为数组。2、Array.of():把一组值转为数组。 1Array.of('1','2','3') //['1','2','3'] 3、Array.find():数组查找，找出第一个符合条件，若没找到，返回undefined。4、Array.findIndex():返回找到的位置，没找到返回-1.5、arr.fill()6、arr.includes()6、arr.indexOf() 🌴 Promise1、解决异步回调问题 123456789101112131415161718new Promise(function(resolve,reject)&#123; //resolve成功调用 //reject 失败调用&#125;)let a=10;let promise = new Promise(function(resolve,reject)&#123; if(a==10)&#123; resolve('成功！'); &#125;else&#123; resolve('失败！'); &#125;&#125;)promise.then(res=&gt;&#123; console.log(res);&#125;,err=&gt;&#123; console.log(err);&#125;) 2、Promise.resolve(‘a’):将现有的东西转成一个promise对象，resolve状态，成功状态。等价于：new Promise(resolve=&gt;{resolve(“a”)})。Promise.reject(‘a’):将现有的东西转成一个promise对象，reject状态，失败状态。3、Promise.all([p1,p2,p3]):把promise打包，扔到数组里，打包完还是一个promise对象。必须确保所有的promise对象都是resolve状态，都是成功状态。4、Promise.race([p1,p2,p3]):只要有一个成功，就返回。 🌴 模块化在ES6之前，社区定制一套模块规范 Commonjs—-主要服务端nodejs require(‘http’) AMD———requirejs,curljs CMD———seajs ES6 ， import/export/export default . 可以是相对路径，也可绝对路径。 import只会导入一次，无论引入多少次。 import “./modules/1.js”;如果这么用，相当于引入文件。 import会自动提升到顶部，先执行 导出去模块内容，如果里面有定时器更改，外面也会改动，不像CommonJS规范缓存。 动态引入：类似node里的require，可以动态引入，默认import语法不能写入if之类的里面，返回值是promise对象 优点：1、按需加载；2、可以写if中；3、路径也可以动态。 123456789101112131415161718192021222324252627//1、import、export //模块 const a=1; const b=2; let c=3 export &#123; a as first b as second c as third &#125; //引入 import &#123;first,second,third&#125; from ./modules.js//2、import、export default export default引入时不用加花括号. //模块 export default a=3; //引入 import a from \"./modules.js\"//3、动态引入 import('./modules.js).then(res=&gt;&#123; console.log(res.a+res.b); &#125;) Promise.all([import('./1.js'),[import('./2.js')]).then(([res1,res2])=&gt;&#123; console.log(res1,res2); &#125;) 🌴 ClassES6 的class可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。 123456789101112131415161718function Point(x, y) &#123; this.x = x; this.y = y;&#125;Point.prototype.toString = function () &#123; return '(' + this.x + ', ' + this.y + ')';&#125;;var p = new Point(1, 2);//ES6改写class Point &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125; toString() &#123; return '(' + this.x + ', ' + this.y + ')'; &#125;&#125; constructor 方法1、constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加。2、constructor方法默认返回实例对象（即this），完全可以指定返回另外一个对象。3、类必须使用new调用，否则会报错。这是它跟普通构造函数的一个主要区别，后者不用new也可以执行。 类的实例生成类的实例的写法，与 ES5 完全一样，也是使用new命令。前面说过，如果忘记加上new，像函数那样调用Class，将会报错。 取值函数（getter）和存值函数（setter）与 ES5 一样，在“类”的内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为 属性表达式类的属性名，可以采用表达式。 123456789101112//Square类的方法名getArea，是从表达式得到的let methodName = 'getArea';class Square &#123; constructor(length) &#123; // ... &#125; [methodName]() &#123; // ... &#125;&#125; Class表达式12345const MyClass = class Me &#123; getClassName() &#123; return Me.name; &#125;&#125;; 静态方法1、在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。 123456789class Foo &#123; static classMethod() &#123; return 'hello'; &#125;&#125;Foo.classMethod() // 'hello'var foo = new Foo();foo.classMethod()// TypeError: foo.classMethod is not a function 2、父类的静态方法，可以被子类继承，下节讨论。 实例属性的新写法实例属性除了定义在constructor()方法里面的this上面，也可以定义在类的最顶层。123456789101112131415161718192021222324class IncreasingCounter &#123; constructor() &#123; this._count = 0; &#125; get value() &#123; console.log('Getting the current value!'); return this._count; &#125; increment() &#123; this._count++; &#125;&#125;//也可以class IncreasingCounter &#123; _count = 0; get value() &#123; console.log('Getting the current value!'); return this._count; &#125; increment() &#123; this._count++; &#125;&#125; 静态属性静态属性指的是 Class 本身的属性，即Class.propName，而不是定义在实例对象（this）上的属性。 123456789101112131415//为Foo类定义了一个静态属性prop。class Foo &#123;&#125;Foo.prop = 1;Foo.prop // 1//提案class MyClass &#123; static myStaticProp = 42; constructor() &#123; console.log(MyClass.myStaticProp); // 42 &#125;&#125; 私有方法和私有属性私有方法和私有属性，是只能在类的内部访问的方法和属性，外部不能访问。这是常见需求，有利于代码的封装。一种做法是在命名上加以区别。下面代码_bar()方法前面的下划线，表示这是一个只限于内部使用的私有方法。但是，这种命名是不保险的，在类的外部，还是可以调用到这个方法。12345678910class Widget &#123; // 公有方法 foo (baz) &#123; this._bar(baz); &#125; // 私有方法 _bar(baz) &#123; return this.snaf = baz; &#125;&#125; 另一种方法就是将私有方法移出类，因为类内部的所有方法都是对外可见的。 私有属性的提案目前，有一个提案，为class加了私有属性。方法是在属性名之前，使用#表示。#count就是私有属性，只能在类的内部使用（this.#count）。如果在类的外部使用，就会报错。 new.target 属性new是从构造函数生成实例对象的命令。ES6 为new命令引入了一个new.target属性，该属性一般用在构造函数之中，返回new命令作用于的那个构造函数。如果构造函数不是通过new命令或Reflect.construct()调用的，new.target会返回undefined，因此这个属性可以用来确定构造函数是怎么调用的。 Class 内部调用new.target，返回当前 Class。子类继承父类时，new.target会返回子类。可以写出不能独立使用、必须继承后才能使用的类。下面代码中，Shape类不能被实例化，只能用于继承。 1234567891011121314151617class Shape &#123; constructor() &#123; if (new.target === Shape) &#123; throw new Error('本类不能实例化'); &#125; &#125;&#125;class Rectangle extends Shape &#123; constructor(length, width) &#123; super(); // ... &#125;&#125;var x = new Shape(); // 报错var y = new Rectangle(3, 4); // 正确 12345678910class IncreasingCounter &#123; #count = 0; get value() &#123; console.log('Getting the current value!'); return this.#count; &#125; increment() &#123; this.#count++; &#125;&#125; 🌴 Class继承（extends）1、Class 可以通过extends关键字实现继承。2、子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类自己的this对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用super方法，子类就得不到this对象。3、如果子类没有定义constructor方法，这个方法会被默认添加。4、在子类的构造函数中，只有调用super之后，才可以使用this关键字，否则会报错。这是因为子类实例的构建，基于父类实例，只有super方法才能调用父类实例。5、父类的静态方法，也会被子类继承。123456789101112131415161718192021222324class Parent &#123;&#125;class Child extends Parent &#123; constructor(x, y, color) &#123; super(x, y); // 调用父类的constructor(x, y) this.color = color; &#125; toString() &#123; return this.color + ' ' + super.toString(); // 调用父类的toString() &#125;&#125;//3、class ColorPoint extends Point &#123;&#125;// 等同于class ColorPoint extends Point &#123; constructor(...args) &#123; super(...args); &#125;&#125; Object.getPrototypeOf()判断，一个类是否继承了另一个类 12Object.getPrototypeOf(ColorPoint) === Point //true super 关键字当作函数使用，也可以当作对象使用，在这两种情况下，它的用法完全不同。1、第一种情况，super作为函数调用时，super()只能用在子类的构造函数之中,代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次super函数。注意：super虽然代表了父类A的构造函数，但是返回的是子类B的实例，即super内部的this指的是B的实例，因此super()在这里相当于A.prototype.constructor.call(this)。下面，new.target指向当前正在执行的函数。可以看到，在super()执行时，它指向的是子类B的构造函数，而不是父类A的构造函数。也就是说，super()内部的this指向的是B。123456789101112class A &#123; constructor() &#123; console.log(new.target.name); &#125;&#125;class B extends A &#123; constructor() &#123; super(); &#125;&#125;new A() // Anew B() // B 2、第二种情况，super作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。 下面，子类B当中的super.p()，就是将super当作一个对象使用。这时，super在普通方法之中，指向A.prototype，所以super.p()就相当于A.prototype.p()。注：super指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过super调用的。 123456789101112131415161718192021222324252627282930313233343536373839//1、在普通方法中class A &#123; p() &#123; return 2; &#125;&#125;class B extends A &#123; constructor() &#123; super(); console.log(super.p()); // 2 &#125;&#125;let b = new B();class Parent &#123; static myMethod(msg) &#123; console.log('static', msg); &#125; myMethod(msg) &#123; console.log('instance', msg); &#125;&#125;class Child extends Parent &#123; static myMethod(msg) &#123; super.myMethod(msg); &#125; myMethod(msg) &#123; super.myMethod(msg); &#125;&#125;Child.myMethod(1); // static 1var child = new Child();child.myMethod(2); // instance 2 类的 prototype 属性和proto属性ES5 中，每一个对象都有proto属性，指向对应的构造函数的prototype属性。Class 作为构造函数的语法糖，同时有prototype属性和proto属性，因此同时存在两条继承链。1、子类的proto属性，表示构造函数的继承，总是指向父类。2、子类prototype属性的proto属性，表示方法的继承，总是指向父类的prototype属性。 12345678class A &#123;&#125;class B extends A &#123;&#125;B.__proto__ === A // trueB.prototype.__proto__ === A.prototype // true 实例的 proto 属性1、子类实例的proto属性的proto属性，指向父类实例的proto属性。也就是说，子类的原型的原型，是父类的原型。2、通过子类实例的proto.proto属性，可以修改父类实例的行为。 12345p2.__proto__.__proto__.printName = function () &#123; console.log(&apos;Ha&apos;);&#125;;p1.printName() // &quot;Ha&quot; 🌴 SymbolES6 数据类型除了 Number 、 String 、 Boolean 、 Object、 null 和 undefined ，还新增了 Symbol 。 基本用法Symbol 函数栈不能用 new 命令，因为 Symbol 是原始数据类型，不是对象。可以接受一个字符串作为参数，为新创建的 Symbol 提供描述，用来显示在控制台或者作为字符串的时候使用，便于区分。","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://xdd7130.github.io/categories/Web前端/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://xdd7130.github.io/tags/ES6/"}]},{"title":"vue","slug":"vue","date":"2020-10-25T11:18:34.000Z","updated":"2022-11-02T11:15:20.677Z","comments":true,"path":"2020/10/25/vue/","link":"","permalink":"http://xdd7130.github.io/2020/10/25/vue/","excerpt":"","text":"生命周期钩子Vue实例从创建到销毁的过程，生命周期分为8个过程：创建前，创建后，挂载前，挂载后，更新前，更新后，销毁前，销毁后。 beforeCreate:初始化vue实例，进行数据观测，发生在实例对象创建之前，一般来实现加载动画等。 created:组件创建，属性被绑定，但DOM还没生成，一般在这个阶段进行请求、获取数据，赋给属性等。 完成数据观测，属性与方法的运算，watch、event事件回调的配置 可调用methods中的方法，访问和修改data数据触发响应式渲染dom，可通过computed和watch完成数据计算 此时vm.$el 并没有被创建 一般在created中进行ajax请求 created -&gt; beforeMount: 判断是否存在el选项，若不存在则停止编译，直到调用vm.$mount(el)才会继续编译 若存在el，则判断是否存在template，若存在，则将template编译成render函数；若不存在，则直接编译el所对应的外部html 如果存在render函数，则首先对其进行编译 此过程中vm.el被实例化为el选项对应DOM元素，所以在beforeMount中，用vm.el获取到的是挂载DOM的HTML优先级： render &gt; template &gt; outerHTML beforeMount: 在此阶段可获取到vm.el 此阶段vm.el虽已完成DOM初始化，但并未挂载在el选项上 beforeMount -&gt; mounted:此阶段vm.el完成挂载，vm.$el生成的DOM替换了el选项所对应的DOM mounted:编译完成页面显示，有些东西需要在页面显示之后再操作的，应在mounted方法阶段。 beforeUpdate:实例更新之前。 updated:实例更新之后。 beforeDestroy:实例销毁之前。 destroyed:实例销毁之后。 路由导航守卫 导航守卫就是路由跳转过程中的一些钩子函数，路由跳转的过程分为跳转前中后等等细小的过程，在每一个过程中都有一函数，这个函数能让你操作一些其他的事儿，这就是导航守卫，类似于上面的组件生命周期钩子函数。 待补充。。。。","categories":[{"name":"Vue","slug":"Vue","permalink":"http://xdd7130.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://xdd7130.github.io/tags/Vue/"}]},{"title":"遇到的问题","slug":"遇到的问题","date":"2020-10-14T01:36:25.000Z","updated":"2022-11-02T11:15:20.746Z","comments":true,"path":"2020/10/14/遇到的问题/","link":"","permalink":"http://xdd7130.github.io/2020/10/14/遇到的问题/","excerpt":"","text":"😮问题一：ArcGIS服务突然启动不了症状😷症状一：所有的ArcGIS服务用不了，启动ArcGIS Server后，会立刻停掉.症状二：Arcgis Desktop连接GIS Servers报错“Proxy server got bad address from remote server …”症状三：打开错误日志，如下错误： 1234567891011java.lang.ExceptionInInitializerError at com.esri.arcgis.discovery.admin.SiteManager.getInstance(SiteManager.java:374) at com.esri.arcgis.discovery.admin.plugins.ServerConfigObserver.beforeStart(ServerConfigObserver.java:80) at com.esri.arcgis.discovery.nodeagent.impl.ObserverManager.beforeStart(ObserverManager.java:146) at com.esri.arcgis.discovery.nodeagent.impl.NodeAgent.c(NodeAgent.java:245) at com.esri.arcgis.discovery.nodeagent.impl.NodeAgent.start(NodeAgent.java:137) at com.esri.arcgis.discovery.nodeagent.impl.Main.start(Main.java:56)Caused by: java.lang.RuntimeException: Could not create directory path 'D:\\arcgisserver\\config-store'. This is required to maintain the Site configuration. Please check that the location is valid and that the ArcGIS Server account has permissions to the location. at com.esri.arcgis.discovery.admin.SiteManager.&lt;init&gt;(SiteManager.java:242) at com.esri.arcgis.discovery.admin.SiteManager.&lt;init&gt;(SiteManager.java:153) at com.esri.arcgis.discovery.admin.SiteManager$i_.&lt;clinit&gt;(SiteManager$i_.java:363) 从以上症状，我们发现了问题所在，即文件夹’D:\\arcgisserver\\config-store’的权限问题，于是回想我之前是否改过权限，之前我删掉了Users组或用户名。 解决办法💊安全-添加-高级-立即查找-选择“users”-确定。添加主体Users后，ArcGIS Server便可恢复，如图： 😮问题二:Sql Server数据库密码过期症状😷症状一：某台服务器上的接口突然无法使用，报错500；症状二：SQL Server数据库,sa用户登录不上，错误如图： 以上症状说明：sa密码错误，我们设定的密码过期了。 解决办法💊常规办法解决如下步骤：1、以windows验证模式进入数据库管理器2、右键数据库服务器名，选择【属性】3、打开“服务器属性”窗口，选择【安全性】，更改“服务器身份验证”4、展开数据库服务器名—“安全性”—“登录名”， 右键“sa”用户，选择【属性】5、打开“登录属性”窗口，选择【常规】，设置密码6、仍然在“登录属性”窗口，选择【状态】，选择“登录”下面的【已启用】7、右键数据库服务器名，选择【重新启动】8、现在可以使用SQL Server身份验证成功登录了。以上办法设置的密码仍会过期，执行下面脚本重启服务便可彻底解决：1ALTER LOGIN sa WITH PASSWORD = '&lt;password&gt;' unlock, check_policy = off, check_expiration = off;","categories":[{"name":"其他","slug":"其他","permalink":"http://xdd7130.github.io/categories/其他/"}],"tags":[{"name":"PROBLEM","slug":"PROBLEM","permalink":"http://xdd7130.github.io/tags/PROBLEM/"}]},{"title":"Node.js部署到IIS服务器","slug":"node部署到IIS服务器","date":"2020-09-25T07:00:31.000Z","updated":"2022-11-02T11:15:20.579Z","comments":true,"path":"2020/09/25/node部署到IIS服务器/","link":"","permalink":"http://xdd7130.github.io/2020/09/25/node部署到IIS服务器/","excerpt":"","text":"使用iisnode模块在IIS中托管node.js应用程序来取代自托管node.exe进程： 起因：服务器的ip只有80端口对外开放。但是我们node app.js后，外网访问不到，为了能够解决此问题，将nodejs部署到iis服务器上，这样既可以解决自动退出问题，也可共享80端口。 依赖项 Node.js URL rewrite IISNode 创建web.config文件（express）1234567891011121314151617181920212223242526272829303132&lt;configuration&gt; &lt;system.webServer&gt; &lt;!-- indicates that the hello.js file is a node.js application to be handled by the iisnode module --&gt; &lt;handlers&gt; &lt;add name=\"iisnode\" path=\"app.js\" verb=\"*\" modules=\"iisnode\" /&gt; &lt;/handlers&gt; &lt;!-- use URL rewriting to redirect the entire branch of the URL namespace to app.js node.js application; for example, the following URLs will all be handled by app.js: http://localhost/foo http://localhost/bar --&gt; &lt;rewrite&gt; &lt;rules&gt; &lt;rule name=\"api\"&gt; &lt;match url=\"api/*\" /&gt; &lt;action type=\"Rewrite\" url=\"app.js\" /&gt; &lt;/rule&gt; &lt;/rules&gt; &lt;/rewrite&gt; &lt;!-- exclude node_modules directory and subdirectories from serving by IIS since these are implementation details of node.js applications --&gt; &lt;security&gt; &lt;requestFiltering&gt; &lt;hiddenSegments&gt; &lt;add segment=\"node_modules\" /&gt; &lt;/hiddenSegments&gt; &lt;/requestFiltering&gt; &lt;/security&gt; &lt;/system.webServer&gt;&lt;/configuration&gt; Node服务的修改1index.js中端口监听由 server.listen(3000) 改成 server.listen(process.env.PORT) 完整app.js1234567891011121314151617181920212223242526272829const userApi = require('./api/userApi');const fs = require('fs');const path = require('path');const bodyParser = require('body-parser');const express = require('express');const app = express();app.all('*', function(req, res, next) &#123; res.header(\"Access-Control-Allow-Credentials\", \"true\"); res.header('Access-Control-Allow-Origin', '*'); res.header('Access-Control-Allow-Headers', 'Content-Type, Content-Length, Authorization, Accept, X-Requested-With,loginedtoken'); res.header('Access-Control-Allow-Methods', 'PUT, POST, GET, DELETE, OPTIONS'); if (req.method == 'OPTIONS') &#123; res.send(200); &#125; else &#123; next(); &#125;&#125;);var history = require('connect-history-api-fallback');const staticFileMiddleware = express.static('assets');app.use(staticFileMiddleware);app.use(history(&#123; disableDotRule: true, verbose: true&#125;));app.use(bodyParser.json());app.use(bodyParser.urlencoded(&#123; extended: true &#125;))app.use('/node_yrd/api', userApi);app.listen(process.env.PORT); Vue请求地址的修改12345var isPro = process.env.NODE_ENV === 'production' //process.env.NODE_ENV用于区分是生产环境还是开发环境//根据环境不同导出不同的baseURLmodule.exports = &#123; baseURL: isPro ? 'http://***.***.com/' : ''&#125; 创建添加应用程序如图","categories":[{"name":"其他","slug":"其他","permalink":"http://xdd7130.github.io/categories/其他/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://xdd7130.github.io/tags/Node-js/"},{"name":"IIS服务器","slug":"IIS服务器","permalink":"http://xdd7130.github.io/tags/IIS服务器/"}]},{"title":"Cesium","slug":"Cesium","date":"2020-07-01T06:16:35.000Z","updated":"2022-11-02T11:15:20.538Z","comments":true,"path":"2020/07/01/Cesium/","link":"","permalink":"http://xdd7130.github.io/2020/07/01/Cesium/","excerpt":"","text":"3dtiles文件放在iis服务器1、目录下，添加应用程序2、配置iis的mime头，防止b3dm请求跨域：.b3dm application/octet-stream 问题1、vue跨域：config目录下的index.js:proxyTable.2、“请求筛选模块被配置为拒绝包含双重转义序列的请求。”，在些URL中若包含+号等符号，然后IIS7以上的版本会默认拒绝请求此URL，需要进行如下的修改. 12345&lt;system.webServer&gt;&lt;security&gt;&lt;requestFiltering allowDoubleEscaping=\"true\"/&gt;&lt;/security&gt;&lt;/system.webServer&gt; viewer.scene.globe.undergroundColor 不同版本，有优化，在1.68,globe无undergroundColor属性，1.71版本有，可自定义设置。 三维遇到的问题（20200709）：1.arcScence:导出的是wrl文件，cesium不支持可视化，还没找到可以文件转换的方法。2.evs:导出的也是wrl文件，呵呵3.arcgis Pro:可以解决这个问题，可以发布服务，但是，需要注册安装，试用期21天，需购买。4.openGeoSys:开源，文件输出的vtk格式，cesium实现可视化，但专业，需进一步学习。","categories":[{"name":"Cesium","slug":"Cesium","permalink":"http://xdd7130.github.io/categories/Cesium/"}],"tags":[{"name":"Cesium","slug":"Cesium","permalink":"http://xdd7130.github.io/tags/Cesium/"}]},{"title":"SVG","slug":"SVG","date":"2020-07-01T06:16:35.000Z","updated":"2025-02-15T04:02:15.962Z","comments":true,"path":"2020/07/01/SVG/","link":"","permalink":"http://xdd7130.github.io/2020/07/01/SVG/","excerpt":"","text":"1. 可缩放矢量图形 Scalable Vector Graphics SVG什么是SVGSVG 指可伸缩矢量图形 (Scalable Vector Graphics)SVG 用来定义用于网络的基于矢量的图形SVG 使用 XML 格式定义图形SVG 图像在放大或改变尺寸的情况下其图形质量不会有所损失SVG 是万维网联盟的标准SVG 与诸如 DOM 和 XSL 之类的 W3C 标准是一个整体 特点及优势SVG 可被非常多的工具读取和修改（比如记事本）SVG 与 JPEG 和 GIF 图像比起来，尺寸更小，且可压缩性更强。SVG 图像可在任何的分辨率下被高质量地打印SVG 可在图像质量不下降的情况下被放大SVG 图像中的文本是可选的，同时也是可搜索的（很适合制作地图） 使用方式在浏览器直接打开xml 是浏览器能读取的格式，但如果希望 svg 能在浏览器中渲染出来，需要使用 xmlns 声明渲染规则。所以必须使用 xmlns=”http://www.w3.org/2000/svg&quot;。 内嵌到HTML中：， 标签并没有使用 xmlns=”http://www.w3.org/2000/svg&quot; 声明命名空间，这是因为 HTML 5 文档使用 &lt;!DOCTYPE html&gt; 标记，它允许跳过 SVG 命名空间声明，HTML 解析器会自动识别 SVG 元素和它的子元素在css背景图中使用 使用img标签引入坐标定位和canvas一样，Svg以页面的左上角为 (0,0) 坐标点，它的默认坐标以像素为单位，x 轴正方向是向右，y 轴正方向是向下；如，这里定义的画布尺寸是 200200px。但是，viewBox 属性定义了画布上可以显示的区域：从 (0,0) 点开始，100 宽100 高的区域。这个 100100 的区域，会放到 200200 的画布上显示。于是就形成了放大两倍的效果。 元素见链接 : 元素 defs, use, g, symbolg 是group（分组）的缩写。g元素通常用来对相关图形元素进行分组，以便统一操作，比如旋转，缩放或者添加相关样式等。defs 重用已存储元素, 分组定义的内容直接会显示，所以defs在使用的时候会有更大的灵活性; use 用的是这些 tag 的 id，而非 defs;defs 是个声明块，声明块本身没啥重用意义，其内定义可被重用的内容集合，重用的是该集合中的一项或多项，原样的拿过来在不同位置下呈现symbol 兼具g的分组功能和defs初始不可见的特性,能够创建自己的视窗,symbol 可以设定 width heightuse 复用; 实现SVG现有图形的复用，可以复用单个SVG图形元素，也可以复用g定义的组元素 属性所有 SVG 显示属性都可以作为 CSS 属性来使用 动画SMIL 驱动SMIL是Synchronized Multimedia Integration Language（同步多媒体集成语言）的首字母缩写简称，是一种标准。SVG借鉴了这种标准用: Set, animate, animateColor, animateTransform, animateMotion元素实现动画 JavaScript 驱动一般应用js操作属性实现 CSS 驱动使用 css @keyframes animationName 定义动画 选择哪个? 建议将CSS动画用于无变形的过渡或简单动画。尤其是在硬件加速时。CSS不需要加载其他资源（一般指三方库），并且悬停时的小变换可以为交互带来更好的效果。特别是当你不需要3d、物理体感、或进行大量堆叠动画效果时建议选用CSS。另外，CSS方便调试也是很大的一个优势。对于较长的动画，开发时会变得非常复杂且需要花精力去调试，而CSS调整时间尺度很困难，尤其是当你需要操纵一些细微帧时，个人觉得SMIL更合适做有序的，复杂的堆叠动画群的场景。对于变形的动画，建议使用SMIL或者第三方库: GSAP, anime.js, D3, Snap.js, SVG.js, Velocity.js。 本文代码示例: 链接","categories":[{"name":"SVG","slug":"SVG","permalink":"http://xdd7130.github.io/categories/SVG/"}],"tags":[{"name":"SVG","slug":"SVG","permalink":"http://xdd7130.github.io/tags/SVG/"}]},{"title":"关于大屏","slug":"关于大屏","date":"2020-04-11T06:57:42.000Z","updated":"2022-11-02T11:15:20.680Z","comments":true,"path":"2020/04/11/关于大屏/","link":"","permalink":"http://xdd7130.github.io/2020/04/11/关于大屏/","excerpt":"","text":"待续。。。","categories":[],"tags":[{"name":"大屏","slug":"大屏","permalink":"http://xdd7130.github.io/tags/大屏/"}]},{"title":"前端安全","slug":"前端安全","date":"2019-11-19T02:43:12.000Z","updated":"2022-11-02T11:15:20.680Z","comments":true,"path":"2019/11/19/前端安全/","link":"","permalink":"http://xdd7130.github.io/2019/11/19/前端安全/","excerpt":"","text":"🌾 网络安全🌾 页面安全跨站脚本攻击XSS 分类待续。。。","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://xdd7130.github.io/categories/Web前端/"}],"tags":[{"name":"安全","slug":"安全","permalink":"http://xdd7130.github.io/tags/安全/"}]},{"title":"vuex+node+express+token登录","slug":"login","date":"2019-09-22T08:38:30.000Z","updated":"2022-11-02T11:15:20.553Z","comments":true,"path":"2019/09/22/login/","link":"","permalink":"http://xdd7130.github.io/2019/09/22/login/","excerpt":"","text":"思路1、第一次登录的时候，前端调后端的登陆接口，发送用户名和密码 2、后端收到请求，验证用户名和密码，验证成功，就给前端返回一个token 3、前端拿到token，将token存储到localStorage和vuex中，并跳转路由页面 4、前端每次跳转路由，就判断 localStroage 中有无 token ，没有就跳转到登录页面，有则跳转到对应路由页面 5、每次调后端接口，都要在请求头中加token 6、后端判断请求头中有无token，有token，就拿到token并验证token，验证成功就返回数据，验证失败（例如：token过期）就返回401，请求头中没有token也返回401 7、如果前端拿到状态码为401，就清除token信息并跳转到登录页面 知识点1、路由守卫导航2、localStorage及其他前端存储（见基础前端）3、防抖和节流（token过期）4、后端接口调用5、node.js、mysql、git、express、element-UI、vuex、vue-router、jsonwebtoken 知识点解释路由守卫导航vue-router 的导航钩子，主要用来作用是拦截导航，让他完成跳转或取消。有三种方式可以植入路由导航过程中： 全局导航守卫1、全局前置守卫 router.beforeEach(fn)2、全局的解析守卫(不常用)3、全局的后置守卫 router.afterEach(fn)（可以做一些用户友好提示、与全局前置守卫参数相同） 路由独享守卫1、路由独享守卫 beforeEnter(to,from,next) （a、写在路由表中的守卫钩子 b、针对的是和当前路由相关的，那么其他与之不相关的路由，它是无法监听它的变化情况的 c、可用于用户权限管理 d、与全局前置守卫参数相同） 1234567891011121314151617181920212223const routes = [ &#123; path: '/', redirect: '/home' &#125;, &#123; path: '/home', component: Home &#125;, &#123; path: '/category', component: Category, beforeEnter ( to,from,next ) &#123; alert('您要进入吗') next() //业务： 用户权限管理 &#125; &#125;, &#123; path: '**', redirect: '/error' &#125; ] 组件内守卫1、组件内的前置守卫beforeRouteEnter((to,from,next)=&gt;{})导航进入组件时，调用因为组件此时没有创建，所以没有this,this是访问不到的，如果非要访问this,必须通过 next(vm=&gt;{})访问。 1234next(vm =&gt; &#123; //vm指的就是组件 const result = JSON.parse(res.data.slice(7,-1)).rp_result.categorys vm.$set(vm.category,'categorys',result) &#125;) 2、组件内的后置守卫beforeRouteEnter((to,from,next)=&gt;{})(a)离开组件时，调用(b)this是可以访问到1234567891011beforeRouteLeave (to, from, next) &#123; //我们现在已经要离开这个组件，那么这个组件身上的数据和方法等内容我们肯定可以获取到，也就是说这里可以使用 this if( this.username || this.password)&#123; if( confirm('您已经填写结束了吗?'))&#123; next() &#125;else&#123; next(false) &#125; &#125;else&#123; next() &#125; 3、组件内的更新守卫（ 路由传参和路由的接参 ）（a）在当前路由改变，但是该组件被复用时调用（b）举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，（c）由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。（d）可以访问组件实例 this1234beforeRouteUpdate ( to,from,next ) &#123; //动态路由用 console.log('路由改变了') next() &#125; 总结 1、3种类型 7个路由监听钩子 2、业务：监听整个项目的路由变化情况——全局的前置守卫监听某个路由的变化情况——路由的独享守卫监听的路由组件的路由变化情况——组件内的导航守卫 #### 实例实现待补充。。。","categories":[{"name":"Vue","slug":"Vue","permalink":"http://xdd7130.github.io/categories/Vue/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://xdd7130.github.io/tags/Node-js/"},{"name":"vue","slug":"vue","permalink":"http://xdd7130.github.io/tags/vue/"}]},{"title":"MySQL","slug":"node7","date":"2019-09-11T07:11:01.000Z","updated":"2022-11-02T11:15:20.579Z","comments":true,"path":"2019/09/11/node7/","link":"","permalink":"http://xdd7130.github.io/2019/09/11/node7/","excerpt":"","text":"准备mysql安装参考：https://www.cnblogs.com/laumians-notes/p/9069498.html Navicat数据库管理工具:https://blog.csdn.net/a599174211/article/details/82795658 nodeJS操作MySQLnodeJS默认不支持MySQL,需要第三方工具来驱动，这里用mysql驱动。 npm install mysql 123456789101112131415const mysql = require('mysql');1.连接//createConnection(哪台服务器，用户名，密码，库)var db = mysql.createConnection(host:'localhost',port:'3306',user:'root',password:'123456',database:'my_db',)；2.查询//query(干啥，回调函数)db.query(\"SELECT * FROM `user_table`;\",(err,data)=&gt;&#123; if(err) console.log('出错了'，err) else console.log('成功了'，data) console.log(JSON.stringify(data))&#125;); SQL标准写法：1.关键字大写2.库、表、字段需加上饭单引号SQL四大语句：增删改查增：INSERTINSERT INTO 表（字段列表） VALUES (值列表)INSERT INTO user_table（ID,username,password）VALUES (0,blue2,987654) VALUES (值列表)删：DELETE改：UPDATE查：SELECT","categories":[{"name":"Node","slug":"Node","permalink":"http://xdd7130.github.io/categories/Node/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://xdd7130.github.io/tags/Node-js/"}]},{"title":"jade、ejs模板库","slug":"node6","date":"2019-09-10T08:36:44.000Z","updated":"2022-11-02T11:15:20.571Z","comments":true,"path":"2019/09/10/node6/","link":"","permalink":"http://xdd7130.github.io/2019/09/10/node6/","excerpt":"","text":"模板引擎：生成页面 主要的： jade-破坏式、侵入式、强依赖ejs-温和式、非侵入式、 弱依赖 安装jade插件npm install jade jade写法: 根据缩进，规定层级 属性放在()里面，逗号分隔 a标签文本内容前有一个空格 style两种写法：普通属性写法;用json。 class两种写法:普通属性写法;用数组。 &amp;attribute jade1.js12345const jade = require('jade');//字符串：var str = jade.render('njfnejrfbjreknve');//文件：var str = jade.renderfile('./views/1.jade',&#123;pertty:true&#125;);console.log(str); 1.jade12345678910111213141516html head style script(src=\"a.js\") link(href='a.css',rel='stylesheet') body div.box div#div1 div(style=\"width:200px;height:200px;\",class=\"aaa bbb\") ul li input(type='text',id=\"test1\") li a(href='http://baidu.com') 百度 li div(style=&#123;width:'200px',height:'200px';&#125;,class=['aaa','bbb']) jade模板库高级语法 识别单双标签，自定义标签默认为双标签。 “|”或”.”用来原样输出东西。 include引入文件 使用变量：#{} 或”=” 12345671.js const jade= require('jade'); console.log(jade.renderfile('./view/1.jade',&#123;pretty:true,name:'blue'&#125;))1.jade div 我的名字#&#123;name&#125; div=name “-“代表：我是一段代码 循环： 12345678910111.jadehtml head body .for(var i=0;i&lt;arr.length;i++) div=arr[i]1.jsconsole.log(jade.renderfile('./view/1.jade',&#123;pretty:true, arr:['aaa','bbb','ccc']&#125;)) 非转义：标签原样输出：！ 123456789101.jadehtml head body div!=content1.jsconsole.log(jade.renderfile('./view/1.jade',&#123;pretty:true, content:'&lt;h2&gt;mwenfoirefwo&lt;/h2&gt;'&#125;)) 生成html文件 安装ejs插件npm install ejs ejs1.js12345678const ejs = require('ejs');var str = ejs.renderfile('./views/1.ejs',&#123;name:'blue'&#125;,function(err,data)&#123; if(err) console.log('编译失败') else console.log(data)&#125;);console.log(str); 1.ejs123456789&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 我的名字叫：&lt;%= name %&gt;&lt;/body&gt;&lt;/html&gt; ejs模板库高级语法 灵活，支持各类型数据 循环 “=”转义输出,”-“非转义输出 &lt;% include ./a.txt %&gt;","categories":[{"name":"Node","slug":"Node","permalink":"http://xdd7130.github.io/categories/Node/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://xdd7130.github.io/tags/Node-js/"}]},{"title":"时序动画","slug":"时序动画","date":"2019-08-23T08:39:42.000Z","updated":"2022-11-02T11:15:20.723Z","comments":true,"path":"2019/08/23/时序动画/","link":"","permalink":"http://xdd7130.github.io/2019/08/23/时序动画/","excerpt":"","text":"补充1:2019-08-29 发布服务前，设置时区 效果图： 步骤一：数据准备拖拉机数据：时间2019/6/7 7:59:00-2019/6/713:52:00目标数据：时间2019/6/7 8:00:00-2019/6/713:52:00 注意：所有的数据需放在地理数据库里，否则日期后的时分秒被自动截去删除。 步骤二：制图表达将拖拉机数据转为制图表达，重新为RULEID赋值，这里我全赋值为6，不能赋值为0哦。目标数据线分为五个等级，再转为制图表达，RULEID是否重新赋值视情况而定。(能够满足步骤四的分级) 步骤三：合并merge将两个制图表达数据合并。 步骤四：分级将步骤三合并的文件进行分级，这里分为六级（包括整个图层），其中第六级用来渲染拖拉机符号。 步骤五：再次制图表达将分级后的文件再次制作制图表达，对第六级进行符号渲染。 步骤六：将文件导入到数据库步骤七：从数据库拉去数据设置timeslider属性，发布服务步骤八：调用服务使用动态图层，要素服务调用，符号不渲染。 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"&gt; &lt;meta name=\"viewport\" content=\"initial-scale=1, maximum-scale=1,user-scalable=no\"&gt; &lt;title&gt;Recent Earthquakes&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"https://js.arcgis.com/3.29/dijit/themes/claro/claro.css\"&gt; &lt;link rel=\"stylesheet\" href=\"https://js.arcgis.com/3.29/esri/css/esri.css\"&gt; &lt;style&gt; html, body &#123; height: 100%; width: 100%; margin: 0; padding: 0; &#125; .dijitBorders&#123; margin:5px 5px 5px 5px; border:solid thin #9CAA9C; -moz-border-radius: 4px; &#125; .labelText&#123; color:#9CAA9C; font-size:12pt; font-family:\"Tahoma\"; margin:5px; &#125; .headerText&#123; color:#9CAA9C; font-size:16pt; font-weight:bold; font-family: \"Tahoma\"; &#125; &lt;/style&gt; &lt;script src=\"https://js.arcgis.com/3.29/\"&gt;&lt;/script&gt; &lt;script&gt; var map,timeExtent; require([ \"esri/map\",\"esri/layers/ArcGISDynamicMapServiceLayer\", \"esri/layers/FeatureLayer\", \"esri/TimeExtent\", \"esri/layers/TimeInfo\", \"esri/renderers/ClassBreaksRenderer\", \"esri/symbols/SimpleMarkerSymbol\", \"esri/symbols/SimpleLineSymbol\", \"esri/dijit/editing/TemplatePicker\", \"esri/dijit/TimeSlider\", \"esri/renderers/TimeClassBreaksAger\", \"esri/renderers/TemporalRenderer\", \"dojo/parser\", \"dojo/_base/array\", \"esri/Color\", \"dojo/dom\", \"dojo/date\", \"dijit/layout/BorderContainer\", \"dijit/layout/ContentPane\", \"dojo/domReady!\" ], function( Map, ArcGISDynamicMapServiceLayer,FeatureLayer, TimeExtent, TimeInfo, ClassBreaksRenderer, SimpleMarkerSymbol, SimpleLineSymbol, TemplatePicker, TimeSlider, TimeClassBreaksAger, TemporalRenderer, parser, arrayUtils, Color, dom, date ) &#123; parser.parse(); map = new Map(\"map\", &#123; basemap: \"satellite\", center: [114.0143, 34.11075], slider: false, zoom:15 &#125;); //边界 var research_scope = new ArcGISDynamicMapServiceLayer(\"http://localhost:6080/arcgis/rest/services/Henan_S/research_scope1/MapServer\",&#123;\"id\":\"100000\"&#125;); map.on(\"load\", mapLoaded); function mapLoaded() &#123; var SOMtlj = new ArcGISDynamicMapServiceLayer(\"http://localhost:6080/arcgis/rest/services/Henan_S/PH1_TLJ/MapServer\",&#123;\"id\":\"3\"&#125;); SOMtlj.on(\"load\", featureLayerLoaded); map.addLayer(SOMtlj); map.addLayer(research_scope); &#125; function featureLayerLoaded() &#123; // create time slider var timeSlider = new TimeSlider(&#123; style: \"width: 100%;\"&#125;, dom.byId(\"timeSliderDiv\")); map.setTimeSlider(timeSlider); timeExtent = new TimeExtent(); // 设置时区后，开始时间和结束时间 //timeExtent.startTime = new Date(\"2019/06/06 23:59:00 UTC\"); //timeExtent.endTime = new Date(\"2019/06/07 05:52:00 UTC\"); timeSlider.setThumbCount(1); timeSlider.createTimeStopsByTimeInterval(timeExtent, 1, \"esriTimeUnitsMinutes\"); timeSlider.setThumbIndexes([0]); timeSlider.on(\"time-extent-change\", displayTimeInfo); timeSlider.startup(); // timeSlider.play(); &#125; function displayTimeInfo(timeExtent) &#123; var info = timeExtent.endTime; dom.byId(\"timeInfo\").innerHTML = info; &#125; &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body class=\"claro\"&gt; &lt;div id=\"mainWindow\" data-dojo-type=\"dijit/layout/BorderContainer\" data-dojo-propx=\"design:'sidebar', gutters:true\" style=\"width:100%; height:100%;\"&gt; &lt;div id=\"header\" data-dojo-type=\"dijit/layout/ContentPane\" data-dojo-props=\"region:'top'\" class=\"dijitBorders\" style=\"height:100px;\"&gt; &lt;center&gt; &lt;span class=\"headerText\"&gt;采样时序&lt;/span&gt; &lt;div id=\"timeInfo\" class=\"labelText\"&gt;&lt;/div&gt; &lt;div id=\"timeSliderDiv\" &gt;&lt;/div&gt; &lt;/center&gt; &lt;/div&gt; &lt;div id=\"map\" data-dojo-type=\"dijit/layout/ContentPane\" data-dojo-props=\"region:'center'\" class=\"dijitBorders\" style=\"background-color:inherit;\"&gt; &lt;/div&gt; &lt;div id=\"right\" data-dojo-type=\"dijit/layout/ContentPane\" data-dojo-props=\"region:'left'\" style=\"width:100px;font-size:small;\"&gt; &lt;center&gt;&lt;span class=\"labelText\"&gt;Age&lt;/span&gt;&lt;/center&gt; &lt;div id=\"ageDiv\" class=\"dijitBorders\"&gt;&lt;/div&gt; &lt;center&gt;&lt;span class=\"labelText\"&gt;Magnitude&lt;/span&gt;&lt;/center&gt; &lt;div id=\"magnitudeDiv\" class=\"dijitBorders\" &gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"ArcGIS","slug":"ArcGIS","permalink":"http://xdd7130.github.io/categories/ArcGIS/"}],"tags":[{"name":"ArcGIS","slug":"ArcGIS","permalink":"http://xdd7130.github.io/tags/ArcGIS/"}]},{"title":"vuex","slug":"vuex","date":"2019-08-15T03:20:43.000Z","updated":"2022-11-02T11:15:20.678Z","comments":true,"path":"2019/08/15/vuex/","link":"","permalink":"http://xdd7130.github.io/2019/08/15/vuex/","excerpt":"","text":"Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式大型项目，涉及复杂的交互时，用vuex","categories":[{"name":"Vue","slug":"Vue","permalink":"http://xdd7130.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://xdd7130.github.io/tags/Vue/"}]},{"title":"小程序","slug":"小程序","date":"2019-08-15T03:20:43.000Z","updated":"2022-11-02T11:15:20.720Z","comments":true,"path":"2019/08/15/小程序/","link":"","permalink":"http://xdd7130.github.io/2019/08/15/小程序/","excerpt":"","text":"开发前准备1、开发者工具下载。👉下载2、注册申请等。 小程序主要文件及作用 组件使用见官网。👉打开 小程序单位物理和逻辑分辨率转换 rpx（responsive pixel）: 可以根据屏幕宽度进行自适应。规定屏幕宽为750rpx。如在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素。 WXML数据绑定WXML（WeiXin Markup Language）是框架设计的一套标签语言，结合基础组件、事件系统，可以构建出页面的结构。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465Page(&#123; /** * 页面的初始数据 */ data: &#123; &#125;, /** * 生命周期函数--监听页面加载 */ onLoad: function (options) &#123; &#125;, /** * 生命周期函数--监听页面初次渲染完成 */ onReady: function () &#123; &#125;, /** * 生命周期函数--监听页面显示 */ onShow: function () &#123; &#125;, /** * 生命周期函数--监听页面隐藏 */ onHide: function () &#123; &#125;, /** * 生命周期函数--监听页面卸载 */ onUnload: function () &#123; &#125;, /** * 页面相关事件处理函数--监听用户下拉动作 */ onPullDownRefresh: function () &#123; &#125;, /** * 页面上拉触底事件的处理函数 */ onReachBottom: function () &#123; &#125;, /** * 用户点击右上角分享 */ onShareAppMessage: function () &#123; &#125;&#125;) 注意:1&lt;image src=\"&#123;&#123;meurl&#125;&#125;\" show-menu-by-longpress=\"&#123;&#123;true&#125;&#125;\"&gt;&lt;/image&gt; 条件渲染和列表渲染wx:if wx:elif wx:elsewx:for wx:for-index wx:for-item 模板及引入1.创建公用页面template.wxml1234567&lt;template name=\"header\"&gt; &lt;view class=\"header\"&gt;这是头部内容&lt;/view&gt;&lt;/template&gt;&lt;template name=\"footer\"&gt; &lt;view class=\"footer\"&gt;这是底部内容&lt;/view&gt;&lt;/template&gt; 2.引入应用123456wxml:&lt;import src=\"/pages/template/template\"/&gt;wxss:@import \"/pages/template/template\"应用：&lt;template is=\"header\"&gt; 事件处理及数据交互1、变量不是一定要初始化2、setData({ })3、bindtap4、catchtap 阻止冒泡事件 小程序的全局配置1、tabBar导航栏页面跳转 独立页面配置","categories":[{"name":"小程序","slug":"小程序","permalink":"http://xdd7130.github.io/categories/小程序/"}],"tags":[{"name":"小程序","slug":"小程序","permalink":"http://xdd7130.github.io/tags/小程序/"}]},{"title":"Express","slug":"node5","date":"2019-08-13T03:07:47.000Z","updated":"2022-11-02T11:15:20.560Z","comments":true,"path":"2019/08/13/node5/","link":"","permalink":"http://xdd7130.github.io/2019/08/13/node5/","excerpt":"","text":"Express框架1.依赖中间件2.接受请求3.非破坏式的4.static用法 安装、配置、接受请求、响应安装1npm install express 使用 创建服务 监听 处理请求1234567891011const express = require('express');var server = express();server.use('/a.html',function(req,res)&#123; res.send('abc'); //send和write类似 res.end();&#125;);server.use('/b.html',function(req,res)&#123; res.send('123'); res.end();&#125;);server.listen(8080); express保留了原生的功能，添加了一些方法，增强原有的功能。 3种方法get(处理get请求)\\post(处理post请求)\\use(get,post均可)。123456789101112const express = require('express');var server = express();server.get('/',function(req,res)&#123; console.log('get请求')&#125;);server.post('/',function(req,res)&#123; console.log('post请求')&#125;);server.use('/',function(req,res)&#123; console.log('use了')&#125;);server.listen(8080); Express-static读取静态文件安装 npm install express-static -save 实例-登录a.html:server.js1234567891011121314151617181920212223242526272829const express = require('express');const expressStatic = require('express-static');var server = express();server.listen(8080);//用户数据模拟var users=&#123; 'blue':'123456', 'zhangsan':'654321', 'lisi':'987678'&#125;;server.get('/login',function(req,res)&#123; // urlLib.parse(req.url,true).query; console.log(req.query) var user= req.query['user']; var pass= req.query['pass']; if(users[user]==null)&#123; res.send(&#123;ok:false,mag:'此用户不存在'&#125;) &#125;else&#123; if(users[user]!=pass)&#123; res.send(&#123;ok:false,msg:'密码错了'&#125;) &#125;else&#123; res.send(&#123;ok:true,mag:'成功'&#125;) &#125; &#125;&#125;)server.use(expressStatic('./www')); 数据解析get请求数据解析,无需中间件:req.querypost请求数据解析，需中间件：body-parser，首先解析数据12345678910111213const express = require(&apos;express&apos;);const bodyParser = require(&apos;body-parser&apos;);var server = express();server.listen(8080);server.use(bodyParser.urlencoded(&#123; extended:true, //扩展模式 limit: 2*1024 //限制2M，默认100k&#125;));server.use(&apos;/&apos;,function(req,res)&#123; console.log(req.body) //POST&#125;) 链式操作12345678910111213const express = require(&apos;express&apos;);var server = express();server.listen(8080);//第三个参数server.use(&apos;/&apos;,function(req,res,next)&#123; console.log(&apos;a&apos;) next();&#125;);server.use(&apos;/&apos;,function(req,res.next)&#123; console.log(&apos;b&apos;) &#125;) 中间件,类似’body-parser’1234567891011121314151617181920const express = require(&apos;express&apos;);const querystring = require(&apos;querystring&apos;);var server = express();server.listen(8080);//第三个参数server.use(function(req,res,next)&#123; var str=&apos;&apos;; req.on(&apos;data&apos;,function(data)&#123; str+=data; &#125;); req.on(&apos;end&apos;,function(data)&#123; req.body=querystring(str); next(); &#125;);&#125;);server.use(&apos;/&apos;,function(req,res.next)&#123; console.log(&apos;b&apos;) &#125;) cookie、session a.发送cookieres.cookie(名字,值,maxAge:毫秒,signed:true) b.读取cookiecookie-parserserver.use(cookieParser(‘秘钥’))server.use(function(){ req.cookie //未签名 req.signedCookies //签名版}) c.删除cookieres.clearCookie(名字) 保存数据，cookie数据保存浏览器，session 数据保存在服务器。npm install cookie-parser cookie-session12345678910111213const express = require('express');const cookieParser = require('cookie-parser');var server = express();//发送cookieserver.use('/aaa/a.html',function(req,res)&#123; res.cookie('user','blue',&#123;path:'/aaa','maxAge':3*24*3600*1000&#125;)&#125;)//读取cookieserver.use(cookieParser())；server.use('/',function(req,res)&#123; console.log(req.cookie)&#125;) 实现cookie加密：12345678910111213const express = require('express');const cookieParser = require('cookie-parser');var server = express();//cookieParserserver.use(cookieParser);server.use('/',function()&#123; req.secret='hdwifbonfjfosdjhfsj'; res.cookie('user','blue',&#123;signed:true&#125;); res.send('ok');&#125;);server.listen(8080); session 123456789101112131415const express = require('express');const cookieSession = require('cookie-session');var server = express();//cookieserver.use(cookieParser('dnkfvbscsvius'));server.use(cookieSession());server.use('/',function()&#123; req.secret='hdwifbonfjfosdjhfsj'; res.cookie('user','blue',&#123;signed:true&#125;); res.send('ok');&#125;);server.listen(8080); express框架整合 multer模块上传文件npm install multer body-parser:解析post数据 (application/x-form-urlencoded)server.use(bodyParse.urlencode()); multer:解析post文件 (multipart/form-data) 123456789101112131415161718192021222324252627282930313233343536373839404142//上传到磁盘 重命名const multer = require('multer');const pathLib = require('path');const fs = require('fs');//1、pathLib解析获取原始文件扩展名 var str='c:\\\\wamp\\www\\a.html'; var obj=path.parse(str); base :文件名\"a.html\" ext:扩展名\"html\" dir:路径'c:\\\\wamp\\www' name:文件名\"a\"//2.fs的rename重命名 fs.rename('a.txt','b.txt',function(err)&#123; console.log(err) &#125;) fs.rename(老名，新名，function(err)&#123; ... &#125;)var obj=multer(&#123;dest:'./www/upload/'&#125;) //文件保存的位置server.use(obj.any()) //接受任意类型文件//只接收name=f1的文件 : server.use(obj.single('f1')) //req.files:指上传的文件信息，如下图：server.use(function(req,res)&#123; var newName = req.file[0].path+pathLib.parse(req.file[0].originalname).ext fs.rename(req.file[0].path,newName,function()(err)&#123; if(err) res.send('上传失败'); else res.send('上传成功') &#125;)&#125;) html文件： 1234&lt;form action='http://localhost:8080/' method='post' enctype='multipart/form-data'&gt; &lt;input type='file'/&gt; &lt;input type='submit' value='上传/&gt;&lt;/form&gt; consolidate 模板引擎整合库安装：npm install consolidate引用：const consolidate = require(‘consolidate’);配置模板引擎： 我要输出什么东西server.set(‘view engine’,’html’) 模板文件放在哪里server.set(‘view’,’./views’) 哪种模板引擎server.engine(‘html’,consolidate.ejs) server.get(‘/‘,function(req,res){ res.render(‘模板文件’，数据);}) route路由根据目录的不同，调用不同的模块 const express = require(‘express’); var server=express(); var routeUser =express.Route();routeUser.get(‘1.html’,function(req,res){ res.send(‘user1’)})routeUser.get(‘2.html’,function(req,res){ res.send(‘user2’)}) server.use(‘/user’,routeUser);server.listen(8080);","categories":[{"name":"Node","slug":"Node","permalink":"http://xdd7130.github.io/categories/Node/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://xdd7130.github.io/tags/Node-js/"}]},{"title":"node笔记(一)","slug":"node4","date":"2019-08-11T11:48:05.000Z","updated":"2022-11-02T11:15:20.557Z","comments":true,"path":"2019/08/11/node4/","link":"","permalink":"http://xdd7130.github.io/2019/08/11/node4/","excerpt":"","text":"node优势：1、性能好2、跟前台JS配合方便3、NodeJS便于前端学习 http系统模块使用12345678910111213141516171819const http=require('http');var server = http.creatServer(function(req,res)&#123; //创建服务器 switch(res.url)&#123; case \"/1.html\": res.write(\"向前台写东西111\")； break; case \"/2.html\": res.write(\"向前台写东西222\")； break; default res.write(\"404\")； break; &#125; // res.write(\"向前台写东西\")； res.end();//结束请求&#125;)//监听 —— 等着//端口 —— 数字server.listen(8888); fs文件模块fs (file system)123456789101112131415//导入引用: const fs = require('fs');//1.readFile(文件名，回调函数) fs.readFile('aaa.txt',function(err,data)&#123; if(err)&#123; console.log('读取失败')； &#125;else&#123; console.log(data.toString());//二进制格式用toString转换 &#125; &#125;)//2.writeFile(文件名，内容，回调函数)fs.write(\"bbb.txt\",\"asdfghjkl\",function(err)&#123; console.log(err);&#125;) 与服务器结合建立www（可以是其他名字）文件夹，用于存放请求的文件。1234567891011121314151617const http=require('http');var server = http.creatServer(function(req,res)&#123; //创建服务器 //req.url = 'index.html' //读取:'./www/index.html' var file_name = './www'+req.url fs.readFile(file_name,function(err,data)&#123; //异步 if(err)&#123; res.write('读取失败') &#125;else&#123; res.write(data) &#125; res.end();//结束请求，因为异步，res.end()应放在此处 &#125;) &#125;)server.listen(8888); http数据解析（get）前台发送请求的方式：form/ajax/jsonp后台都是一样。唯有一点不同，请求方式不同，接受方式不一样（get/post）.下面一个实例：GET数据解析： 自己切 querystring: url:urlLib.parse(…,true) server.js 普通写法12345678910111213141516171819const http = require('http');http.createServer(function(req,res)&#123; //req获取前台请求的数据 var get=&#123;&#125;; if(req.url.indexOf('?') != -1)&#123; console.log(req.url); // /aaa?user=Tom&amp;pass=123456 var arr = req.url.split('？')；// arr[0]='/aaa' arr[1]='user=Tom&amp;pass=123456' var url=arr[0]; var arr2 = arr[1].split('&amp;'); //arr2 for(var i=0;i&lt;arr2.length;i++)&#123; var arr3=arr2[i].split('=') get[arr3[0]]=arr3[1]; &#125; &#125;else&#123; var url=req.url; &#125; console.log(url,get) res.end();&#125;).listen(8080); server.js querystring模块写法：123456789101112131415161718192021 //写法如下： //const querystring=require('querystring'); //var json = querystring.parse('user=Tom&amp;pass=123456') //console.log(json)//server.js改动后： const http = require('http'); const querystring=require('querystring'); http.createServer(function(req,res)&#123; //req获取前台请求的数据 var get=&#123;&#125;; if(req.url.indexOf('?') != -1)&#123; console.log(req.url); // /aaa?user=Tom&amp;pass=123456 var arr = req.url.split('？')；// arr[0]='/aaa' arr[1]='user=Tom&amp;pass=123456' var url=arr[0]; get=querystring.parse(arr[1]); &#125;else&#123; var url=req.url; &#125; console.log(url,get) res.end(); &#125;).listen(8080); server.js url模块写法：123456789101112131415//url.js写法 const urlLib=require('url'); var obj= urlLib.parse(\"http://www.aaa.bbb/index.html?a=12&amp;b=55\",true); 第二个参数为true时，会把pathname等解析为json. console.log(obj.pathname,obj.query);//server.js改动后： const http = require('http'); http.createServer(function(req,res)&#123; //req获取前台请求的数据 var obj = urlLib.parse(req.url,true); var url=obj.pathname; var get=obj.query; console.log(url,get) res.end(); &#125;).listen(8080); form.html1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=\"http://localhost:8080/aaa\" method=\"get\"&gt; 用户： &lt;input type=\"text\" name=\"user\" value=''&gt; &lt;br&gt; &lt;input type=\"password\" name=\"pass\" value=''&gt; &lt;br&gt; &lt;input type=\"submit\" value='提交' &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; http数据解析（post）POST数据接收：POST数据比GET数据大的多,根据数据量大小分段完成12345678910111213141516const http=require('http');const querystring=require('querystring');http.creatServer(function(req,res)&#123; //POST--req var str=''; //接受数据 //data--有一段数据到达（很多次） req.on('data',function()&#123; str+=data &#125;); //end--数据全部到达（一次） req.on('end',function()&#123; var post = querystring.parse(str); console.log(post) &#125;);&#125;).listen(8080); 应用1:简易httpServer搭建,用户注册登录(略)nodeJS模块化系统模块介绍除了以上用到的：http、querystring、url,还有： Crypto 加密 Event 事件 Net 网络操作 OS 操作系统信息 Path 处理文件路径 Stream 流操作 Timer 定时器 ZLIB 压缩 自定义模块关于引入模块写法：若为当前目录自己的模块，加上“./”,系统模块要加。若想要输出东西，必须exports。若都输出多个东西，module可实现批量输出。 require:请求引入其他模块。 module:批量输出。 exports:输出。 module.exports == exports。 const aaa = require(‘./bbb.js’); 其中“.js”可省略。 npm:nodejs package manager(nodejs包管理器)1、统计下载途径2、自动下载依赖 npm initnpm publishnpm updatenpm unpublishnpm –force unpublish node_modules:放模块，可以放自己定义的模块，此时若引用，不加“./” 总结：require引入模块，若有“./”,从当前目录找，若没有“./”，从系统模块或node_modules找。模块优先级：系统&gt;node_modules,一般将自定义模块放在node_modules中。","categories":[{"name":"Node","slug":"Node","permalink":"http://xdd7130.github.io/categories/Node/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://xdd7130.github.io/tags/Node-js/"}]},{"title":"apply and bind","slug":"apply-and-bind","date":"2019-08-11T02:36:27.000Z","updated":"2022-11-02T11:15:20.547Z","comments":true,"path":"2019/08/11/apply-and-bind/","link":"","permalink":"http://xdd7130.github.io/2019/08/11/apply-and-bind/","excerpt":"","text":"本篇主要解决一下几个问题： 1.apply和call的区别在哪里 2.什么情况下用apply,什么情况下用call 3.apply的其他巧妙用法（一般在什么情况下可以使用apply）* apply:方法能劫持另外一个对象的方法，继承另外一个对象的属性. Function.apply(obj,args)方法能接收两个参数obj：这个对象将代替Function类里this对象args：这个是数组，它将作为参数传给Function（args–&gt;arguments） call:和apply的意思一样,只不过是参数列表不一样. Function.call(obj,[param1[,param2[,…[,paramN]]]])obj：这个对象将代替Function类里this对象params：这个是一个参数列表 apply示例:1234567891011121314151617181920&lt;script type=\"text/javascript\"&gt; /*定义一个人类*/ function Person(name,age) &#123; this.name=name; this.age=age; &#125; /*定义一个学生类*/ functionStudent(name,age,grade) &#123; Person.apply(this,arguments); this.grade=grade; &#125; //创建一个学生类 var student=new Student(\"qian\",21,\"一年级\"); //测试 alert(\"name:\"+student.name+\"\\n\"+\"age:\"+student.age+\"\\n\"+\"grade:\"+student.grade); //大家可以看到测试结果name:qian age:21 grade:一年级 //学生类里面我没有给name和age属性赋值啊,为什么又存在这两个属性的值呢,这个就是apply的神奇之处.&lt;/script&gt; 分析: Person.apply(this,arguments); this:在创建对象在这个时候代表的是student arguments:是一个数组,也就是[“qian”,”21”,”一年级”];也就是通俗一点讲就是:用student去执行Person这个类里面的内容,在Person这个类里面存在this.name等之类的语句,这样就将属性创建到了student对象里面 call示例在Studen函数里面可以将apply中修改成如下:1Person.call(this,name,age); 什么情况下用apply,什么情况下用call在给对象参数的情况下,如果参数的形式是数组的时候,比如apply示例里面传递了参数arguments,这个参数是数组类型,并且在调用Person的时候参数的列表是对应一致的(也就是Person和Student的参数列表前两位是一致的) 就可以采用 apply , 如果我的Person的参数列表是这样的(age,name),而Student的参数列表是(name,age,grade),这样就可以用call来实现了,也就是直接指定参数列表对应值的位置(Person.call(this,age,name,grade)); apply的一些其他巧妙用法细心的人可能已经察觉到,在我调用apply方法的时候,第一个参数是对象(this), 第二个参数是一个数组集合, 在调用Person的时候,他需要的不是一个数组,但是为什么他给我一个数组我仍然可以将数组解析为一个一个的参数,这个就是apply的一个巧妙的用处,可以将一个数组默认的转换为一个参数列表([param1,param2,param3] 转换为 param1,param2,param3) 这个如果让我们用程序来实现将数组的每一个项,来装换为参数的列表,可能都得费一会功夫,借助apply的这点特性,所以就有了以下高效率的方法: a) Math.max 可以实现得到数组中最大的一项 因为Math.max参数里面不支持Math.max([param1,param2])也就是数组但是它支持Math.max(param1,param2,param3…),所以可以根据刚才apply的那个特点来解决 var max=Math.max.apply(null,array),这样轻易的可以得到一个数组中最大的一项(apply会将一个数组装换为一个参数接一个参数的传递给方法)这块在调用的时候第一个参数给了一个null,这个是因为没有对象去调用这个方法,我只需要用这个方法帮我运算,得到返回的结果就行,.所以直接传递了一个null过去 b) Math.min 可以实现得到数组中最小的一项同样和 max是一个思想 var min=Math.min.apply(null,array); c) Array.prototype.push 可以实现两个数组合并 同样push方法没有提供push一个数组,但是它提供了push(param1,param,…paramN) 所以同样也可以通过apply来装换一下这个数组,即:123vararr1=new Array(\"1\",\"2\",\"3\");vararr2=new Array(\"4\",\"5\",\"6\");Array.prototype.push.apply(arr1,arr2);","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://xdd7130.github.io/categories/Web前端/"}],"tags":[{"name":"js","slug":"js","permalink":"http://xdd7130.github.io/tags/js/"}]},{"title":"node基础(三)","slug":"node3","date":"2019-08-10T09:41:11.000Z","updated":"2022-11-02T11:15:20.556Z","comments":true,"path":"2019/08/10/node3/","link":"","permalink":"http://xdd7130.github.io/2019/08/10/node3/","excerpt":"","text":"什么是node.js编写高性能网络服务器的JS工具包（用js开发服务端程序）单线程、异步、事件驱动特点：快、耗内存 框架express、koa、Hapi、以及express基础上的sails node的安装http://nodejs.cn/是否成功：12node -v npm -v 第一个hello程序12345678910var http = require('http');http.createServer(function(request,response)&#123; response.writeHead(200,&#123;'Content-Type': 'text/html; charset=utf-8'&#125;); if (request.url!==\"/favicon.ico\") &#123; //清除第二次访问 console.log('访问'); response.write('hello,world'); response.end('你好，世界'); &#125;&#125;).listen(8000);console.log('Server running at http://localhost:8000/'); 调用函数 调用本地函数 调用其他js文件中的函数 12345678910111213141516171819202122232425var http = require('http'); var otherfun = require(\"./models/other_func.js\"); http.createServer(function(request,response)&#123; response.writeHead(200,&#123;'Content-Type': 'text/html; charset=utf-8'&#125;); if (request.url!==\"/favicon.ico\") &#123; //fun1(response); otherfun.fun2(response); otherfun.fun3(response); //用字符串调用对应函数 // otherfun.fun2(response); // otherfun.fun3(response); funname = 'fun3'; otherfun[funname](response); response.end(''); &#125;&#125;).listen(8000);console.log('Server running at http://10.75.68.123:8000/');function fun1(res)&#123; // 本文件函数 console.log(\"fun1\"); res.write(\"hello,我是fun1\");&#125; 关于被调用的函数：123456//只支持一个函数function fun2(res)&#123; console.log(\"fun2\"); res.write(\"hello,我是fun2\");&#125;module.exports = fun2; 123456789101112 //支持多个函数module.exports=&#123; fun2:function(res)&#123; console.log(\"fun2\"); res.write(\"hello,我是fun2\"); &#125;, fun3:function(res)&#123; console.log(\"fun3\"); res.write(\"hello,我是fun3\"); &#125;&#125; 调用模块123456789101112131415161718 var http = require('http'); // var User = require(\"./models/User\"); var Teacher = require(\"./models/Teacher\"); http.createServer(function(request,response)&#123; response.writeHead(200,&#123;'Content-Type': 'text/html; charset=utf-8'&#125;); if (request.url!==\"/favicon.ico\") &#123; teacher = new Teacher(1,\"张三\",20); teacher.enter(); teacher.teach(response); // user.id=1; // user.name=\"张三\"; // user.age=20; // user.enter(); response.end(''); &#125;&#125;).listen(8000);console.log('Server running at http://localhost:8000/'); 路由初步123456789101112131415 var http = require('http'); var url = require(\"url\"); var router = require(\"./router\");http.createServer(function(request,response)&#123; response.writeHead(200,&#123;'Content-Type': 'text/html; charset=utf-8'&#125;); if (request.url!==\"/favicon.ico\") &#123; var pathname=url.parse(request.url).pathname; pathname = pathname.replace(/\\//,''); //替换掉前面的\"/\" router[pathname](request,response); console.log(pathname); response.end(''); &#125;&#125;).listen(8000);console.log('Server running at http://10.75.68.123:8000/'); 读文件1234567891011121314151617181920212223242526272829303132var http = require('http'); var url = require('url'); var router = require('./router'); // var optfile = require(\"./models/optfile\"); http.createServer(function(request,response)&#123; response.writeHead(200,&#123;'Content-Type': 'text/html; charset=utf-8'&#125;); if (request.url!==\"/favicon.ico\") &#123; var pathname=url.parse(request.url).pathname; pathname = pathname.replace(/\\//,''); //替换掉前面的\"/\" router[pathname](request,response); /* // optfile.readfileSync('./views/login.html'); // optfile.readFile('./views/login.html'); function recall(data)&#123; response.write(data); response.end('ok'); //不写则没有http协议尾 &#125; optfile.readFile('./views/login.html',recall); // optfile.readFile('C:\\inetpub\\wwwroot\\HN_NTZJS01/index.html',recall); console.log(\"主程序执行完毕\"); */ &#125;&#125;).listen(8000);console.log('Server running at http://localhost:8000/') 待续。。。","categories":[{"name":"Node","slug":"Node","permalink":"http://xdd7130.github.io/categories/Node/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://xdd7130.github.io/tags/Node-js/"}]},{"title":"node基础(二)","slug":"node2","date":"2019-08-09T06:38:25.000Z","updated":"2022-11-02T11:15:20.555Z","comments":true,"path":"2019/08/09/node2/","link":"","permalink":"http://xdd7130.github.io/2019/08/09/node2/","excerpt":"","text":"Node.js REPL(交互式解释器)Node.js REPL(Read Eval Print Loop:交互式解释器) 表示一个电脑的环境，类似 Window 系统的终端或 Unix/Linux shell，我们可以在终端中输入命令，并接收系统的响应。我们可以输入以下命令来启动 Node 的终端：12$ node&gt; 停止 REPL前面我们已经提到按下两次 ctrl + c 键就能退出 REPL:1234$ node&gt;(^C again to quit)&gt; Node.js 回调函数Node.js 异步编程的直接体现就是回调。 异步编程依托于回调来实现，但不能说使用了回调后程序就异步化了。 回调函数在完成任务后就会被调用，Node 使用了大量的回调函数，Node 所有 API 都支持回调函数。 例如，我们可以一边读取文件，一边执行其他命令，在文件读取完成后，我们将文件内容作为回调函数的参数返回。这样在执行代码时就没有阻塞或等待文件 I/O 操作。这就大大提高了 Node.js 的性能，可以处理大量的并发请求。 回调函数一般作为函数的最后一个参数出现：12function foo1(name, age, callback) &#123; &#125;function foo2(value, callback1, callback2) &#123; &#125; 阻塞代码实例创建一个文件 input.txt ，内容如下： 菜鸟教程官网地址：www.runoob.com创建 main.js 文件, 代码如下：123456var fs = require(&quot;fs&quot;);var data = fs.readFileSync(&apos;input.txt&apos;);console.log(data.toString());console.log(&quot;程序执行结束!&quot;); 以上代码执行结果如下：1234$ node main.js菜鸟教程官网地址：www.runoob.com程序执行结束! 非阻塞代码实例创建一个文件 input.txt ，内容如下： 菜鸟教程官网地址：www.runoob.com创建 main.js 文件, 代码如下：1234567var fs = require(&quot;fs&quot;);fs.readFile(&apos;input.txt&apos;, function (err, data) &#123; if (err) return console.error(err); console.log(data.toString());&#125;);console.log(&quot;程序执行结束!&quot;); 以上代码执行结果如下：123$ node main.js程序执行结束!菜鸟教程官网地址：www.runoob.com 以上两个实例我们了解了阻塞与非阻塞调用的不同。第一个实例在文件读取完后才执行完程序。 第二个实例我们不需要等待文件读取完，这样就可以在读取文件时同时执行接下来的代码，大大提高了程序的性能。 因此，阻塞是按顺序执行的，而非阻塞是不需要按顺序的，所以如果需要处理回调函数的参数，我们就需要写在回调函数内。 Node.js 事件循环Node.js 是单进程单线程应用程序，但是因为 V8 引擎提供的异步执行回调接口，通过这些接口可以处理大量的并发，所以性能非常高。 Node.js 几乎每一个 API 都是支持回调函数的。 Node.js 基本上所有的事件机制都是用设计模式中观察者模式实现。 Node.js 单线程类似进入一个while(true)的事件循环，直到没有事件观察者退出，每个异步事件都生成一个事件观察者，如果有事件发生就调用该回调函数. 事件驱动程序Node.js 使用事件驱动模型，当web server接收到请求，就把它关闭然后进行处理，然后去服务下一个web请求。 当这个请求完成，它被放回处理队列，当到达队列开头，这个结果被返回给用户。 这个模型非常高效可扩展性非常强，因为webserver一直接受请求而不等待任何读写操作。（这也被称之为非阻塞式IO或者事件驱动IO） 在事件驱动模型中，会生成一个主循环来监听事件，当检测到事件时触发回调函数。整个事件驱动的流程就是这么实现的，非常简洁。有点类似于观察者模式，事件相当于一个主题(Subject)，而所有注册到这个事件上的处理函数相当于观察者(Observer)。 Node.js 有多个内置的事件，我们可以通过引入 events 模块，并通过实例化 EventEmitter 类来绑定和监听事件，如下实例：1234// 引入 events 模块var events = require(&apos;events&apos;);// 创建 eventEmitter 对象var eventEmitter = new events.EventEmitter(); 下程序绑定事件处理程序：12// 绑定事件及事件的处理程序eventEmitter.on(&apos;eventName&apos;, eventHandler); 我们可以通过程序触发事件：12// 触发事件eventEmitter.emit(&apos;eventName&apos;); 实例创建 main.js 文件，代码如下所示： 实例12345678910111213141516171819202122232425// 引入 events 模块var events = require(&apos;events&apos;);// 创建 eventEmitter 对象var eventEmitter = new events.EventEmitter(); // 创建事件处理程序var connectHandler = function connected() &#123; console.log(&apos;连接成功。&apos;); // 触发 data_received 事件 eventEmitter.emit(&apos;data_received&apos;);&#125; // 绑定 connection 事件处理程序eventEmitter.on(&apos;connection&apos;, connectHandler); // 使用匿名函数绑定 data_received 事件eventEmitter.on(&apos;data_received&apos;, function()&#123; console.log(&apos;数据接收成功。&apos;);&#125;); // 触发 connection 事件 eventEmitter.emit(&apos;connection&apos;); console.log(&quot;程序执行完毕。&quot;); 接下来让我们执行以上代码：1234$ node main.js连接成功。数据接收成功。程序执行完毕。 Node.js EventEmitterNode.js 所有的异步 I/O 操作在完成时都会发送一个事件到事件队列。 Node.js 里面的许多对象都会分发事件：一个 net.Server 对象会在每次有新连接时触发一个事件， 一个 fs.readStream 对象会在文件被打开的时候触发一个事件。 所有这些产生事件的对象都是 events.EventEmitter 的实例。 EventEmitter 类events 模块只提供了一个对象： events.EventEmitter。EventEmitter 的核心就是事件触发与事件监听器功能的封装。 你可以通过require(“events”);来访问该模块。1234// 引入 events 模块var events = require(&apos;events&apos;);// 创建 eventEmitter 对象var eventEmitter = new events.EventEmitter(); EventEmitter 对象如果在实例化时发生错误，会触发 error 事件。当添加新的监听器时，newListener 事件会触发，当监听器被移除时，removeListener 事件被触发。 下面我们用一个简单的例子说明 EventEmitter 的用法：123456789//event.js 文件var EventEmitter = require(&apos;events&apos;).EventEmitter; var event = new EventEmitter(); event.on(&apos;some_event&apos;, function() &#123; console.log(&apos;some_event 事件触发&apos;); &#125;); setTimeout(function() &#123; event.emit(&apos;some_event&apos;); &#125;, 1000); 执行结果如下： 运行这段代码，1 秒后控制台输出了 ‘some_event 事件触发’。其原理是 event 对象注册了事件 some_event 的一个监听器，然后我们通过 setTimeout 在 1000 毫秒以后向 event 对象发送事件 some_event，此时会调用some_event 的监听器。12$ node event.js some_event 事件触发 EventEmitter 的每个事件由一个事件名和若干个参数组成，事件名是一个字符串，通常表达一定的语义。对于每个事件，EventEmitter 支持 若干个事件监听器。 当事件触发时，注册到这个事件的事件监听器被依次调用，事件参数作为回调函数参数传递。12345678910//event.js 文件var events = require(&apos;events&apos;); var emitter = new events.EventEmitter(); emitter.on(&apos;someEvent&apos;, function(arg1, arg2) &#123; console.log(&apos;listener1&apos;, arg1, arg2); &#125;); emitter.on(&apos;someEvent&apos;, function(arg1, arg2) &#123; console.log(&apos;listener2&apos;, arg1, arg2); &#125;); emitter.emit(&apos;someEvent&apos;, &apos;arg1 参数&apos;, &apos;arg2 参数&apos;); 执行以上代码，运行的结果如下：123$ node event.js listener1 arg1 参数 arg2 参数listener2 arg1 参数 arg2 参数 以上例子中，emitter 为事件 someEvent 注册了两个事件监听器，然后触发了 someEvent 事件。 运行结果中可以看到两个事件监听器回调函数被先后调用。 这就是EventEmitter最简单的用法。 EventEmitter 提供了多个属性，如 on 和 emit。on 函数用于绑定事件函数，emit 属性用于触发一个事件。接下来我们来具体看下 EventEmitter 的属性介绍。 方法","categories":[{"name":"Node","slug":"Node","permalink":"http://xdd7130.github.io/categories/Node/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://xdd7130.github.io/tags/Node-js/"}]},{"title":"node基础(一)","slug":"node1","date":"2019-08-08T03:09:06.000Z","updated":"2022-11-02T11:15:20.555Z","comments":true,"path":"2019/08/08/node1/","link":"","permalink":"http://xdd7130.github.io/2019/08/08/node1/","excerpt":"","text":"JavaScript的后端开发在Node上运行的JavaScript相比其他后端开发语言有何优势？最大的优势是借助JavaScript天生的事件驱动机制加V8高性能引擎，使编写高性能Web服务轻而易举 安装Node.js和npm由于Node.js平台是在后端运行JavaScript代码，所以，必须首先在本机安装Node环境。 安装Node.js从Node.js官网下载对应平台的安装程序安装完成后，在Windows环境下，请打开命令提示符，然后输入node -v，如果安装正常，你应该看到v7.6.0这样的输出：12C:\\Users\\IEUser&gt;node -vv7.6.0 npm在正式开始Node.js学习之前，我们先认识一下npm。 npm是什么东东？npm其实是Node.js的包管理工具（package manager）。 为啥我们需要一个包管理工具呢？因为我们在Node.js上开发时，会用到很多别人写的JavaScript代码。如果我们要使用别人写的某个包，每次都根据名称搜索一下官方网站，下载代码，解压，再使用，非常繁琐。于是一个集中管理的工具应运而生：大家都把自己开发的模块打包后放到npm官网上，如果要使用，直接通过npm安装就可以直接用，不用管代码存在哪，应该从哪下载。 更重要的是，如果我们要使用模块A，而模块A又依赖于模块B，模块B又依赖于模块X和模块Y，npm可以根据依赖关系，把所有依赖的包都下载下来并管理起来。否则，靠我们自己手动管理，肯定既麻烦又容易出错。 讲了这么多，npm究竟在哪？ 其实npm已经在Node.js安装的时候顺带装好了。我们在命令提示符或者终端输入npm -v，应该看到类似的输出：12C:\\&gt;npm -v4.1.2 如果直接输入npm，你会看到类似下面的输出：12345C:\\&gt; npmUsage: npm &lt;command&gt;where &lt;command&gt; is one of: 卸载模块我们可以使用以下命令来卸载 Node.js 模块。 $ npm uninstall express卸载后，你可以到 /node_modules/ 目录下查看包是否还存在，或者使用以下命令查看： $ npm ls 更新模块我们可以使用以下命令更新模块： $ npm update express 搜索模块使用以下来搜索模块：$ npm search express NPM 常用命令 NPM提供了很多命令，例如install和publish，使用npm help可查看所有命令。 使用npm help 可查看某条命令的详细帮助，例如npm help install。 在package.json所在目录下使用npm install . -g可先在本地安装当前命令行程序，可用于发布前的本地测试。 使用npm update 可以把当前目录下node_modules子目录里边的对应模块更新至最新版本。 使用npm update -g可以把全局安装的对应命令行程序更新至最新版。 使用npm cache clear可以清空NPM本地缓存，用于对付使用相同版本号发布新版本代码的人。 使用npm unpublish @可以撤销发布自己发布过的某个版本代码。 使用淘宝 NPM 镜像1$ npm install -g cnpm --registry=https://registry.npm.taobao.org 这样就可以使用 cnpm 命令来安装模块了：1$ cnpm install [name] 小结请在本机安装Node.js环境，并确保node和npm能正常运行。 第一个Node程序用文本编辑器写JavaScript程序，然后保存为后缀为.js的文件，就可以用node直接运行这个程序了。 Node的交互模式和直接运行.js文件有什么区别呢？ 直接输入node进入交互模式，相当于启动了Node解释器，但是等待你一行一行地输入源代码，每输入一行就执行一行。 直接运行node hello.js文件相当于启动了Node解释器，然后一次性把hello.js文件的源代码给执行了，你是没有机会以交互的方式输入源代码的。 在编写JavaScript代码的时候，完全可以一边在文本编辑器里写代码，一边开一个Node交互式命令窗口，在写代码的过程中，把部分代码粘到命令行去验证，事半功倍！前提是得有个27’的超大显示器！ 搭建Node开发环境使用文本编辑器来开发Node程序，最大的缺点是效率太低，运行Node程序还需要在命令行单独敲命令。如果还需要调试程序，就更加麻烦了。 所以我们需要一个IDE集成开发环境，让我们能在一个环境里编码、运行、调试，这样就可以大大提升开发效率。 Java的集成开发环境有Eclipse，Intellij idea等，C#的集成开发环境有Visual Studio，那么问题又来了：Node.js的集成开发环境到底哪家强？ 考察Node.js的集成开发环境，重点放在启动速度快，执行简单，调试方便这三点上。当然，免费使用是一个加分项。 综合考察后，我们隆重向大家推荐Node.js集成开发环境： vscodeVisual Studio Code由微软出品，但它不是那个大块头的Visual Studio，它是一个精简版的迷你Visual Studio，并且，Visual Studio Code可以跨！平！台！Windows、Mac和Linux通用。 运行和调试JavaScript在VS Code中，我们可以非常方便地运行JavaScript文件。 VS Code以文件夹作为工程目录（Workspace Dir），所有的JavaScript文件都存放在该目录下。此外，VS Code在工程目录下还需要一个.vscode的配置目录，里面存放里VS Code需要的配置文件。 假设我们在C:\\Work\\目录下创建了一个hello目录作为工程目录，并编写了一个hello.js文件，则该工程目录的结构如下：1234567hello/ &lt;-- workspace dir|+- hello.js &lt;-- JavaScript file|+- .vscode/ &lt;-- VS Code config | +- launch.json &lt;-- VS Code config file for JavaScript 可以用VS Code快速创建launch.json，然后修改如下：12345678910111213141516171819202122232425&#123; &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ &#123; &quot;name&quot;: &quot;Run hello.js&quot;, &quot;type&quot;: &quot;node&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;program&quot;: &quot;$&#123;workspaceRoot&#125;/hello.js&quot;, &quot;stopOnEntry&quot;: false, &quot;args&quot;: [], &quot;cwd&quot;: &quot;$&#123;workspaceRoot&#125;&quot;, &quot;preLaunchTask&quot;: null, &quot;runtimeExecutable&quot;: null, &quot;runtimeArgs&quot;: [ &quot;--nolazy&quot; ], &quot;env&quot;: &#123; &quot;NODE_ENV&quot;: &quot;development&quot; &#125;, &quot;externalConsole&quot;: false, &quot;sourceMaps&quot;: false, &quot;outDir&quot;: null &#125; ]&#125; 有了配置文件，即可使用VS Code调试JavaScript。 模块在计算机程序的开发过程中，随着程序代码越写越多，在一个文件里代码就会越来越长，越来越不容易维护。 为了编写可维护的代码，我们把很多函数分组，分别放到不同的文件里，这样，每个文件包含的代码就相对较少，很多编程语言都采用这种组织代码的方式。在Node环境中，一个.js文件就称之为一个模块（module）。 使用模块有什么好处？ 最大的好处是大大提高了代码的可维护性。其次，编写代码不必从零开始。当一个模块编写完毕，就可以被其他地方引用。我们在编写程序的时候，也经常引用其他模块，包括Node内置的模块和来自第三方的模块。 使用模块还可以避免函数名和变量名冲突。相同名字的函数和变量完全可以分别存在不同的模块中，因此，我们自己在编写模块时，不必考虑名字会与其他模块冲突。 在上一节，我们编写了一个hello.js文件，这个hello.js文件就是一个模块，模块的名字就是文件名（去掉.js后缀），所以hello.js文件就是名为hello的模块。 我们把hello.js改造一下，创建一个函数，这样我们就可以在其他地方调用这个函数：123456789&apos;use strict&apos;;var s = &apos;Hello&apos;;function greet(name) &#123; console.log(s + &apos;, &apos; + name + &apos;!&apos;);&#125;module.exports = greet; 函数greet()是我们在hello模块中定义的，你可能注意到最后一行是一个奇怪的赋值语句，它的意思是，把函数greet作为模块的输出暴露出去，这样其他模块就可以使用greet函数了。 问题是其他模块怎么使用hello模块的这个greet函数呢？我们再编写一个main.js文件，调用hello模块的greet函数：12345678&apos;use strict&apos;;// 引入hello模块:var greet = require(&apos;./hello&apos;);var s = &apos;Michael&apos;;greet(s); // Hello, Michael! 注意到引入hello模块用Node提供的require函数：1var greet = require(&apos;./hello&apos;); 引入的模块作为变量保存在greet变量中，那greet变量到底是什么东西？其实变量greet就是在hello.js中我们用module.exports = greet;输出的greet函数。所以，main.js就成功地引用了hello.js模块中定义的greet()函数，接下来就可以直接使用它了。 在使用require()引入模块的时候，请注意模块的相对路径。因为main.js和hello.js位于同一个目录，所以我们用了当前目录.：1var greet = require(&apos;./hello&apos;); // 不要忘了写相对目录! 如果只写模块名：1var greet = require(&apos;hello&apos;); 则Node会依次在内置模块、全局模块和当前模块下查找hello.js，你很可能会得到一个错误：123456789module.js throw err; ^Error: Cannot find module &apos;hello&apos; at Function.Module._resolveFilename at Function.Module._load ... at Function.Module._load at Function.Module.runMain 遇到这个错误，你要检查： 模块名是否写对了； 模块文件是否存在； 相对路径是否写对了。 CommonJS规范这种模块加载机制被称为CommonJS规范。在这个规范下，每个.js文件都是一个模块，它们内部各自使用的变量名和函数名都互不冲突，例如，hello.js和main.js都申明了全局变量var s = ‘xxx’，但互不影响。 一个模块想要对外暴露变量（函数也是变量），可以用module.exports = variable;，一个模块要引用其他模块暴露的变量，用var ref = require(‘module_name’);就拿到了引用模块的变量。 结论要在模块中对外输出变量，用：1module.exports = variable; 输出的变量可以是任意对象、函数、数组等等。 要引入其他模块输出的对象，用：1var foo = require(&apos;other_module&apos;); 引入的对象具体是什么，取决于引入模块输出的对象。 module.exports vs exports很多时候，你会看到，在Node环境中，有两种方法可以在一个模块中输出变量： 方法一：对module.exports赋值：1234567891011121314// hello.jsfunction hello() &#123; console.log(&apos;Hello, world!&apos;);&#125;function greet(name) &#123; console.log(&apos;Hello, &apos; + name + &apos;!&apos;);&#125;module.exports = &#123; hello: hello, greet: greet&#125;; 方法二：直接使用exports：12345678910111213141516// hello.jsfunction hello() &#123; console.log(&apos;Hello, world!&apos;);&#125;function greet(name) &#123; console.log(&apos;Hello, &apos; + name + &apos;!&apos;);&#125;function hello() &#123; console.log(&apos;Hello, world!&apos;);&#125;exports.hello = hello;exports.greet = greet; 但是你不可以直接对exports赋值：12345// 代码可以执行，但是模块并没有输出任何变量:exports = &#123; hello: hello, greet: greet&#125;","categories":[{"name":"Node","slug":"Node","permalink":"http://xdd7130.github.io/categories/Node/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://xdd7130.github.io/tags/Node-js/"}]},{"title":"WebSocket","slug":"WebSocket","date":"2019-08-07T12:42:20.000Z","updated":"2022-11-02T11:15:20.544Z","comments":true,"path":"2019/08/07/WebSocket/","link":"","permalink":"http://xdd7130.github.io/2019/08/07/WebSocket/","excerpt":"","text":"WebSocketWebSocket是HTML5新增的协议，它的目的是在浏览器和服务器之间建立一个不受限的双向通信的通道，比如说，服务器可以在任意时刻发送消息给浏览器。 WebSocket 是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。 WebSocket使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在 WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。 在 WebSocket API 中，浏览器和服务器只需要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。 现在，很多网站为了实现推送技术，所用的技术都是 Ajax 轮询。轮询是在特定的的时间间隔（如每1秒），由浏览器对服务器发出HTTP请求，然后由服务器返回最新的数据给客户端的浏览器。这种传统的模式带来很明显的缺点，即浏览器需要不断的向服务器发出请求，然而HTTP请求可能包含较长的头部，其中真正有效的数据可能只是很小的一部分，显然这样会浪费很多的带宽等资源。 HTML5 定义的 WebSocket 协议，能更好的节省服务器资源和带宽，并且能够更实时地进行通讯。浏览器通过 JavaScript 向服务器发出建立 WebSocket 连接的请求，连接建立以后，客户端和服务器端就可以通过 TCP 连接直接交换数据。 当你获取 Web Socket 连接后，你可以通过 send() 方法来向服务器发送数据，并通过 onmessage 事件来接收服务器返回的数据。 以下 API 用于创建 WebSocket 对象。1var Socket = new WebSocket(url, [protocol] ); 以上代码中的第一个参数 url, 指定连接的 URL。第二个参数 protocol 是可选的，指定了可接受的子协议。 WebSocket 属性以下是 WebSocket 对象的属性。假定我们使用了以上代码创建了 Socket 对象： WebSocket 事件以下是 WebSocket 对象的相关事件。假定我们使用了以上代码创建了 Socket 对象： WebSocket 方法以下是 WebSocket 对象的相关方法。假定我们使用了以上代码创建了 Socket 对象： WebSocket 协议本质上是一个基于 TCP 的协议。 为了建立一个 WebSocket 连接，客户端浏览器首先要向服务器发起一个 HTTP 请求，这个请求和通常的 HTTP 请求不同，包含了一些附加头信息，其中附加头信息”Upgrade: WebSocket”表明这是一个申请协议升级的 HTTP 请求，服务器端解析这些附加的头信息然后产生应答信息返回给客户端，客户端和服务器端的 WebSocket 连接就建立起来了，双方就可以通过这个连接通道自由的传递信息，并且这个连接会持续存在直到客户端或者服务器端的某一方主动的关闭连接。","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://xdd7130.github.io/categories/Web前端/"}],"tags":[{"name":"WebSocket","slug":"WebSocket","permalink":"http://xdd7130.github.io/tags/WebSocket/"}]},{"title":"python基础(四)","slug":"python基础4","date":"2019-08-07T12:04:14.000Z","updated":"2022-11-02T11:15:20.668Z","comments":true,"path":"2019/08/07/python基础4/","link":"","permalink":"http://xdd7130.github.io/2019/08/07/python基础4/","excerpt":"","text":"Python 模块Python 模块(Module)，是一个 Python 文件，以 .py 结尾，包含了 Python 对象定义和Python语句。 模块让你能够有逻辑地组织你的 Python 代码段。 把相关的代码分配到一个模块里能让你的代码更好用，更易懂。 模块能定义函数，类和变量，模块里也能包含可执行的代码。下例是个简单的模块 support.py：123def print_func( par ): print &quot;Hello : &quot;, par return import 语句1import module1[, module2[,... moduleN]] 比如要引用模块 math，就可以在文件最开始的地方用 import math 来引入。在调用 math 模块中的函数时，必须这样引用：1模块名.函数名 当解释器遇到 import 语句，如果模块在当前的搜索路径就会被导入。 搜索路径是一个解释器会先进行搜索的所有目录的列表。如想要导入模块 support.py，需要把命令放在脚本的顶端： test.py 文件代码：12345678#!/usr/bin/python# -*- coding: UTF-8 -*- # 导入模块import support # 现在可以调用模块里包含的函数了support.print_func(&quot;Runoob&quot;) from…import 语句Python 的 from 语句让你从模块中导入一个指定的部分到当前命名空间中。语法如下：1from modname import name1[, name2[, ... nameN]] 例如，要导入模块 fib 的 fibonacci 函数，使用如下语句：1from fib import fibonacci from…import* 语句把一个模块的所有内容全都导入到当前的命名空间也是可行的，只需使用如下声明：1from modname import * dir()函数dir() 函数一个排好序的字符串列表，内容是一个模块里定义过的名字。 返回的列表容纳了在一个模块里定义的所有模块，变量和函数。如下一个简单的实例：123456789#!/usr/bin/python# -*- coding: UTF-8 -*- # 导入内置math模块import math content = dir(math) print content; Python 文件I/O打印到屏幕最简单的输出方法是用print语句，你可以给它传递零个或多个用逗号隔开的表达式。此函数把你传递的表达式转换成一个字符串表达式，并将结果写到标准输出如下：1234#!/usr/bin/python# -*- coding: UTF-8 -*- print &quot;Python 是一个非常棒的语言，不是吗？&quot; 读取键盘输入Python提供了两个内置函数从标准输入读入一行文本，默认的标准输入是键盘。如下： raw_input input 打开和关闭文件open 函数你必须先用Python内置的open()函数打开一个文件，创建一个file对象，相关的方法才可以调用它进行读写。1file object = open(file_name [, access_mode][, buffering]) file_name：file_name变量是一个包含了你要访问的文件名称的字符串值。 access_mode：access_mode决定了打开文件的模式：只读，写入，追加等。所有可取值见如下的完全列表。这个参数是非强制的，默认文件访问模式为只读(r)。 buffering:如果buffering的值被设为0，就不会有寄存。如果buffering的值取1，访问文件时会寄存行。如果将buffering的值设为大于1的整数，表明了这就是的寄存区的缓冲大小。如果取负值，寄存区的缓冲大小则为系统默认。 write()方法write()方法可将任何字符串写入一个打开的文件。需要重点注意的是，Python字符串可以是二进制数据，而不是仅仅是文字。 write()方法不会在字符串的结尾添加换行符(‘\\n’) read()方法read（）方法从一个打开的文件中读取一个字符串。需要重点注意的是，Python字符串可以是二进制数据，而不是仅仅是文字。 remove()方法你可以用remove()方法删除文件，需要提供要删除的文件名作为参数 tell()方法,seek（offset [,from]）文件定位 重命名和删除文件 Python的os模块提供了帮你执行文件处理操作的方法，比如重命名和删除文件。要使用这个模块，你必须先导入它，然后才可以调用相关的各种功能。rename()方法：rename()方法需要两个参数，当前的文件名和新文件名。 1os.rename(current_file_name, new_file_name) 下例将重命名一个已经存在的文件test1.txt。1234567#!/usr/bin/python# -*- coding: UTF-8 -*-import os # 重命名文件test1.txt到test2.txt。os.rename( &quot;test1.txt&quot;, &quot;test2.txt&quot; ) remove()方法你可以用remove()方法删除文件，需要提供要删除的文件名作为参数。语法：1os.remove(file_name) 例子：1234567#!/usr/bin/python# -*- coding: UTF-8 -*-import os # 删除一个已经存在的文件test2.txtos.remove(&quot;test2.txt&quot;)","categories":[{"name":"python","slug":"python","permalink":"http://xdd7130.github.io/categories/python/"}],"tags":[{"name":"python基础","slug":"python基础","permalink":"http://xdd7130.github.io/tags/python基础/"}]},{"title":"python基础(三)--数据类型","slug":"python基础3","date":"2019-08-07T10:59:42.000Z","updated":"2022-11-02T11:15:20.660Z","comments":true,"path":"2019/08/07/python基础3/","link":"","permalink":"http://xdd7130.github.io/2019/08/07/python基础3/","excerpt":"","text":"Python Number(数字)Python Number 数据类型用于存储数值。 数据类型是不允许改变的,这就意味着如果改变 Number 数据类型的值，将重新分配内存空间。 以下实例在变量赋值时 Number 对象将被创建：12var1 = 1var2 = 10 Python 支持四种不同的数值类型： 整型(Int) - 通常被称为是整型或整数，是正或负整数，不带小数点。 长整型(long integers) - 无限大小的整数，整数最后是一个大写或小写的L。 浮点型(floating point real values) - 浮点型由整数部分与小数部分组成，浮点型也可以使用科学计数法表示（2.5e2 = 2.5 x 102 = 250） 复数(complex numbers) - 复数由实数部分和虚数部分构成，可以用a + bj,或者complex(a,b)表示， 复数的实部a和虚部b都是浮点型。 Python Number 类型转换 Python math 模块、cmath 模块Python 中数学运算常用的函数基本都在 math 模块、cmath 模块中。 Python math 模块提供了许多对浮点数的数学运算函数。 Python cmath 模块包含了一些用于复数运算的函数。 cmath 模块的函数跟 math 模块函数基本一致，区别是 cmath 模块运算的是复数，math 模块运算的是数学运算。 要使用 math 或 cmath 函数必须先导入：1import math Python数学函数 Python随机数函数 Python三角函数 Python数学常量 Python 字符串可以使用引号(‘或”)来创建字符串Python访问字符串中的值Python不支持单字符类型，单字符在 Python 中也是作为一个字符串使用。 Python访问子字符串，可以使用方括号来截取字符串，如下实例：1234567#!/usr/bin/python var1 = &apos;Hello World!&apos;var2 = &quot;Python Runoob&quot; print &quot;var1[0]: &quot;, var1[0]print &quot;var2[1:5]: &quot;, var2[1:5] Python字符串更新1234#!/usr/bin/python# -*- coding: UTF-8 -*-var1 = &apos;Hello World!&apos;print &quot;更新字符串 :- &quot;, var1[:6] + &apos;Runoob!&apos; Python转义字符Python字符串运算符Python 字符串格式化123#!/usr/bin/pythonprint &quot;My name is %s and weight is %d kg!&quot; % (&apos;Zara&apos;, 21) 以上实例输出结果：1My name is Zara and weight is 21 kg! Python三引号（triple quotes） python中三引号可以将复杂的字符串进行复制:python三引号允许一个字符串跨多行，字符串中可以包含换行符、制表符以及其他特殊字符。三引号的语法是一对连续的单引号或者双引号（通常都是成对的用）。 Unicode 字符串引号前小写的”u”表示这里创建的是一个 Unicode 字符串。如果你想加入一个特殊字符，可以使用 Python 的 Unicode-Escape 编码。 Python 列表(List)序列是Python中最基本的数据结构。序列中的每个元素都分配一个数字 - 它的位置，或索引，第一个索引是0，第二个索引是1，依此类推。Python有6个序列的内置类型，但最常见的是列表和元组。序列都可以进行的操作包括索引，切片，加，乘，检查成员。此外，Python已经内置确定序列的长度以及确定最大和最小的元素的方法。列表是最常用的Python数据类型，它可以作为一个方括号内的逗号分隔值出现。列表的数据项不需要具有相同的类型创建一个列表，只要把逗号分隔的不同的数据项使用方括号括起来即可。如下所示：123list1 = [&apos;physics&apos;, &apos;chemistry&apos;, 1997, 2000]list2 = [1, 2, 3, 4, 5 ]list3 = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;] 访问列表中的值使用下标索引来访问列表中的值，同样你也可以使用方括号的形式截取字符，如下所示：1234567#!/usr/bin/python list1 = [&apos;physics&apos;, &apos;chemistry&apos;, 1997, 2000]list2 = [1, 2, 3, 4, 5, 6, 7 ] print &quot;list1[0]: &quot;, list1[0]print &quot;list2[1:5]: &quot;, list2[1:5] 更新列表你可以对列表的数据项进行修改或更新，你也可以使用append()方法来添加列表项，如下所示：1234567#!/usr/bin/python# -*- coding: UTF-8 -*- list = [] ## 空列表list.append(&apos;Google&apos;) ## 使用 append() 添加元素list.append(&apos;Runoob&apos;)print list 删除列表元素12345678#!/usr/bin/python list1 = [&apos;physics&apos;, &apos;chemistry&apos;, 1997, 2000] print list1del list1[2]print &quot;After deleting value at index 2 : &quot;print list1 Python列表脚本操作符列表对 + 和 的操作符与字符串相似。+ 号用于组合列表， 号用于重复列表。Python列表截取12345678&gt;&gt;&gt;L = [&apos;Google&apos;, &apos;Runoob&apos;, &apos;Taobao&apos;]&gt;&gt;&gt; L[2]&apos;Taobao&apos;&gt;&gt;&gt; L[-2]&apos;Runoob&apos;&gt;&gt;&gt; L[1:][&apos;Runoob&apos;, &apos;Taobao&apos;]&gt;&gt;&gt; Python列表函数&amp;方法 Python 元组Python的元组与列表类似，不同之处在于元组的元素不能修改。元组使用小括号，列表使用方括号。元组创建很简单，只需要在括号中添加元素，并使用逗号隔开即可。123tup1 = (&apos;physics&apos;, &apos;chemistry&apos;, 1997, 2000)tup2 = (1, 2, 3, 4, 5 )tup3 = &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot; 创建空元组1tup1 = () 元组中只包含一个元素时，需要在元素后面添加逗号1tup1 = (50,) 访问元组元组可以使用下标索引来访问元组中的值1234567#!/usr/bin/python tup1 = (&apos;physics&apos;, &apos;chemistry&apos;, 1997, 2000)tup2 = (1, 2, 3, 4, 5, 6, 7 ) print &quot;tup1[0]: &quot;, tup1[0]print &quot;tup2[1:5]: &quot;, tup2[1:5] 修改元组元组中的元素值是不允许修改的，但我们可以对元组进行连接组合123456789101112#!/usr/bin/python# -*- coding: UTF-8 -*- tup1 = (12, 34.56)tup2 = (&apos;abc&apos;, &apos;xyz&apos;) # 以下修改元组元素操作是非法的。# tup1[0] = 100 # 创建一个新的元组tup3 = tup1 + tup2print tup3 以上实例输出结果：1(12, 34.56, &apos;abc&apos;, &apos;xyz&apos;) 删除元组元组中的元素值是不允许删除的，但我们可以使用del语句来删除整个元组12345678#!/usr/bin/python tup = (&apos;physics&apos;, &apos;chemistry&apos;, 1997, 2000) print tupdel tupprint &quot;After deleting tup : &quot;print tup 元组运算符与字符串一样，元组之间可以使用 + 号和 * 号进行运算。这就意味着他们可以组合和复制，运算后会生成一个新的元组元组索引，截取无关闭分隔符任意无符号的对象，以逗号隔开，默认为元组元组内置函数 Python 字典(Dictionary)字典是另一种可变容器模型，且可存储任意类型对象。 字典的每个键值 key=&gt;value 对用冒号 : 分割，每个键值对之间用逗号 , 分割，整个字典包括在花括号 {} 中 ,格式如下所示：1d = &#123;key1 : value1, key2 : value2 &#125; 键一般是唯一的，如果重复最后的一个键值对会替换前面的，值不需要唯一。12345&gt;&gt;&gt;dict = &#123;&apos;a&apos;: 1, &apos;b&apos;: 2, &apos;b&apos;: &apos;3&apos;&#125;&gt;&gt;&gt; dict[&apos;b&apos;]&apos;3&apos;&gt;&gt;&gt; dict&#123;&apos;a&apos;: 1, &apos;b&apos;: &apos;3&apos;&#125; 值可以取任何数据类型，但键必须是不可变的，如字符串，数字或元组。 一个简单的字典实例：1dict = &#123;&apos;Alice&apos;: &apos;2341&apos;, &apos;Beth&apos;: &apos;9102&apos;, &apos;Cecil&apos;: &apos;3258&apos;&#125; 访问字典里的值123456#!/usr/bin/python dict = &#123;&apos;Name&apos;: &apos;Zara&apos;, &apos;Age&apos;: 7, &apos;Class&apos;: &apos;First&apos;&#125; print &quot;dict[&apos;Name&apos;]: &quot;, dict[&apos;Name&apos;]print &quot;dict[&apos;Age&apos;]: &quot;, dict[&apos;Age&apos;] 修改字典向字典添加新内容的方法是增加新的键/值对，修改或删除已有键/值对12345678910#!/usr/bin/python dict = &#123;&apos;Name&apos;: &apos;Zara&apos;, &apos;Age&apos;: 7, &apos;Class&apos;: &apos;First&apos;&#125; dict[&apos;Age&apos;] = 8 # 更新dict[&apos;School&apos;] = &quot;RUNOOB&quot; # 添加 print &quot;dict[&apos;Age&apos;]: &quot;, dict[&apos;Age&apos;]print &quot;dict[&apos;School&apos;]: &quot;, dict[&apos;School&apos;] 删除字典元素能删单一的元素也能清空字典，清空只需一项操作。 显示删除一个字典用del命令. Python 日期和时间Python 程序能用很多方式处理日期和时间，转换日期格式是一个常见的功能。 Python 提供了一个 time 和 calendar 模块可以用于格式化日期和时间。 时间间隔是以秒为单位的浮点小数。 每个时间戳都以自从1970年1月1日午夜（历元）经过了多长时间来表示。 Python 的 time 模块下有很多函数可以转换常见日期格式。如函数time.time()用于获取当前时间戳1234567#!/usr/bin/python# -*- coding: UTF-8 -*- import time; # 引入time模块 ticks = time.time()print &quot;当前时间戳为:&quot;, ticks 以上实例输出结果：1当前时间戳为: 1459994552.51 获取当前时间12localtime = time.localtime(time.time())print &quot;本地时间为 :&quot;, localtime 获取格式化的时间1234import time localtime = time.asctime( time.localtime(time.time()) )print &quot;本地时间为 :&quot;, localtime 格式化日期我们可以使用 time 模块的 strftime 方法来格式化日期，：1time.strftime(format[, t]) 获取某月日历12345import calendar cal = calendar.month(2016, 1)print &quot;以下输出2016年1月份的日历:&quot;print cal Python 函数函数是组织好的，可重复使用的，用来实现单一，或相关联功能的代码段。 函数能提高应用的模块性，和代码的重复利用率。你已经知道Python提供了许多内建函数，比如print()。但你也可以自己创建函数，这被叫做用户自定义函数。 定义一个函数你可以定义一个由自己想要功能的函数，以下是简单的规则： 函数代码块以 def 关键词开头，后接函数标识符名称和圆括号()。 任何传入参数和自变量必须放在圆括号中间。圆括号之间可以用于定义参数。 函数的第一行语句可以选择性地使用文档字符串—用于存放函数说明。 函数内容以冒号起始，并且缩进。 return [表达式] 结束函数，选择性地返回一个值给调用方。不带表达式的return相当于返回 None。 函数调用定义一个函数只给了函数一个名称，指定了函数里包含的参数，和代码块结构。 这个函数的基本结构完成以后，你可以通过另一个函数调用执行，也可以直接从Python提示符执行。 如下实例调用了printme（）函数：123456789101112#!/usr/bin/python# -*- coding: UTF-8 -*- # 定义函数def printme( str ): &quot;打印任何传入的字符串&quot; print str; return; # 调用函数printme(&quot;我要调用用户自定义函数!&quot;);printme(&quot;再次调用同一函数&quot;);","categories":[{"name":"python","slug":"python","permalink":"http://xdd7130.github.io/categories/python/"}],"tags":[{"name":"python基础","slug":"python基础","permalink":"http://xdd7130.github.io/tags/python基础/"}]},{"title":"python基础(二)--语句","slug":"python基础2","date":"2019-08-07T10:24:58.000Z","updated":"2022-11-02T11:15:20.650Z","comments":true,"path":"2019/08/07/python基础2/","link":"","permalink":"http://xdd7130.github.io/2019/08/07/python基础2/","excerpt":"","text":"Python 条件语句Python条件语句是通过一条或多条语句的执行结果（True或者False）来决定执行的代码块。1234if 判断条件： 执行语句……else： 执行语句…… if 语句的判断条件可以用&gt;（大于）、&lt;(小于)、==（等于）、&gt;=（大于等于）、&lt;=（小于等于）来表示其关系。 当判断条件为多个值时，可以使用以下形式：12345678if 判断条件1: 执行语句1……elif 判断条件2: 执行语句2……elif 判断条件3: 执行语句3……else: 执行语句4…… 简单的语句组123456#!/usr/bin/python # -*- coding: UTF-8 -*- var = 100 if ( var == 100 ) : print &quot;变量 var 的值为100&quot; print &quot;Good bye!&quot; Python 循环语句循环控制语句 Python While 循环语句Python 编程中 while 语句用于循环执行程序，即在某条件下，循环执行某段程序，以处理需要重复处理的相同任务。其基本形式为：12while 判断条件： 执行语句…… while 语句时还有另外两个重要的命令 continue，break 来跳过循环，continue 用于跳过该次循环，break . 循环使用 else 语句在 python 中，while … else 在循环条件为 false 时执行 else 语句块：12345678#!/usr/bin/python count = 0while count &lt; 5: print count, &quot; is less than 5&quot; count = count + 1else: print count, &quot; is not less than 5&quot; 简单语句组类似 if 语句的语法，如果你的 while循环体中只有一条语句，你可以将该语句与while写在同一行中， 如下所示：1234#!/usr/bin/pythonflag = 1while (flag): print &apos;Given flag is really true!&apos;print &quot;Good bye!&quot; Python for 循环语句Python for循环可以遍历任何序列的项目，如一个列表或者一个字符串。 语法：12for iterating_var in sequence: statements(s) 1234567891011#!/usr/bin/python# -*- coding: UTF-8 -*- for letter in &apos;Python&apos;: # 第一个实例 print &apos;当前字母 :&apos;, letter fruits = [&apos;banana&apos;, &apos;apple&apos;, &apos;mango&apos;]for fruit in fruits: # 第二个实例 print &apos;当前水果 :&apos;, fruit print &quot;Good bye!&quot; 结果：12345678910当前字母 : P当前字母 : y当前字母 : t当前字母 : h当前字母 : o当前字母 : n当前水果 : banana当前水果 : apple当前水果 : mangoGood bye! 通过序列索引迭代:12345678#!/usr/bin/python# -*- coding: UTF-8 -*- fruits = [&apos;banana&apos;, &apos;apple&apos;, &apos;mango&apos;]for index in range(len(fruits)): print &apos;当前水果 :&apos;, fruits[index] print &quot;Good bye!&quot; 循环使用 else 语句在 python 中，for … else 表示这样的意思，for 中的语句和普通的没有区别，else 中的语句会在循环正常执行完（即 for 不是通过 break 跳出而中断的）的情况下执行，while … else 也是一样。12345678for num in range(10,20): # 迭代 10 到 20 之间的数字 for i in range(2,num): # 根据因子迭代 if num%i == 0: # 确定第一个因子 j=num/i # 计算第二个因子 print &apos;%d 等于 %d * %d&apos; % (num,i,j) break # 跳出当前循环 else: # 循环的 else 部分 print num, &apos;是一个质数&apos; Python 循环嵌套Python 语言允许在一个循环体里面嵌入另一个循环。 Python for 循环嵌套语法：12345for iterating_var in sequence: for iterating_var in sequence: statements(s) statements(s)Python while 循环嵌套语法： 1234while expression: while expression: statement(s) statement(s) 你可以在循环体内嵌入其他的循环体，如在while循环中可以嵌入for循环， 反之，你可以在for循环中嵌入while循环 Python break 语句Python break语句，就像在C语言中，打破了最小封闭for或while循环。 break语句用来终止循环语句，即循环条件没有False条件或者序列还没被完全递归完，也会停止执行循环语句。 break语句用在while和for循环中。 如果您使用嵌套循环，break语句将停止执行最深层的循环，并开始执行下一行代码。 Python continue 语句Python continue 语句跳出本次循环，而break跳出整个循环。 continue 语句用来告诉Python跳过当前循环的剩余语句，然后继续进行下一轮循环。 continue语句用在while和for循环中。 Python pass 语句Python pass 是空语句，是为了保持程序结构的完整性。 pass 不做任何事情，一般用做占位语句。","categories":[{"name":"python","slug":"python","permalink":"http://xdd7130.github.io/categories/python/"}],"tags":[{"name":"python基础","slug":"python基础","permalink":"http://xdd7130.github.io/tags/python基础/"}]},{"title":"python基础（一）","slug":"python基础1","date":"2019-08-07T02:27:58.000Z","updated":"2022-11-02T11:15:20.642Z","comments":true,"path":"2019/08/07/python基础1/","link":"","permalink":"http://xdd7130.github.io/2019/08/07/python基础1/","excerpt":"","text":"Python 中文编码Python中默认的编码格式是 ASCII 格式，在没修改编码格式时无法正确打印汉字，所以在读取中文时会报错。 解决方法为只要在文件开头加入 # -- coding: UTF-8 -- 或者 # coding=utf-8 就行了 Python 基础语法Python 标识符 在 Python 里，标识符由字母、数字、下划线组成。 在 Python 中，所有标识符可以包括英文、数字以及下划线(_)，但不能以数字开头。 Python 中的标识符是区分大小写的。 以下划线开头的标识符是有特殊意义的。以单下划线开头 _foo 的代表不能直接访问的类属性，需通过类提供的接口进行访问，不能用 from xxx import * 而导入。 以双下划线开头的 foo 代表类的私有成员，以双下划线开头和结尾的 foo__ 代表 Python 里特殊方法专用的标识，如 init() 代表类的构造函数。 Python 可以同一行显示多条语句，方法是用分号 ; 分开，如： 123&gt;&gt;&gt; print &apos;hello&apos;;print &apos;runoob&apos;;hellorunoob Python 保留字符 1 2 3 and exec not assert finally or break for pass class from print continue global raise def if return del import try elif in while else is with except lambda yield 行和缩进Python 与其他语言最大的区别就是，Python的代码块不使用大括号{}来控制类，函数以及其他逻辑判断。python 最具特色的就是用缩进来写模块。 缩进的空白数量是可变的，但是所有代码块语句必须包含相同的缩进空白数量，这个必须严格执行。如下所示：1234567891011#!/usr/bin/python# -*- coding: UTF-8 -*-# 文件名：test.pyif True: print &quot;Answer&quot; print &quot;True&quot;else: print &quot;Answer&quot; # 没有严格缩进，在执行时会报错 print &quot;False&quot; 执行以上代码，会出现如下错误提醒：12345$ python test.py File &quot;test.py&quot;, line 10 print &quot;False&quot; ^IndentationError: unindent does not match any outer indentation level IndentationError: unindent does not match any outer indentation level错误表明，你使用的缩进方式不一致，有的是 tab 键缩进，有的是空格缩进，改为一致即可。 如果是 IndentationError: unexpected indent 错误, 则 python 编译器是在告诉你”Hi，老兄，你的文件里格式不对了，可能是tab和空格没对齐的问题”，所有 python 对格式要求非常严格。 因此，在 Python 的代码块中必须使用相同数目的行首缩进空格数。 建议你在每个缩进层次使用 单个制表符 或 两个空格 或 四个空格 , 切记不能混用 多行语句Python语句中一般以新行作为语句的结束符。 但是我们可以使用斜杠（ \\）将一行的语句分为多行显示，如下所示：123total = item_one + \\ item_two + \\ item_three 语句中包含 [], {} 或 () 括号就不需要使用多行连接符。如下实例：12days = [&apos;Monday&apos;, &apos;Tuesday&apos;, &apos;Wednesday&apos;, &apos;Thursday&apos;, &apos;Friday&apos;] Python 引号Python 可以使用引号( ‘ )、双引号( “ )、三引号( ‘’’ 或 “”” ) 来表示字符串，引号的开始与结束必须的相同类型的。 其中三引号可以由多行组成，编写多行文本的快捷语法，常用于文档字符串，在文件的特定地点，被当做注释。 Python注释python中单行注释采用 # 开头。12345# -*- coding: UTF-8 -*-# 文件名：test.py# 第一个注释print &quot;Hello, Python!&quot; # 第二个注释 python 中多行注释使用三个单引号(‘’’)或三个双引号(“””)。12345678910111213141516#!/usr/bin/python# -*- coding: UTF-8 -*-# 文件名：test.py&apos;&apos;&apos;这是多行注释，使用单引号。这是多行注释，使用单引号。这是多行注释，使用单引号。&apos;&apos;&apos;&quot;&quot;&quot;这是多行注释，使用双引号。这是多行注释，使用双引号。这是多行注释，使用双引号。&quot;&quot;&quot; ####Python空行函数之间或类的方法之间用空行分隔，表示一段新的代码的开始。类和函数入口之间也用一行空行分隔，以突出函数入口的开始。 空行与代码缩进不同，空行并不是Python语法的一部分。书写时不插入空行，Python解释器运行也不会出错。但是空行的作用在于分隔两段不同功能或含义的代码，便于日后代码的维护或重构。 记住：空行也是程序代码的一部分 等待用户输入1234#!/usr/bin/python# -*- coding: UTF-8 -*-# \\n 实现换行。一旦用户按下 enter(回车) 键退出，其它键显示。input(&quot;按下 enter 键退出，其他任意键显示...\\n&quot;) # python2 raw_input() 同一行显示多条语句Python可以在同一行中使用多条语句，语句之间使用分号(;)分割，以下是一个简单的实例：12#!/usr/bin/pythonimport sys; x = &apos;runoob&apos;; sys.stdout.write(x + &apos;\\n&apos;) Print 输出print 默认输出是换行的，如果要实现不换行需要在变量末尾加上逗号 ,12345678910111213141516#!/usr/bin/python# -*- coding: UTF-8 -*-x=&quot;a&quot;y=&quot;b&quot;# 换行输出print xprint yprint &apos;---------&apos;# 不换行输出print x,print y,# 不换行输出print x,y 以上实例执行结果为：1234ab---------a b a b 多个语句构成代码组缩进相同的一组语句构成一个代码块，我们称之代码组。 像if、while、def和class这样的复合语句，首行以关键字开始，以冒号( : )结束，该行之后的一行或多行代码构成代码组。 我们将首行及后面的代码组称为一个子句(clause)。123456if expression : suite elif expression : suite else : suite 变量类型变量存储在内存中的值。这就意味着在创建变量时会在内存中开辟一个空间。 基于变量的数据类型，解释器会分配指定内存，并决定什么数据可以被存储在内存中。 因此，变量可以指定不同的数据类型，这些变量可以存储整数，小数或字符。 变量赋值 Python 中的变量赋值不需要类型声明。 每个变量在内存中创建，都包括变量的标识，名称和数据这些信息。 每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。 等号（=）用来给变量赋值。 等号（=）运算符左边是一个变量名,等号（=）运算符右边是存储在变量中的值。 1234567counter = 100 # 赋值整型变量miles = 1000.0 # 浮点型name = &quot;John&quot; # 字符串 print counterprint milesprint name 多个变量赋值Python允许你同时为多个变量赋值。例如：a = b = c = 1以上实例，创建一个整型对象，值为1，三个变量被分配到相同的内存空间上。您也可以为多个对象指定多个变量。例如：a, b, c = 1, 2, “john”以上实例，两个整型对象 1 和 2 分别分配给变量 a 和 b，字符串对象 “john” 分配给变量 c。 标准数据类型在内存中存储的数据可以有多种类型。例如，一个人的年龄可以用数字来存储，他的名字可以用字符来存储。Python 定义了一些标准类型，用于存储各种类型的数据。Python有五个标准的数据类型： Numbers（数字） String（字符串） List（列表） Tuple（元组） Dictionary（字典） Python数字数字数据类型用于存储数值。 他们是不可改变的数据类型，这意味着改变数字数据类型会分配一个新的对象。 当你指定一个值时，Number对象就会被创建： var1 = 1var2 = 10您也可以使用del语句删除一些对象的引用。del语句的语法是：del var1[,var2[,var3[….,varN]]]]您可以通过使用del语句删除单个或多个对象的引用。例如：del vardel var_a, var_bPython支持四种不同的数字类型： int（有符号整型）long（长整型[也可以代表八进制和十六进制]）float（浮点型）complex（复数） Python字符串字符串或串(String)是由数字、字母、下划线组成的一串字符。一般记为 :s=”a1a2···an”(n&gt;=0)python的字串列表有2种取值顺序: 从左到右索引默认0开始的，最大范围是字符串长度少1 从右到左索引默认-1开始的，最大范围是字符串开头 如果你要实现从字符串中获取一段子字符串的话，可以使用 [头下标:尾下标] 来截取相应的字符串，其中下标是从 0 开始算起，可以是正数或负数，下标可以为空表示取到头或尾。[头下标:尾下标] 获取的子字符串包含头下标的字符，但不包含尾下标的字符。比如:123s = &apos;abcdef&apos;s[1:5]&apos;bcde&apos; 当使用以冒号分隔的字符串，python 返回一个新的对象，结果包含了以这对偏移标识的连续的内容，左边的开始是包含了下边界。上面的结果包含了 s[1] 的值 b，而取到的最大范围不包括尾下标，就是 s[5] 的值 f。123456789#!/usr/bin/python# -*- coding: UTF-8 -*-str = &apos;Hello World!&apos;print str # 输出完整字符串print str[0] # 输出字符串中的第一个字符print str[2:5] # 输出字符串中第三个至第六个之间的字符串print str[2:] # 输出从第三个字符开始的字符串print str * 2 # 输出字符串两次print str + &quot;TEST&quot; # 输出连接的字符串 以上实例输出结果：123456Hello World!Hllollo World!Hello World!Hello World!Hello World!TEST Python 列表截取可以接收第三个参数，参数作用是截取的步长，以下实例在索引 1 到索引 4 的位置并设置为步长为 2（间隔一个位置）来截取字符串： Python列表List（列表） 是 Python 中使用最频繁的数据类型。列表可以完成大多数集合类的数据结构实现。它支持字符，数字，字符串甚至可以包含列表（即嵌套）。列表用 [ ] 标识，是 python 最通用的复合数据类型。列表中值的切割也可以用到变量 [头下标:尾下标] ，就可以截取相应的列表，从左到右索引默认 0 开始，从右到左索引默认 -1 开始，下标可以为空表示取到头或尾。1234567891011#!/usr/bin/python# -*- coding: UTF-8 -*- list = [ &apos;runoob&apos;, 786 , 2.23, &apos;john&apos;, 70.2 ]tinylist = [123, &apos;john&apos;]print list # 输出完整列表print list[0] # 输出列表的第一个元素print list[1:3] # 输出第二个至第三个元素 print list[2:] # 输出从第三个开始至列表末尾的所有元素print tinylist * 2 # 输出列表两次print list + tinylist # 打印组合的列表 以上实例输出结果：123456[&apos;runoob&apos;, 786, 2.23, &apos;john&apos;, 70.2]runoob[786, 2.23][2.23, &apos;john&apos;, 70.2][123, &apos;john&apos;, 123, &apos;john&apos;][&apos;runoob&apos;, 786, 2.23, &apos;john&apos;, 70.2, 123, &apos;john&apos;] Python 元组元组是另一个数据类型，类似于 List（列表）。元组用 () 标识。内部元素用逗号隔开。但是元组不能二次赋值，相当于只读列表。123456789101112#!/usr/bin/python# -*- coding: UTF-8 -*- tuple = ( &apos;runoob&apos;, 786 , 2.23, &apos;john&apos;, 70.2 )tinytuple = (123, &apos;john&apos;) print tuple # 输出完整元组print tuple[0] # 输出元组的第一个元素print tuple[1:3] # 输出第二个至第四个（不包含）的元素 print tuple[2:] # 输出从第三个开始至列表末尾的所有元素print tinytuple * 2 # 输出元组两次print tuple + tinytuple # 打印组合的元组 以上实例输出结果：123456(&apos;runoob&apos;, 786, 2.23, &apos;john&apos;, 70.2)runoob(786, 2.23)(2.23, &apos;john&apos;, 70.2)(123, &apos;john&apos;, 123, &apos;john&apos;)(&apos;runoob&apos;, 786, 2.23, &apos;john&apos;, 70.2, 123, &apos;john&apos;) 以下是元组无效的，因为元组是不允许更新的。而列表是允许更新的：1234567#!/usr/bin/python# -*- coding: UTF-8 -*- tuple = ( &apos;runoob&apos;, 786 , 2.23, &apos;john&apos;, 70.2 )list = [ &apos;runoob&apos;, 786 , 2.23, &apos;john&apos;, 70.2 ]tuple[2] = 1000 # 元组中是非法应用list[2] = 1000 # 列表中是合法应用 Python 字典字典(dictionary)是除列表以外python之中最灵活的内置数据结构类型。列表是有序的对象集合，字典是无序的对象集合。两者之间的区别在于：字典当中的元素是通过键来存取的，而不是通过偏移存取。字典用”{ }”标识。字典由索引(key)和它对应的值value组成。123456789101112#!/usr/bin/python# -*- coding: UTF-8 -*- dict = &#123;&#125;dict[&apos;one&apos;] = &quot;This is one&quot;dict[2] = &quot;This is two&quot;tinydict = &#123;&apos;name&apos;: &apos;john&apos;,&apos;code&apos;:6734, &apos;dept&apos;: &apos;sales&apos;&#125;print dict[&apos;one&apos;] # 输出键为&apos;one&apos; 的值print dict[2] # 输出键为 2 的值print tinydict # 输出完整的字典print tinydict.keys() # 输出所有键print tinydict.values() # 输出所有值 输出结果为：12345This is oneThis is two&#123;&apos;dept&apos;: &apos;sales&apos;, &apos;code&apos;: 6734, &apos;name&apos;: &apos;john&apos;&#125;[&apos;dept&apos;, &apos;code&apos;, &apos;name&apos;][&apos;sales&apos;, 6734, &apos;john&apos;] Python数据类型转换 函数 描述 int(x [,base]) 将x转换为一个整数 long(x [,base] ) 将x转换为一个长整数 float(x) 将x转换到一个浮点数 complex(real [,imag]) 创建一个复数 str(x) 将对象 x 转换为字符串 repr(x) 将对象 x 转换为表达式字符串 eval(str) 用来计算在字符串中的有效Python表达式,并返回一个对象 tuple(s) 将序列 s 转换为一个元组 list(s) 将序列 s 转换为一个列表 set(s) 转换为可变集合 dict(d) 创建一个字典。d 必须是一个序列 (key,value)元组。 frozenset(s) 转换为不可变集合 chr(x) 将一个整数转换为一个字符 unichr(x) 将一个整数转换为Unicode字符 ord(x) 将一个字符转换为它的整数值 hex(x) 将一个整数转换为一个十六进制字符串 oct(x) 将一个整数转换为一个八进制字符串 Python 运算符 算术运算符 比较（关系）运算符 赋值运算符 逻辑运算符 位运算符 成员运算符 身份运算符 运算符优先级 Python算术运算符 运算符 描述 实例 + 加 - 两个对象相加 a + b 输出结果 30 - 减 - 得到负数或是一个数减去另一个数 a - b 输出结果 -10 * 乘 - 两个数相乘或是返回一个被重复若干次的字符串 a * b 输出结果 200 / 除 - x除以y b / a 输出结果 2 % 取模 - 返回除法的余数 b % a 输出结果 0 ** 幂 - 返回x的y次幂 a**b 为10的20次方， 输出结果 100000000000000000000 // 取整除 - 返回商的整数部分（向下取整） 9//2 结果：4 Python比较运算符 Python赋值运算符 Python位运算符 Python逻辑运算符 Python成员运算符 Python身份运算符 Python运算符优先级","categories":[{"name":"python","slug":"python","permalink":"http://xdd7130.github.io/categories/python/"}],"tags":[{"name":"python基础","slug":"python基础","permalink":"http://xdd7130.github.io/tags/python基础/"}]},{"title":"ArcGIS API For Javascript之影像服务分析","slug":"ArcGIS-API-for-JS25","date":"2019-08-06T10:08:42.000Z","updated":"2022-11-02T11:15:20.536Z","comments":true,"path":"2019/08/06/ArcGIS-API-for-JS25/","link":"","permalink":"http://xdd7130.github.io/2019/08/06/ArcGIS-API-for-JS25/","excerpt":"","text":"在前面我们大多数的程序是对矢量数据的操作，在这篇博客中，主要介绍影响服务的操作。在影像服务的操作中主要用到的类有： esri/tasks/ImageServiceIdentifyTask用于对影像数据的查询，它主要对应的参数为esri/tasks/ImageServiceIdentifyParameters,查询返回的结果用esri/tasks/ImageServiceIdentifyResult接受 对影像数据的测量主要用到的类为esri/tasks/ImageServiceMeasureTask,它所对应的的参数为esri/tasks/ImageServiceMeasureParameters ArcGIS API影像测量代码实现首先加载地图123456require([&quot;esri/map&quot;,&quot;esri/layers/ArcGISImageServiceLayer&quot;,&quot;dojo/domReady!&quot;],function(Map,ArcGISImageServiceLayer)&#123; var map=new Map(&quot;mapDiv&quot;) //注意这里是影响服务 var layer=new ArcGISImageServiceLayer(&quot;http://localhost:6080/arcgis/rest/services/Test/Dem/ImageServer&quot;) map.addLayer(layer); &#125;); 添加两个按钮，一个用于绘制折线，一个用于测量分析12&lt;button id=&quot;drawp&quot;&gt;绘制点&lt;/button&gt;&lt;button id=&quot;btn&quot;&gt;查询&lt;/button&gt; 创建必要对象12345678910//用于绘制点 var toolbar =new Draw(map); //创建影像分析对象 var task=new ImageServiceIdentifyTask(&quot;http://192.168.0.112:6080/arcgis/rest/services/Test/Dem1/ImageServer&quot;); //创建影像分析参数对象 var params=new ImageServiceIdentifyParameters(); var lineSymbol = new SimpleLineSymbol(SimpleLineSymbol.STYLE_DASH, new dojo.Color([255, 0, 0]), 3); var marker= new SimpleMarkerSymbol(SimpleMarkerSymbol.STYLE_CIRCLE,10, lineSymbol, new dojo.Color([255, 0, 0])); var fill= new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, lineSymbol, new dojo.Color([255, 0, 0])); 给绘制折现按钮添加绑定事件1234567891011121314//给绘制点按钮绑定事件 on(dom.byId(&quot;drawp&quot;),&quot;click&quot;,function()&#123; toolbar.activate(Draw.POLYLINE, &#123; showTooltips:true &#125;) &#125;) //给draw工具的绘制完成事件绑定函数 on(toolbar,&quot;draw-complete&quot;, function (result) &#123; var geometry=result.geometry; //给参数对象的几何属性赋值 params.geometry=geometry; toolbar.deactivate(); &#125;) 给分析按钮绑定事件12345678910111213on(dom.byId(&quot;btn&quot;),&quot;click&quot;,function()&#123; //设置掩膜规则 var mosaicRule=new MosaicRule(); mosaicRule.ascending=false; mosaicRule.method=MosaicRule.METHOD_CENTER params.mosaicRule=mosaicRule params.pixelSizeX=layer.pixelSizeX; params.pixelSizeY=layer.pixelSizeY; task.execute(params,function(result)&#123; //弹出改点的高程值 alert(result.value) &#125;) &#125;) 代码结果 全部代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;index.html&lt;/title&gt; &lt;meta http-equiv=&quot;keywords&quot; content=&quot;keyword1,keyword2,keyword3&quot;&gt; &lt;meta http-equiv=&quot;description&quot; content=&quot;this is my page&quot;&gt; &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html; charset=utf-8&quot;&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;http://localhost/arcgis_js_api/library/3.17/3.17/dijit/themes/tundra/tundra.css&quot;/&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;http://localhost/arcgis_js_api/library/3.17/3.17/esri/css/esri.css&quot; /&gt; &lt;script type=&quot;text/Javascript&quot; src=&quot;http://localhost/arcgis_js_api/library/3.17/3.17/init.js&quot;&gt;&lt;/script&gt; &lt;!--&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;./styles.css&quot;&gt;--&gt; &lt;style&gt; .MapClass&#123; width:100%; height:500px; border:1px solid #000; &#125; &lt;/style&gt; &lt;script&gt; require([&quot;esri/map&quot;,&quot;esri/layers/ArcGISImageServiceLayer&quot;,&quot;dojo/on&quot;, &quot;dojo/dom&quot;,&quot;esri/toolbars/draw&quot;, &quot;esri/tasks/ImageServiceIdentifyTask&quot;,&quot;esri/tasks/ImageServiceIdentifyParameters&quot;, &quot;esri/symbols/SimpleLineSymbol&quot;,&quot;esri/graphic&quot;,&quot;esri/symbols/SimpleMarkerSymbol&quot;, &quot;esri/symbols/SimpleFillSymbol&quot;, &quot;esri/layers/MosaicRule&quot;, &quot;dojo/domReady!&quot;],function(Map,ArcGISImageServiceLayer,on,dom,Draw,ImageServiceIdentifyTask, ImageServiceIdentifyParameters,SimpleLineSymbol, Graphic,SimpleMarkerSymbol,SimpleFillSymbol,MosaicRule)&#123; var map=new Map(&quot;mapDiv&quot;) //注意这里是影响服务 var layer=new ArcGISImageServiceLayer(&quot;http://192.168.0.112:6080/arcgis/rest/services/Test/Dem1/ImageServer&quot;) map.addLayer(layer); //用于绘制点 var toolbar =new Draw(map); //创建影像分析对象 var task=new ImageServiceIdentifyTask(&quot;http://192.168.0.112:6080/arcgis/rest/services/Test/Dem1/ImageServer&quot;); //创建影像分析参数对象 var params=new ImageServiceIdentifyParameters(); var lineSymbol = new SimpleLineSymbol(SimpleLineSymbol.STYLE_DASH, new dojo.Color([255, 0, 0]), 3); var marker= new SimpleMarkerSymbol(SimpleMarkerSymbol.STYLE_CIRCLE,10, lineSymbol, new dojo.Color([255, 0, 0])); var fill= new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, lineSymbol, new dojo.Color([255, 0, 0])); //给绘制折线按钮绑定事件 on(dom.byId(&quot;drawp&quot;),&quot;click&quot;,function()&#123; toolbar.activate(Draw.POINT, &#123; showTooltips:true &#125;) &#125;) //给draw工具的绘制完成事件绑定函数 on(toolbar,&quot;draw-complete&quot;, function (result) &#123; map.graphics.clear(); var geometry=result.geometry; //给参数对象的几何属性赋值 params.geometry =geometry; graphic= new Graphic(geometry, marker); map.graphics.add(graphic); toolbar.deactivate(); &#125;) on(dom.byId(&quot;btn&quot;),&quot;click&quot;,function()&#123; //设置掩膜规则 var mosaicRule=new MosaicRule(); mosaicRule.ascending=false; mosaicRule.method=MosaicRule.METHOD_CENTER params.mosaicRule=mosaicRule params.pixelSizeX=layer.pixelSizeX; params.pixelSizeY=layer.pixelSizeY; task.execute(params,function(result)&#123; //弹出改点的高程值 alert(result.value) &#125;) &#125;) &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;mapDiv&quot; class=&quot;MapClass&quot;&gt;&lt;/div&gt; &lt;button id=&quot;drawp&quot;&gt;绘制点&lt;/button&gt; &lt;button id=&quot;btn&quot;&gt;查询&lt;/button&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"ArcGIS","slug":"ArcGIS","permalink":"http://xdd7130.github.io/categories/ArcGIS/"}],"tags":[{"name":"ArcGIS API for JS","slug":"ArcGIS-API-for-JS","permalink":"http://xdd7130.github.io/tags/ArcGIS-API-for-JS/"},{"name":"webgis","slug":"webgis","permalink":"http://xdd7130.github.io/tags/webgis/"}]},{"title":"ArcGIS API For Javascript之调用地理编码服务","slug":"ArcGIS-API-for-JS24","date":"2019-08-06T10:03:13.000Z","updated":"2022-11-02T11:15:20.530Z","comments":true,"path":"2019/08/06/ArcGIS-API-for-JS24/","link":"","permalink":"http://xdd7130.github.io/2019/08/06/ArcGIS-API-for-JS24/","excerpt":"","text":"地理编码（Geocoding）指建立地理位置坐标与给定地址一致性的过程，简单的说就是将一个地址的描述信息映射为地图上该地址所对应的空间位置。 根据输入的地址找到对应的空间信息。当输入一个地址的时候，可能会查到好多个空间位置，程序会给每一个位置一个打分，匹配的越完全的比分越高。（注意这里说的） 调用地理编码服务查看我们发布的服务首先看一下发布的服务数据我发布的地理编码服务是：name为主键 注意应该输入的参数 代码实现添加地图（略）创建三个html要素123Name:&lt;input class=&quot;nm&quot; type=&quot;text&quot;&gt;&lt;input id=&quot;btn&quot; type=&quot;button&quot; value=&quot;定位&quot;&gt;&lt;div id=&quot;divShowResult&quot;&gt;&lt;/div&gt; 给定位按钮添加绑定事件12345678910111213141516171819//执行方法 locator.addressToLocations(options,function(candidates)&#123; //获得运行之后的信息 if (candidates.length &gt; 0)&#123; //拼接字符串 var htmls = &quot;&lt;table style=&apos;width: 100%&apos;&gt;&quot;; htmls = htmls + &quot;&lt;tr bgcolor=&apos;#E0E0E0&apos;&gt;&lt;td&gt;X 坐标&lt;/td&gt;&lt;td&gt;Y 坐标&lt;/td&gt;&lt;td&gt;得分&lt;/td&gt;&lt;/tr&gt;&quot;; array.forEach(candidates, function (candidate, index) &#123; if (index % 2 == 1) &#123; htmls = htmls + &quot;&lt;tr bgcolor=&apos;#E0E0E0&apos;&gt;&lt;td style=&apos;width: 60px&apos;&gt;&quot; + candidate.location.x + &quot;&lt;/td&gt;&lt;td style=&apos;width: 60px&apos;&gt;&quot; + candidate.location.y+ &quot;&lt;/td&gt;&lt;td&gt;&quot; + candidate.score + &quot;&lt;/td&gt;&lt;/tr&gt;&quot;; &#125; else &#123; htmls = htmls + &quot;&lt;tr&gt;&lt;td style=&apos;width: 60px&apos;&gt;&quot; + candidate.location.x + &quot;&lt;/td&gt;&lt;td style=&apos;width: 60px&apos;&gt;&quot; + candidate.location.y+ &quot;&lt;/td&gt;&lt;td&gt;&quot; + candidate.score + &quot;&lt;/td&gt;&lt;/tr&gt;&quot;; &#125; &#125;); htmls = htmls + &quot;&lt;/table&gt;&quot;; //将拼接的字符串显示在页面上 dom.byId(&quot;divShowResult&quot;).innerHTML = htmls; &#125; &#125;,function(error)&#123;alert(error)&#125;); 运行结果 全部代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;gbk&quot;&gt; &lt;title&gt;Hello World&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;http://localhost/arcgis_js_api/library/3.17/3.17/dijit/themes/tundra/tundra.css&quot;/&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;http://localhost/arcgis_js_api/library/3.17/3.17/esri/css/esri.css&quot; /&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;http://localhost/arcgis_js_api/library/3.17/3.17/init.js&quot;&gt;&lt;/script&gt; &lt;script&gt; require([&quot;esri/map&quot;,&quot;dojo/query&quot;,&quot;dojo/on&quot;,&quot;dojo/_base/array&quot;,&quot;dojo/dom&quot;, &quot;esri/layers/ArcGISDynamicMapServiceLayer&quot;, &quot;esri/tasks/locator&quot;, &quot;esri/symbols/SimpleMarkerSymbol&quot;, &quot;dojo/colors&quot;, &quot;esri/InfoTemplate&quot;,&quot;esri/graphic&quot;, &quot;dojo/domReady!&quot;], function(Map,query,on,array,dom,ArcGISDynamicMapServiceLayer,Locator,SimpleMarkerSymbol,Color,InfoTemplate,Graphic)&#123; var map = new Map(&quot;mapDiv&quot;); var layer=new ArcGISDynamicMapServiceLayer(&quot;http://localhost:6080/arcgis/rest/services/Test/MyService/MapServer&quot;); map.addLayer(layer); query(&quot;#btn&quot;).on(&quot;click&quot;,function()&#123; //获得教学楼的名称 var name=query(&quot;.nm&quot;)[0].value; //创建地理编码对象 var locator = new Locator(&quot;http://localhost:6080/arcgis/rest/services/Test/nameLoc/GeocodeServer&quot;); //注意这里的参数要和服务的参数对应 var address = &#123; &quot;Single Line Input&quot;: name&#125;; //输出的空间参考 locator.outSpatialReference = map.spatialReference; var options = &#123; address: address, outFields: [&quot;*&quot;] &#125; //执行方法 locator.addressToLocations(options,function(candidates)&#123; //获得运行之后的信息 if (candidates.length &gt; 0)&#123; //拼接字符串 var htmls = &quot;&lt;table style=&apos;width: 100%&apos;&gt;&quot;; htmls = htmls + &quot;&lt;tr bgcolor=&apos;#E0E0E0&apos;&gt;&lt;td&gt;X 坐标&lt;/td&gt;&lt;td&gt;Y 坐标&lt;/td&gt;&lt;td&gt;得分&lt;/td&gt;&lt;/tr&gt;&quot;; array.forEach(candidates, function (candidate, index) &#123; if (index % 2 == 1) &#123; htmls = htmls + &quot;&lt;tr bgcolor=&apos;#E0E0E0&apos;&gt;&lt;td style=&apos;width: 60px&apos;&gt;&quot; + candidate.location.x + &quot;&lt;/td&gt;&lt;td style=&apos;width: 60px&apos;&gt;&quot; + candidate.location.y+ &quot;&lt;/td&gt;&lt;td&gt;&quot; + candidate.score + &quot;&lt;/td&gt;&lt;/tr&gt;&quot;; &#125; else &#123; htmls = htmls + &quot;&lt;tr&gt;&lt;td style=&apos;width: 60px&apos;&gt;&quot; + candidate.location.x + &quot;&lt;/td&gt;&lt;td style=&apos;width: 60px&apos;&gt;&quot; + candidate.location.y+ &quot;&lt;/td&gt;&lt;td&gt;&quot; + candidate.score + &quot;&lt;/td&gt;&lt;/tr&gt;&quot;; &#125; &#125;); htmls = htmls + &quot;&lt;/table&gt;&quot;; //将拼接的字符串显示在页面上 dom.byId(&quot;divShowResult&quot;).innerHTML = htmls; &#125; &#125;,function(error)&#123;alert(error)&#125;); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body class=&quot;tundra&quot;&gt;&lt;div id=&quot;mapDiv&quot; style=&quot;width:900px; height:580px; border:1px solid #000;&quot;&gt;&lt;/div&gt; Name:&lt;input class=&quot;nm&quot; type=&quot;text&quot;&gt; &lt;input id=&quot;btn&quot; type=&quot;button&quot; value=&quot;定位&quot;&gt; &lt;div id=&quot;divShowResult&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"ArcGIS","slug":"ArcGIS","permalink":"http://xdd7130.github.io/categories/ArcGIS/"}],"tags":[{"name":"ArcGIS API for JS","slug":"ArcGIS-API-for-JS","permalink":"http://xdd7130.github.io/tags/ArcGIS-API-for-JS/"},{"name":"webgis","slug":"webgis","permalink":"http://xdd7130.github.io/tags/webgis/"}]},{"title":"ArcGIS API For Javascript之地图输出","slug":"ArcGIS-API-for-JS23","date":"2019-08-06T09:54:17.000Z","updated":"2022-11-02T11:15:20.526Z","comments":true,"path":"2019/08/06/ArcGIS-API-for-JS23/","link":"","permalink":"http://xdd7130.github.io/2019/08/06/ArcGIS-API-for-JS23/","excerpt":"","text":"在WebGIS中地图输出是一个比较常用的功能，当我们制图结束时，往往要将我们的地图打印成一张图片保存起来，在ArcGIS API要想实现地图打印，需要借助PrintingTools工具，此工具实质上是一个GP工具，因为是GP工具，所以地图的生成是在服务器端生成的，也可以叫做服务器端打印.服务器端打印的执行对象是 PrintTask，打印的参数是 PrintParameters，通过设置打印模板对象PrintTemplate，可以对图片的大小，像素，格式等进行设置 启用PrintingTools 工具PrintingTools 和几何服务一样，默认情况下是关闭的，我们应当开启此工具默认情况下关闭启动成功要使用的URL1http://localhost:6080/arcgis/rest/services/Utilities/PrintingTools/GPServer/Export%20Web%20Map%20Task 使用PrintingTools 打印地图代码实现加载地图（略）添加两个按钮（一个按钮用于画polygon，一个按钮用于地图打印）12&lt;button class=&quot;pbtn&quot; &gt;画多边形&lt;/button&gt;&lt;input id=&quot;Btn&quot; type=&quot;button&quot; value=&quot;地图打印&quot; /&gt; 创建相关对象（例如：绘图对象，符号对象）123456//创建绘图对象var toolBar = new Draw(map); //线符号lineSymbol = new SimpleLineSymbol(SimpleLineSymbol.STYLE_DASH, new Color([255, 0, 0]), 3);//面符号polygonSymbol = new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, lineSymbol, new Color([255, 0, 0, 0.25])); 给绘制多边形按钮绑定事件123456789101112131415161718//给绘制polygon的按钮绑定事件query(&quot;.pbtn&quot;).on(&quot;click&quot;,function(event)&#123; //激活绘制多边形 toolBar.activate(Draw.POLYGON, &#123; showTooltips:true &#125;) &#125;)//绘图结束绑定事件on(toolBar,&quot;draw-end&quot;,function(result)&#123; //获得面形状 var geometry=result.geometry; //创建Graphic var graphicpoint= new Graphic(geometry, polygonSymbol); map.graphics.add(graphicpoint); //关闭绘图工具 toolBar.deactivate(); &#125;) 给地图打印按钮绑定事件1234567891011121314151617181920212223242526272829303132//给地图打印按钮绑定事件 on(dom.byId(&quot;Btn&quot;),&quot;click&quot;,function()&#123; //创建地图打印对象 var printMap = new PrintTask(&quot;http://localhost:6080/arcgis/rest/services/Utilities/PrintingTools/GPServer/Export%20Web%20Map%20Task&quot;); //创建地图打印模版 var template = new PrintTemplate(); //创建地图的打印参数，参数里面包括：模版和地图 var params = new PrintParameters(); //输出图片的空间参考 printMap.outSpatialReference = map.SpatialReference //打印图片的各种参数 template.exportOptions = &#123; width: 850, height: 650, dpi: 96 &#125;; //打印输出的格式 template.format = &quot;PDF&quot;; //输出地图的布局 template.layout = &quot;MAP_ONLY&quot;; PrintTemplate //设置参数地图 params.map = map; //设置参数模版 params.template = template; //运行结果 printMap.execute(params, function(result)&#123; if (result != null) &#123; //网页打开生成的地图 window.open(result.url); &#125; &#125;) 运行结果 全部代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111&lt;!DOCTYPE html&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;/&gt; &lt;title&gt;地图打印&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;http://localhost/arcgis_js_api/library/3.17/3.17/dijit/themes/tundra/tundra.css&quot;/&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;http://localhost/arcgis_js_api/library/3.17/3.17/esri/css/esri.css&quot; /&gt; &lt;script type=&quot;text/Javascript&quot; src=&quot;http://localhost/arcgis_js_api/library/3.17/3.17/init.js&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; .MapClass&#123; width:100%; height:500px; border:1px solid #000; &#125; &lt;/style&gt; &lt;script type=&quot;text/javascript&quot;&gt; require([&quot;esri/map&quot;, &quot;dojo/dom&quot;,&quot;dojo/on&quot;,&quot;dojo/query&quot;, &quot;esri/layers/ArcGISDynamicMapServiceLayer&quot;, &quot;esri/symbols/SimpleMarkerSymbol&quot;, &quot;esri/symbols/SimpleLineSymbol&quot;, &quot;esri/symbols/SimpleFillSymbol&quot;, &quot;esri/toolbars/draw&quot;, &quot;esri/graphic&quot;, &quot;esri/tasks/PrintTask&quot;, &quot;esri/tasks/PrintTemplate&quot;, &quot;esri/tasks/PrintParameters&quot;, &quot;dojo/colors&quot;, &quot;dojo/domReady!&quot;], function (Map,dom,on,query, ArcGISDynamicMapServiceLayer, SimpleMarkerSymbol, SimpleLineSymbol, SimpleFillSymbol, Draw, Graphic, PrintTask,PrintTemplate,PrintParameters, Color) &#123; var map = new esri.Map(&quot;mapDiv&quot;); var layer = new esri.layers.ArcGISDynamicMapServiceLayer (&quot;http://localhost:6080/arcgis/rest/services/Test/ft/MapServer&quot;); map.addLayer(layer); //创建绘图对象 var toolBar = new Draw(map); //线符号 lineSymbol = new SimpleLineSymbol(SimpleLineSymbol.STYLE_DASH, new Color([255, 0, 0]), 3); //面符号 polygonSymbol = new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, lineSymbol, new Color([255, 0, 0, 0.25])); //给绘制polygon的按钮绑定事件 query(&quot;.pbtn&quot;).on(&quot;click&quot;,function(event)&#123; //激活绘制多边形 toolBar.activate(Draw.POLYGON, &#123; showTooltips:true &#125;) &#125;) //绘图结束绑定事件 on(toolBar,&quot;draw-end&quot;,function(result)&#123; //获得面形状 var geometry=result.geometry; //创建Graphic var graphicpoint= new Graphic(geometry, polygonSymbol); map.graphics.add(graphicpoint); //关闭绘图工具 toolBar.deactivate(); &#125;) //给地图打印按钮绑定事件 on(dom.byId(&quot;Btn&quot;),&quot;click&quot;,function()&#123; //创建地图打印对象 var printMap = new PrintTask(&quot;http://localhost:6080/arcgis/rest/services/Utilities/PrintingTools/GPServer/Export%20Web%20Map%20Task&quot;); //创建地图打印模版 var template = new PrintTemplate(); //创建地图的打印参数，参数里面包括：模版和地图 var params = new PrintParameters(); //输出图片的空间参考 printMap.outSpatialReference = map.SpatialReference //打印图片的各种参数 template.exportOptions = &#123; width: 850, height: 650, dpi: 96 &#125;; //打印输出的格式 template.format = &quot;PDF&quot;; //输出地图的布局 template.layout = &quot;MAP_ONLY&quot;; PrintTemplate //设置参数地图 params.map = map; //设置参数模版 params.template = template; //运行结果 printMap.execute(params, function(result)&#123; if (result != null) &#123; //网页打开生成的地图 window.open(result.url); &#125; &#125;) &#125;) &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;mapDiv&quot; class=&quot;MapClass&quot;&gt;&lt;/div&gt; &lt;button class=&quot;pbtn&quot; &gt;画多边形&lt;/button&gt; &lt;input id=&quot;Btn&quot; type=&quot;button&quot; value=&quot;地图打印&quot; /&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"ArcGIS","slug":"ArcGIS","permalink":"http://xdd7130.github.io/categories/ArcGIS/"}],"tags":[{"name":"ArcGIS API for JS","slug":"ArcGIS-API-for-JS","permalink":"http://xdd7130.github.io/tags/ArcGIS-API-for-JS/"},{"name":"webgis","slug":"webgis","permalink":"http://xdd7130.github.io/tags/webgis/"}]},{"title":"ArcGIS API For Javascript之几何服务","slug":"ArcGIS-API-for-JS22","date":"2019-08-06T09:43:13.000Z","updated":"2022-11-02T11:15:20.522Z","comments":true,"path":"2019/08/06/ArcGIS-API-for-JS22/","link":"","permalink":"http://xdd7130.github.io/2019/08/06/ArcGIS-API-for-JS22/","excerpt":"","text":"什么是几何服务（GeometryService）？从字面意义上来说是和几何（Geometry）相关的服务，具体一点讲我们可以用这个类实现一些简单的图形操作。例如： 测量直线的距离 形状的缓冲区分析 判断两个形状之间的关系（相交，相离等等） 两个形状求交 对形状的裁剪等等 在此以缓冲区分析和图形求交来介绍几何服务的使用. 启用几何服务当我们安装好ArcGIS Server的时候，几何服务就已经存在了，因此几何服务不需要我们发布，但是在默认情况下几何服务是关闭的，因此我们首先启动几何服务，步骤如下： 登录我们的ArcGIS Server Manager启动成功几何服务的URL 利用几何服务进行缓冲区分析几何服务的使用一般分为四个步骤： 创建几何服务对象 创建参数 构建参数对象 执行相应的方法，并处理返回的结果 代码实现加载地图（省略）创建两个按钮–一个按钮用于画点，另外一个按钮用于缓冲区分析12&lt;input id=&quot;point&quot; type=&quot;button&quot; value=&quot;点&quot;/&gt;&lt;input id=&quot;Btn&quot; type=&quot;button&quot; /&gt; 创建相关对象（例如符号对象，Draw对象等等）1234567891011//使用toolbar上的绘图工具 var toolBar = new Draw(map); //创建点符号 var pointSymbol = new SimpleMarkerSymbol(); pointSymbol.style = SimpleMarkerSymbol.STYLE_CIRCLE; pointSymbol.setSize(12); pointSymbol.setColor(new Color(&quot;#FFFFCC&quot;)); //线符号 lineSymbol = new SimpleLineSymbol(SimpleLineSymbol.STYLE_DASH, new Color([255, 0, 0]), 3); //面符号 polygonSymbol= new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, lineSymbol, new Color([255, 255, 0, 0.25])); 创建几何服务对象，创建相应的缓冲区参数对象12var geometryServices = new GeometryService(&quot;http://localhost:6080/arcgis/rest/services/Utilities/Geometry/GeometryServer&quot;);var params = new BufferParameters(); 给画点按钮绑定事件123456789101112131415161718192021222324//给画点按钮绑定事件 on(dom.byId(&quot;point&quot;),&quot;click&quot;,function()&#123; //激活画点工具 toolBar.activate(Draw.POINT, &#123; showTooltips:true &#125;) &#125;) //绘图结束绑定事件 on(toolBar,&quot;draw-end&quot;,function(result)&#123; //获得点形状 var geometry=result.geometry; //创建Graphic var graphicpoint = new Graphic(geometry, pointSymbol); map.graphics.add(graphicpoint); //关闭绘图工具 toolBar.deactivate(); //很重要！！！在这里构建缓冲区分析的形状属性 //注意这里可以放一个数组，此处为了方便我们只对一个形状进行缓冲区分析 params.geometries = [ geometry ]; &#125;) 给缓冲区分析按钮绑定事件12345678910111213141516171819//给缓冲区分析按钮绑定事件 on(dom.byId(&quot;Btn&quot;),&quot;click&quot;,function()&#123; //缓冲距离 params.distances = [ &quot;80&quot; ]; //空间参考 params.bufferSpatialReference = map.spatialReference; params.outSpatialReference = map.spatialReference; //执行分析处理结果 geometryServices.buffer(params,function(result)&#123; //处理缓冲区分析得到的结果 for(var idx in result) &#123; //创建Graphic var graphic=new Graphic(result[idx],polygonSymbol) //将每一个结果都放在map中 map.graphics.add(graphic) &#125; &#125;); &#125;) 运行结果 全部代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112&lt;!DOCTYPE html&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;/&gt; &lt;title&gt;缓冲区分析&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;http://localhost/arcgis_js_api/library/3.17/3.17/dijit/themes/tundra/tundra.css&quot;/&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;http://localhost/arcgis_js_api/library/3.17/3.17/esri/css/esri.css&quot; /&gt; &lt;script type=&quot;text/Javascript&quot; src=&quot;http://localhost/arcgis_js_api/library/3.17/3.17/init.js&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; .MapClass&#123; width:100%; height:500px; border:1px solid #000; &#125; &lt;/style&gt; &lt;script type=&quot;text/javascript&quot;&gt; require([&quot;esri/map&quot;, &quot;dojo/dom&quot;,&quot;dojo/on&quot;, &quot;esri/layers/ArcGISDynamicMapServiceLayer&quot;, &quot;esri/symbols/SimpleMarkerSymbol&quot;, &quot;esri/symbols/SimpleLineSymbol&quot;, &quot;esri/symbols/SimpleFillSymbol&quot;, &quot;esri/toolbars/draw&quot;, &quot;esri/graphic&quot;, &quot;esri/tasks/GeometryService&quot;, &quot;esri/tasks/BufferParameters&quot;, &quot;dojo/colors&quot;, &quot;dojo/domReady!&quot;], function (Map,dom,on, ArcGISDynamicMapServiceLayer, SimpleMarkerSymbol, SimpleLineSymbol, SimpleFillSymbol, Draw, Graphic, GeometryService, BufferParameters,Color) &#123; var map = new esri.Map(&quot;mapDiv&quot;); var layer = new esri.layers.ArcGISDynamicMapServiceLayer (&quot;http://localhost:6080/arcgis/rest/services/Test/ft/MapServer&quot;); map.addLayer(layer); //创建几何服务对象 var geometryServices = new GeometryService(&quot;http://localhost:6080/arcgis/rest/services/Utilities/Geometry/GeometryServer&quot;); //创建缓存参数对象 var params = new BufferParameters(); //使用toolbar上的绘图工具 var toolBar = new Draw(map); //创建点符号 var pointSymbol = new SimpleMarkerSymbol(); pointSymbol.style = SimpleMarkerSymbol.STYLE_CIRCLE; pointSymbol.setSize(12); pointSymbol.setColor(new Color(&quot;#FFFFCC&quot;)); //线符号 lineSymbol = new SimpleLineSymbol(SimpleLineSymbol.STYLE_DASH, new Color([255, 0, 0]), 3); //面符号 polygonSymbol = new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, lineSymbol, new Color([255, 255, 0, 0.25])); //给画点按钮绑定事件 on(dom.byId(&quot;point&quot;),&quot;click&quot;,function()&#123; //激活画点工具 toolBar.activate(Draw.POINT, &#123; showTooltips:true &#125;) &#125;) //绘图结束绑定事件 on(toolBar,&quot;draw-end&quot;,function(result)&#123; //获得点形状 var geometry=result.geometry; //创建Graphic var graphicpoint = new Graphic(geometry, pointSymbol); map.graphics.add(graphicpoint); //关闭绘图工具 toolBar.deactivate(); //很重要！！！在这里构建缓冲区分析的形状属性 //注意这里可以放一个数组，此处为了方便我们只对一个形状进行缓冲区分析 params.geometries = [ geometry ]; &#125;) //给缓冲区分析按钮绑定事件 on(dom.byId(&quot;Btn&quot;),&quot;click&quot;,function()&#123; //缓冲距离 params.distances = [ &quot;80&quot; ]; //空间参考 params.bufferSpatialReference = map.spatialReference; params.outSpatialReference = map.spatialReference; //执行分析处理结果 geometryServices.buffer(params,function(result)&#123; //处理缓冲区分析得到的结果 for(var idx in result) &#123; //创建Graphic var graphic=new Graphic(result[idx],polygonSymbol) //将每一个结果都放在map中 map.graphics.add(graphic) &#125; &#125;); &#125;) &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;mapDiv&quot; class=&quot;MapClass&quot;&gt;&lt;/div&gt; &lt;input id=&quot;point&quot; type=&quot;button&quot; value=&quot;点&quot;/&gt; &lt;input id=&quot;Btn&quot; type=&quot;button&quot; value=&quot;缓冲区分析&quot; /&gt;&lt;/body&gt;&lt;/html&gt; 利用几何服务进行多边形求交首先我们先看看求交这一个方法1GeometryService.intersect(geometries, geometry, callback?, errback?) 解释：12345此方法有四个参数，第一个参数是 形状的集合(多个形状)第二个参数是 一个形状第三个参数是 运行成功之后的结果第四个参数是 运行失败之后的结果 方法的使用：用第二个参数的形状与第一个参数的多个形状进行求交，从而返回运行的结果 代码实现加载地图（略）创建三个按钮123&lt;button class=&quot;pbtn&quot; &gt;第一个参数&lt;/button&gt;&lt;button class=&quot;pbtn&quot; &gt;第二个参数&lt;/button&gt;&lt;input id=&quot;Btn&quot; type=&quot;button&quot; value=&quot;求交分析&quot; /&gt; 创建相关对象（符号对象，绘图对象）12345678910111213141516171819//一个标志位，用于记录是绘制第几个参数 //1代表第一个参数 //2代表第二个参数 var flag; //第一个参数 注意第一个参数是多个形状 var geometries=[]; //第二个参数 注意第二个参数是一个形状 var paramGeometry; //使用toolbar上的绘图工具 var toolBar = new Draw(map); //线符号 lineSymbol = new SimpleLineSymbol(SimpleLineSymbol.STYLE_DASH, new Color([255, 0, 0]), 3); //第一个参数的面符号 polygonSymbol1 = new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, lineSymbol, new Color([255, 0, 0, 0.25])); //第二个参数的面符号 polygonSymbol2 = new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, lineSymbol, new Color([0, 255, 0, 0.25])); //求交之后的面符号 polygonSymbol3 = new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, lineSymbol, new Color([0, 0, 255, 0.25])); 给画图形的按钮绑定事件1234567891011121314151617181920212223242526272829303132333435363738394041424344//给绘制polygon的按钮绑定事件 query(&quot;.pbtn&quot;).on(&quot;click&quot;,function(event)&#123; var value=this.innerHTML; switch(value)&#123; case &quot;第一个参数&quot;:&#123; flag=1; break; &#125; case &quot;第二个参数&quot;:&#123; flag=2; break; &#125; &#125; //激活绘制多边形 toolBar.activate(Draw.POLYGON, &#123; showTooltips:true &#125;) &#125;) //绘图结束绑定事件 on(toolBar,&quot;draw-end&quot;,function(result)&#123; //获得面形状 var geometry=result.geometry; //创建Graphic var graphicpoint; //很重要！！！在这里构建参数对象 if(flag==1) &#123; //创建Graphic graphicpoint = new Graphic(geometry, polygonSymbol1); geometries.push(geometry) &#125; else if(flag==2) &#123; //创建Graphic graphicpoint = new Graphic(geometry, polygonSymbol2); paramGeometry=geometry; &#125; map.graphics.add(graphicpoint); //关闭绘图工具 toolBar.deactivate(); &#125;) 给求交按钮绑定事件12345678910111213//给求交按钮绑定事件 on(dom.byId(&quot;Btn&quot;),&quot;click&quot;,function()&#123; //在这里在说一边，第一个参数是图形集合，第二个参数是一个图形 geometryServices.intersect(geometries,paramGeometry,function(result)&#123; for(var idx in result) &#123; //创建Graphic var graphic=new Graphic(result[idx],polygonSymbol3) //将每一个结果都放在map中 map.graphics.add(graphic) &#125; &#125;) &#125;) 运行结果 全部代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130&lt;!DOCTYPE html&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;/&gt; &lt;title&gt;多边形求交&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;http://localhost/arcgis_js_api/library/3.17/3.17/dijit/themes/tundra/tundra.css&quot;/&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;http://localhost/arcgis_js_api/library/3.17/3.17/esri/css/esri.css&quot; /&gt; &lt;script type=&quot;text/Javascript&quot; src=&quot;http://localhost/arcgis_js_api/library/3.17/3.17/init.js&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; .MapClass&#123; width:100%; height:500px; border:1px solid #000; &#125; &lt;/style&gt; &lt;script type=&quot;text/javascript&quot;&gt; require([&quot;esri/map&quot;, &quot;dojo/dom&quot;,&quot;dojo/on&quot;,&quot;dojo/query&quot;, &quot;esri/layers/ArcGISDynamicMapServiceLayer&quot;, &quot;esri/symbols/SimpleMarkerSymbol&quot;, &quot;esri/symbols/SimpleLineSymbol&quot;, &quot;esri/symbols/SimpleFillSymbol&quot;, &quot;esri/toolbars/draw&quot;, &quot;esri/graphic&quot;, &quot;esri/tasks/GeometryService&quot;, &quot;dojo/colors&quot;, &quot;dojo/domReady!&quot;], function (Map,dom,on,query, ArcGISDynamicMapServiceLayer, SimpleMarkerSymbol, SimpleLineSymbol, SimpleFillSymbol, Draw, Graphic, GeometryService, Color) &#123; var map = new esri.Map(&quot;mapDiv&quot;); var layer = new esri.layers.ArcGISDynamicMapServiceLayer (&quot;http://localhost:6080/arcgis/rest/services/Test/ft/MapServer&quot;); map.addLayer(layer); //创建几何服务对象 var geometryServices = new GeometryService(&quot;http://localhost:6080/arcgis/rest/services/Utilities/Geometry/GeometryServer&quot;); //一个标志位，用于记录是绘制第几个参数 //1代表第一个参数 //2代表第二个参数 var flag; //第一个参数 注意第一个参数是多个形状 var geometries=[]; //第二个参数 注意第二个参数是一个形状 var paramGeometry; //使用toolbar上的绘图工具 var toolBar = new Draw(map); //线符号 lineSymbol = new SimpleLineSymbol(SimpleLineSymbol.STYLE_DASH, new Color([255, 0, 0]), 3); //第一个参数的面符号 polygonSymbol1 = new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, lineSymbol, new Color([255, 0, 0, 0.25])); //第二个参数的面符号 polygonSymbol2 = new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, lineSymbol, new Color([0, 255, 0, 0.25])); //求交之后的面符号 polygonSymbol3 = new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, lineSymbol, new Color([0, 0, 255, 0.25])); //给绘制polygon的按钮绑定事件 query(&quot;.pbtn&quot;).on(&quot;click&quot;,function(event)&#123; var value=this.innerHTML; switch(value)&#123; case &quot;第一个参数&quot;:&#123; flag=1; break; &#125; case &quot;第二个参数&quot;:&#123; flag=2; break; &#125; &#125; //激活绘制多边形 toolBar.activate(Draw.POLYGON, &#123; showTooltips:true &#125;) &#125;) //绘图结束绑定事件 on(toolBar,&quot;draw-end&quot;,function(result)&#123; //获得面形状 var geometry=result.geometry; //创建Graphic var graphicpoint; //很重要！！！在这里构建参数对象 if(flag==1) &#123; //创建Graphic graphicpoint = new Graphic(geometry, polygonSymbol1); geometries.push(geometry) &#125; else if(flag==2) &#123; //创建Graphic graphicpoint = new Graphic(geometry, polygonSymbol2); paramGeometry=geometry; &#125; map.graphics.add(graphicpoint); //关闭绘图工具 toolBar.deactivate(); &#125;) //给求交按钮绑定事件 on(dom.byId(&quot;Btn&quot;),&quot;click&quot;,function()&#123; //在这里在说一边，第一个参数是图形集合，第二个参数是一个图形 geometryServices.intersect(geometries,paramGeometry,function(result)&#123; for(var idx in result) &#123; //创建Graphic var graphic=new Graphic(result[idx],polygonSymbol3) //将每一个结果都放在map中 map.graphics.add(graphic) &#125; &#125;) &#125;) &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;mapDiv&quot; class=&quot;MapClass&quot;&gt;&lt;/div&gt; &lt;button class=&quot;pbtn&quot; &gt;第一个参数&lt;/button&gt; &lt;button class=&quot;pbtn&quot; &gt;第二个参数&lt;/button&gt; &lt;input id=&quot;Btn&quot; type=&quot;button&quot; value=&quot;求交分析&quot; /&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"ArcGIS","slug":"ArcGIS","permalink":"http://xdd7130.github.io/categories/ArcGIS/"}],"tags":[{"name":"ArcGIS API for JS","slug":"ArcGIS-API-for-JS","permalink":"http://xdd7130.github.io/tags/ArcGIS-API-for-JS/"},{"name":"webgis","slug":"webgis","permalink":"http://xdd7130.github.io/tags/webgis/"}]},{"title":"ArcGIS API For Javascript之网络分析","slug":"ArcGIS-API-for-JS21","date":"2019-08-06T09:27:59.000Z","updated":"2022-11-02T11:15:20.518Z","comments":true,"path":"2019/08/06/ArcGIS-API-for-JS21/","link":"","permalink":"http://xdd7130.github.io/2019/08/06/ArcGIS-API-for-JS21/","excerpt":"","text":"在WebGIS中网络分析一直是比较常用的功能，比如：路径分析，服务点分析等等,在WebGIS中想要实现相应的功能需要将我们的服务发布为网络服务。 路径分析在路径分析中，主要有两个比较关键的参数： 停靠点 障碍点 总体来说，路径分析的步骤主要有以下几步： 发布网络分析服务 在Web端创建路径分析对象 构建路径分析参数。（1）停靠点（2）障碍点 获得结果，进行处理。 #### 代码实现创建三个按钮（停靠点，障碍点，分析）123&lt;input id=&quot;Stop&quot; type=&quot;button&quot; value=&quot;停靠点&quot; /&gt;&lt;input id=&quot;barriers&quot; type=&quot;button&quot; value=&quot;障碍点&quot; /&gt;&lt;input id=&quot;Analyse&quot; type=&quot;button&quot; value=&quot;分析&quot; /&gt; 添加地图（步骤省略）创建路径分析对象，创建路径分析参数对象（注意：还缺少两个重要的参数，停靠点，障碍点）1234567891011121314//创建路径分析对象 var shortestAnalyst = new RouteTask(&quot;http://localhost:6080/arcgis/rest/services/Test/mynet/NAServer/Route&quot;); //创建路径参数对象 var routeParas = new RouteParameters(); //障碍点，但是此时障碍点为空 routeParas.barriers = new FeatureSet(); //停靠点，但是此时停靠点为空 routeParas.stops = new FeatureSet(); //路径是否有方向 routeParas.returnDirections = false; //是否返回路径，此处必须返回 routeParas.returnRoutes = true; //空间参考 routeParas.outSpatialReference = map.SpatialReference; 给停靠点按钮和障碍点按钮绑定点击事件12345678910111213//定义一个标志 //selectPointID=0什么都不做 //selectPointID=1说明是添加停靠点 //selectPointID=2说明是添加障碍点 var selectPointID; //给停靠点按钮添加点击事件 on(dom.byId(&quot;stop&quot;),&quot;click&quot;,function()&#123; selectPointID = 1; &#125;) //给障碍点按钮添加点击事件 on(dom.byId(&quot;barriers&quot;),&quot;click&quot;,function()&#123; selectPointID = 2; &#125;) 给地图绑定点击事件（为了获得点的坐标–&gt;构建停靠点或者障碍点）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//定义停靠点的符号 var stopSymbol = new SimpleMarkerSymbol(); stopSymbol.style = SimpleMarkerSymbol.STYLE_CIRCLE; stopSymbol.setSize(8); stopSymbol.setColor(new Color(&quot;#FFFFCC&quot;)); //定义障碍点的符号 var barrierSymbol = new SimpleMarkerSymbol(); barrierSymbol.style = SimpleMarkerSymbol.STYLE_CIRCLE; barrierSymbol.setSize(8); barrierSymbol.setColor(new Color(&quot;#f1a340&quot;)); on(map, &quot;mouse-down&quot;, function(evt)&#123; //通过selectPointID判断是添加是停靠点还是障碍点 switch (selectPointID) &#123; case 0: break; case 1: //获得停靠点的坐标 var pointStop=evt.mapPoint; var gr=new Graphic(pointStop,stopSymbol); //构建停靠点的参数 routeParas.stops.features.push(gr); break; case 2: //获得障碍点的坐标 var pointBarrier=evt.mapPoint; var gr=new Graphic(pointBarrier,barrierSymbol); //构建障碍点的参数 routeParas.barriers.features.push(gr); break; &#125; //如果selectPointID不等于0，将点的坐标在地图上显示出来 if (selectPointID != 0) &#123; addTextPoint(&quot;停靠点&quot;, pointStop, stopSymbol); addTextPoint(&quot;障碍点&quot;, pointBarrier, barrierSymbol); selectPointID = 0; &#125; &#125;); //文本符号：文本信息，点坐标，符号 function addTextPoint(text,point,symbol) &#123; var textSymbol = new TextSymbol(text); textSymbol.setColor(new Color([128, 0, 0])); var graphicText = Graphic(point, textSymbol); var graphicpoint = new Graphic(point, symbol); //用默认的图层添加 map.graphics.add(graphicpoint); //用默认的图层添加 map.graphics.add(graphicText); &#125; 给分析按钮绑定点击事件1234567891011//给分析按钮添加点击事件 on(dom.byId(&quot;analyse&quot;),&quot;click&quot;,function()&#123; //如果障碍点或者停靠点的个数有一个为0，提示用户参数输入不对 if (routeParas.stops.features.length == 0 || routeParas.barriers.features.length==0) &#123; alert(&quot;输入参数不全，无法分析&quot;); return; &#125; //执行路径分析函数 shortestAnalyst.solve(routeParas, showRoute) &#125;) 获得结果，处理路径分析返回的结果。1234567891011121314151617181920//处理路径分析返回的结果。 function showRoute(solveResult) &#123; //路径分析的结果 var routeResults = solveResult.routeResults; //路径分析的长度 var res = routeResults.length; //路径的符号 routeSymbol = new SimpleLineSymbol(SimpleLineSymbol.STYLE_DASH, new Color([255, 0, 0]), 3); if (res &gt; 0) &#123; for (var i = 0; i &lt; res; i++) &#123; var graphicroute = routeResults[i]; var graphic = graphicroute.route; graphic.setSymbol(routeSymbol); map.graphics.add(graphic); &#125; &#125; else &#123; alert(&quot;没有返回结果&quot;); &#125; &#125; 运行结果添加停靠点添加障碍点分析获得结果 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165&lt;!DOCTYPE html&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;/&gt; &lt;title&gt;Geometric _Network&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;http://localhost/arcgis_js_api/library/3.17/3.17/dijit/themes/tundra/tundra.css&quot;/&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;http://localhost/arcgis_js_api/library/3.17/3.17/esri/css/esri.css&quot; /&gt; &lt;script type=&quot;text/Javascript&quot; src=&quot;http://localhost/arcgis_js_api/library/3.17/3.17/init.js&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; .MapClass&#123; width:100%; height:600px; border:1px solid #000; &#125; &lt;/style&gt; &lt;script type=&quot;text/javascript&quot;&gt; require([&quot;esri/map&quot;, &quot;dojo/on&quot;, &quot;dojo/dom&quot;, &quot;esri/layers/ArcGISDynamicMapServiceLayer&quot;, &quot;esri/tasks/RouteTask&quot;, &quot;esri/tasks/FeatureSet&quot;, &quot;esri/symbols/SimpleMarkerSymbol&quot;, &quot;esri/symbols/TextSymbol&quot;, &quot;esri/toolbars/draw&quot;, &quot;esri/symbols/SimpleLineSymbol&quot;, &quot;esri/tasks/RouteParameters&quot;, &quot;dojo/colors&quot;, &quot;esri/graphic&quot;, &quot;dojo/domReady!&quot;], function (Map,on,dom, ArcGISDynamicMapServiceLayer, RouteTask, FeatureSet, SimpleMarkerSymbol, TextSymbol, Draw, SimpleLineSymbol, RouteParameters, Color, Graphic ) &#123; var map = new Map(&quot;MyMapDiv&quot;); var layer = new ArcGISDynamicMapServiceLayer (&quot;http://localhost:6080/arcgis/rest/services/Test/mynet/MapServer&quot;); map.addLayer(layer) //创建路径分析对象 var shortestAnalyst = new RouteTask(&quot;http://localhost:6080/arcgis/rest/services/Test/mynet/NAServer/Route&quot;); //创建路径参数对象 var routeParas = new RouteParameters(); //障碍点，但是此时障碍点为空 routeParas.barriers = new FeatureSet(); //停靠点，但是此时停靠点为空 routeParas.stops = new FeatureSet(); //路径是否有方向 routeParas.returnDirections = false; //是否返回路径，此处必须返回 routeParas.returnRoutes = true; //空间参考 routeParas.outSpatialReference = map.SpatialReference; //定义一个标志 //selectPointID=0什么都不做 //selectPointID=1说明是添加停靠点 //selectPointID=2说明是添加障碍点 var selectPointID; //给停靠点按钮添加点击事件 on(dom.byId(&quot;stop&quot;),&quot;click&quot;,function()&#123; selectPointID = 1; &#125;) //给障碍点按钮添加点击事件 on(dom.byId(&quot;barriers&quot;),&quot;click&quot;,function()&#123; selectPointID = 2; &#125;) //定义停靠点的符号 var stopSymbol = new SimpleMarkerSymbol(); stopSymbol.style = SimpleMarkerSymbol.STYLE_CIRCLE; stopSymbol.setSize(8); stopSymbol.setColor(new Color(&quot;#FFFFCC&quot;)); //定义障碍点的符号 var barrierSymbol = new SimpleMarkerSymbol(); barrierSymbol.style = SimpleMarkerSymbol.STYLE_CIRCLE; barrierSymbol.setSize(8); barrierSymbol.setColor(new Color(&quot;#f1a340&quot;)); on(map, &quot;mouse-down&quot;, function(evt)&#123; //通过selectPointID判断是添加是停靠点还是障碍点 switch (selectPointID) &#123; case 0: break; case 1: //获得停靠点的坐标 var pointStop=evt.mapPoint; var gr=new Graphic(pointStop,stopSymbol); //构建停靠点的参数 routeParas.stops.features.push(gr); break; case 2: //获得障碍点的坐标 var pointBarrier=evt.mapPoint; var gr=new Graphic(pointBarrier,barrierSymbol); //构建障碍点的参数 routeParas.barriers.features.push(gr); break; &#125; //如果selectPointID不等于0，将点的坐标在地图上显示出来 if (selectPointID != 0) &#123; addTextPoint(&quot;停靠点&quot;, pointStop, stopSymbol); addTextPoint(&quot;障碍点&quot;, pointBarrier, barrierSymbol); selectPointID = 0; &#125; &#125;); //文本符号：文本信息，点坐标，符号 function addTextPoint(text,point,symbol) &#123; var textSymbol = new TextSymbol(text); textSymbol.setColor(new Color([128, 0, 0])); var graphicText = Graphic(point, textSymbol); var graphicpoint = new Graphic(point, symbol); //用默认的图层添加 map.graphics.add(graphicpoint); map.graphics.add(graphicText); &#125; //给分析按钮添加点击事件 on(dom.byId(&quot;analyse&quot;),&quot;click&quot;,function()&#123; //如果障碍点或者停靠点的个数有一个为0，提示用户参数输入不对 if (routeParas.stops.features.length == 0 || routeParas.barriers.features.length==0) &#123; alert(&quot;输入参数不全，无法分析&quot;); return; &#125; //执行路径分析函数 shortestAnalyst.solve(routeParas, showRoute) &#125;) //处理路径分析返回的结果。 function showRoute(solveResult) &#123; //路径分析的结果 var routeResults = solveResult.routeResults; //路径分析的长度 var res = routeResults.length; //路径的符号 routeSymbol = new SimpleLineSymbol(SimpleLineSymbol.STYLE_DASH, new Color([255, 0, 0]), 3); if (res &gt; 0) &#123; for (var i = 0; i &lt; res; i++) &#123; var graphicroute = routeResults[i]; var graphic = graphicroute.route; graphic.setSymbol(routeSymbol); map.graphics.add(graphic); &#125; &#125; else &#123; alert(&quot;没有返回结果&quot;); &#125; &#125; &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;MyMapDiv&quot; class=&quot;MapClass&quot;&gt;&lt;/div&gt; &lt;input id=&quot;stop&quot; type=&quot;button&quot; value=&quot;停靠点&quot; /&gt; &lt;input id=&quot;barriers&quot; type=&quot;button&quot; value=&quot;障碍点&quot; /&gt; &lt;input id=&quot;analyse&quot; type=&quot;button&quot; value=&quot;分析&quot; /&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"ArcGIS","slug":"ArcGIS","permalink":"http://xdd7130.github.io/categories/ArcGIS/"}],"tags":[{"name":"ArcGIS API for JS","slug":"ArcGIS-API-for-JS","permalink":"http://xdd7130.github.io/tags/ArcGIS-API-for-JS/"},{"name":"webgis","slug":"webgis","permalink":"http://xdd7130.github.io/tags/webgis/"}]},{"title":"ArcGIS API For Javascript之编辑服务器端图层","slug":"ArcGIS-API-for-JS20","date":"2019-08-06T09:19:00.000Z","updated":"2022-11-02T11:15:20.516Z","comments":true,"path":"2019/08/06/ArcGIS-API-for-JS20/","link":"","permalink":"http://xdd7130.github.io/2019/08/06/ArcGIS-API-for-JS20/","excerpt":"","text":"在现实需求中，我们不仅仅需要编辑客户端图层，也有可能去编辑服务器端图层，要想编辑服务器端的图层，必须要将地图发布为：要素服务 需求（服务器端图层编辑）关于服务器端图层的操作,基本就是增删改查操作，要素服务的查询前面已经介绍过，在此篇博客中主要记录一下关于要素服务的增删改操作,在ArcGIS API for JS中给我们提供了三个类用于要素的增Add,删Delete,改Update,接下来就用这三个类来实现我们的功能。 我们操作的是要素服务的sushelou图层 我们的服务： 注意：宿舍楼图层编号为1 图层的属性信息 实现首先在页面添加三个按钮(用于实现用户的增删改操作) 添加要素 删除要素 修改要素 查询要素添加地图（省略）创建通用的对象，例如Draw12345678910//用于操作的要素图层，注意我们是操作的宿舍楼图层var featureLayer = new FeatureLayer(&quot;http://localhost:6080/arcgis/rest/services/Test/ft/FeatureServer/1&quot;, &#123; mode:FeatureLayer.MODE_SNAPSHOT, outFields: [&quot;*&quot;] &#125;); //在添加要素时，利用Draw工具获得geometry对象 var d = new Draw(map, &#123; showTooltips: true &#125;); //要操作的graphic var g; 给相应的按钮添加绑定事件12345678910111213141516171819202122232425262728293031323334query(&quot;button&quot;).on(&quot;click&quot;,function(event)&#123; //获得按钮的文本 var value=this.innerHTML; //根据文本绑定不同的事件 switch(value)&#123; case &quot;添加要素&quot;: d.activate(Draw.POLYGON); break; case &quot;删除要素&quot;: //创建Graphic对象，删除OBJECTID为34的元素， //因为OBJECTID是主键，所以只需要指定主键即可 g=new Graphic(&quot;&quot;,&quot;&quot;,&#123; &quot;OBJECTID&quot;:34 &#125;); //创建删除对象 var de=new Delete(&#123; &quot;featureLayer&quot;:featureLayer, &quot;deletedGraphics&quot;:[g] &#125;); //执行删除结果 de.performRedo(); //刷新图层 layer.refresh(); break; case &quot;修改要素&quot;: //用于修改要素的函数,查询更新为36的要素 updateFeature(36); break; case &quot;查询要素&quot;: //用于查询要素的函数，查询主键为36的要素 searchFeather(36); break; &#125; &#125;); 如果是添加操作（利用draw添加geometry属性）123456789101112131415//当画图完毕时，添加要素 on(d, &quot;draw-complete&quot;, function (result) &#123; //要素只赋予了geometry，属性信息为空 var graphic = new Graphic(result.geometry, null,&#123;&#125;); var add=new Add(&#123; &quot;featureLayer&quot;:featureLayer,//给哪一个要素图层添加要素 &quot;addedGraphics&quot;:[graphic]//用于添加的要素 &#125;) //执行添加函数 add.performRedo(); //刷新视图 layer.refresh(); //关闭绘图对象 d.deactivate(); &#125;); 如果是查询操作12345678910111213141516171819202122232425262728293031//根据id查询要素 function searchFeather(id,callback)&#123; //得到要素图层的主键属性 var idProperty = featureLayer.objectIdField; //定义查询参数 var query = new Query(); //是否返回几何形状 query.returnGeometry = false; //图层的主键名称（根据自己要求修改） query.objectIds = [id]; //查询条件1=1意思是：只根据主键查询，忽略where子句 query.where = &quot;1=1&quot;; //进行查询 featureLayer.selectFeatures(query, FeatureLayer.SELECTION_NEW,function(result)&#123; //如果callback不存在，说明仅仅是查询操作 if(!callback)&#123; //因为我们根据主键查询，一定只有一个元素 var graphic=result[0]; //获得属性 var attributes=graphic.attributes; //得到该属性信息转换成字符串 var result=jsonUtil.stringify(attributes) //将结果弹出一下 alert(result); &#125;else//如果callback存在，说明是更新操作 &#123; callback(result); &#125; &#125;); &#125; 如果是更新操作12345678910111213141516171819202122232425//根据id修改要素 function updateFeature(id)&#123; //注意:（第二个参数）这里传入一个回调函数，用于处理查询出来的数据 searchFeather(id,function(result)&#123; //获得旧的要素 var oldgraphic=result[0]; //新的要素 var newgraphic=new Graphic(oldgraphic.toJson()); //将alias属性修改为:修改后的C区 newgraphic.attributes.alias=&quot;修改后的C区&quot;; //创建更新对象 var update=new Update(&#123; &quot;featureLayer&quot;:featureLayer, &quot;postUpdatedGraphics&quot;:[newgraphic],//修改之后的要素 &quot;preUpdatedGraphics&quot;:[oldgraphic]//修改之前的要素 &#125;) //执行刷新操作 update.performRedo(); //刷新视图 layer.refresh(); alert(&quot;修改成功&quot;); &#125;) &#125; 全部代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158&lt;!DOCTYPE html&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;/&gt; &lt;title&gt;WebGIS&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;http://localhost/arcgis_js_api/library/3.17/3.17/dijit/themes/tundra/tundra.css&quot;/&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;http://localhost/arcgis_js_api/library/3.17/3.17/esri/css/esri.css&quot; /&gt; &lt;script type=&quot;text/Javascript&quot; src=&quot;http://localhost/arcgis_js_api/library/3.17/3.17/init.js&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; .MapClass&#123; width:100%; height:500px; border:1px solid #000; &#125; &lt;/style&gt; &lt;script type=&quot;text/javascript&quot;&gt; require([&quot;esri/map&quot;, &quot;dojo/on&quot;, &quot;dojo/query&quot;, &quot;esri/layers/ArcGISDynamicMapServiceLayer&quot;, &quot;esri/toolbars/draw&quot;, &quot;esri/layers/FeatureLayer&quot;, &quot;esri/graphic&quot;, &quot;esri/dijit/editing/Add&quot;, &quot;esri/dijit/editing/Delete&quot;,&quot;esri/dijit/editing/Update&quot;,&quot;esri/tasks/query&quot;,&quot;dojo/json&quot;, &quot;dojo/domReady!&quot;], function (Map,on,query, ArcGISDynamicMapServiceLayer, Draw,FeatureLayer,Graphic,Add,Delete,Update,Query,jsonUtil) &#123; var map = new esri.Map(&quot;MyMapDiv&quot;); var layer = new ArcGISDynamicMapServiceLayer(&quot;http://localhost:6080/arcgis/rest/services/Test/ft/MapServer&quot;); map.addLayer(layer); //用于操作的要素图层，注意我们是操作的宿舍楼图层 var featureLayer = new FeatureLayer(&quot;http://localhost:6080/arcgis/rest/services/Test/ft/FeatureServer/1&quot;, &#123; mode:FeatureLayer.MODE_SNAPSHOT, outFields: [&quot;*&quot;] &#125;); //在添加要素时，利用Draw工具获得geometry对象 var d = new Draw(map, &#123; showTooltips: true &#125;); //要操作的graphic var g; query(&quot;button&quot;).on(&quot;click&quot;,function(event)&#123; var value=this.innerHTML; switch(value)&#123; case &quot;添加要素&quot;: d.activate(Draw.POLYGON); break; case &quot;删除要素&quot;: //创建Graphic对象，删除OBJECTID为34的元素， //因为OBJECTID是主键，所以只需要指定主键即可 g=new Graphic(&quot;&quot;,&quot;&quot;,&#123; &quot;OBJECTID&quot;:34 &#125;); //创建删除对象 var de=new Delete(&#123; &quot;featureLayer&quot;:featureLayer, &quot;deletedGraphics&quot;:[g] &#125;); //执行删除结果 de.performRedo(); //刷新图层 layer.refresh(); break; case &quot;修改要素&quot;: //用于修改要素的函数,查询更新为36的要素 updateFeature(1); break; case &quot;查询要素&quot;: //用于查询要素的函数，查询主键为36的要素 searchFeather(1); break; &#125; &#125;); //当画图完毕时，添加要素 on(d, &quot;draw-complete&quot;, function (result) &#123; //要素只赋予了geometry，属性信息为空 var graphic = new Graphic(result.geometry, null,&#123;&#125;); var add=new Add(&#123; &quot;featureLayer&quot;:featureLayer,//给哪一个要素图层添加要素 &quot;addedGraphics&quot;:[graphic]//用于添加的要素 &#125;) //执行添加函数 add.performRedo(); //刷新视图 layer.refresh(); //关闭绘图对象 d.deactivate(); &#125;); //根据id修改要素 function updateFeature(id)&#123; //注意:（第二个参数）这里传入一个回调函数，用于处理查询出来的数据 searchFeather(id,function(result)&#123; //获得旧的要素 var oldgraphic=result[0]; //新的要素 var newgraphic=new Graphic(oldgraphic.toJson()); //将alias属性修改为:修改后的A区宿舍 newgraphic.attributes.alias=&quot;修改后的A区宿舍&quot;; //创建更新对象 var update=new Update(&#123; &quot;featureLayer&quot;:featureLayer, &quot;postUpdatedGraphics&quot;:[newgraphic],//修改之后的要素 &quot;preUpdatedGraphics&quot;:[oldgraphic]//修改之前的要素 &#125;) //执行刷新操作 update.performRedo(); //刷新视图 layer.refresh(); alert(&quot;修改成功&quot;); &#125;) &#125; //根据id查询要素 function searchFeather(id,callback)&#123; //得到要素图层的主键属性 var idProperty = featureLayer.objectIdField; //定义查询参数 var query = new Query(); //是否返回几何形状 query.returnGeometry = false; //图层的主键名称（根据自己要求修改） query.objectIds = [id]; //查询条件1=1意思是：只根据主键查询，忽略where子句 query.where = &quot;1=1&quot;; //进行查询 featureLayer.selectFeatures(query, FeatureLayer.SELECTION_NEW,function(result)&#123; //如果callback不存在，说明仅仅是查询操作 if(!callback)&#123; //因为我们根据主键查询，一定只有一个元素 var graphic=result[0]; //获得属性 var attributes=graphic.attributes; //得到该属性信息转换成字符串 var result=jsonUtil.stringify(attributes) //将结果弹出一下 alert(result); &#125;else//如果callback存在，说明是更新操作 &#123; callback(result); &#125; &#125;); &#125; &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;MyMapDiv&quot; class=&quot;MapClass&quot;&gt;&lt;/div&gt;&lt;button class=&quot;btn&quot;&gt;添加要素&lt;/button&gt;&lt;button class=&quot;btn&quot;&gt;删除要素&lt;/button&gt;&lt;button class=&quot;btn&quot;&gt;修改要素&lt;/button&gt;&lt;button class=&quot;btn&quot;&gt;查询要素&lt;/button&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"ArcGIS","slug":"ArcGIS","permalink":"http://xdd7130.github.io/categories/ArcGIS/"}],"tags":[{"name":"ArcGIS API for JS","slug":"ArcGIS-API-for-JS","permalink":"http://xdd7130.github.io/tags/ArcGIS-API-for-JS/"},{"name":"webgis","slug":"webgis","permalink":"http://xdd7130.github.io/tags/webgis/"}]},{"title":"ArcGIS API For Javacsript编辑客户端图形","slug":"ArcGIS-API-for-JS19","date":"2019-08-06T09:07:56.000Z","updated":"2022-11-02T11:15:20.513Z","comments":true,"path":"2019/08/06/ArcGIS-API-for-JS19/","link":"","permalink":"http://xdd7130.github.io/2019/08/06/ArcGIS-API-for-JS19/","excerpt":"","text":"在ArcGIS API当中，提供了一个工具叫做Edit，我们利用Edit可以交互的编辑客户端图形Graphic，这个功能在我们实际开发过程中非常有用，可以交互编辑已经存在的Graphic以达到我们的目的，Edit工具可以从以下方面编辑客户端图形： 移动客户端图形 编辑结点（增加结点，删除结点） 拉伸客户端图形（是否保持长宽比例） 旋转客户端图形 Edit工具的使用使用Edit工具很简单，只需要以下几步即可： 给地图添加Graphic，为了下面Edit交互操作做准备 创建Edit对象 激活Edit工具，此时需要制定Edit的一些参数 操作完Graphic将Edit工具关闭 代码实现添加地图（省略）定义Edit对象，和graphic对象1234//声明一个客户端图形（为了以后的编辑）var graphic//定义一个Edit对象var edit = new Edit(map); 首先创建几个按钮（用户实现相应的功能）12345&lt;input type=&quot;button&quot; id=&quot;add&quot; value=&quot;添加客户端图形&quot;&gt;&lt;input type=&quot;button&quot; class=&quot;btn&quot; value=&quot;移动客户端图形&quot;&gt;&lt;input type=&quot;button&quot; class=&quot;btn&quot; value=&quot;拉伸客户端图形&quot;&gt;&lt;input type=&quot;button&quot; class=&quot;btn&quot; value=&quot;旋转客户端图形&quot;&gt;&lt;input type=&quot;button&quot; class=&quot;btn&quot; value=&quot;编辑结点&quot;&gt; 给添加客户端图形按钮添加绑定事件123456789101112131415161718192021on(dom.byId(&quot;add&quot;),&quot;click&quot;,function()&#123; //定义线符号 var lineSymbol=new SimpleLineSymbol(SimpleLineSymbol.STYLE_DASH, new Color([255, 0, 0]), 3); //定义面符号 var fill=SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, lineSymbol, new Color([255, 0, 0])); //点的坐标对 var ring=[]; ring[0]=[ [510275, 3986100], [510508, 3986162], [510596, 3986032], [510271, 3985847], [510275, 3986100] ]; var geometry=new Polygon(&#123; &quot;rings&quot;:ring, &quot;spatialReference&quot;:map.spatialReference &#125;); graphic=new Graphic(geometry,fill); map.graphics.add(graphic); &#125;) 给剩余四个按钮添加绑定事件123456789101112131415161718192021222324252627282930//给剩余四个按钮绑定事件 query(&quot;.btn&quot;).on(&quot;click&quot;,function(event)&#123; var value=event.currentTarget.defaultValue; switch(value)&#123; case &quot;移动客户端图形&quot;: //激活Edit工具（移动） edit.activate(Edit.MOVE,graphic); break; case &quot;拉伸客户端图形&quot;: //构建Edit参数 注：拉伸的时候，可以指定是否保持长宽比例 var options = &#123; uniformScaling:true &#125;; //激活Edit工具（拉伸客户端图形） edit.activate(Edit.SCALE,graphic,options) break; case &quot;旋转客户端图形&quot;: //激活Edit工具（旋转客户端图形） edit.activate(Edit.ROTATE,graphic) break; case &quot;编辑结点&quot;: //构建Edit参数 注：编辑折点的时候，要指定是否能添加或者删除结点。 var options = &#123; allowAddVertices:true,//能添加结点 allowDeleteVertices: true,//能删除结点 &#125;; edit.activate(Edit.EDIT_VERTICES, graphic, options); break; &#125; &#125;) 关闭Edit工具1234//用完Edit工具，将工具关闭，点击地图（没有点击到Graphic时结束） map.on(&quot;click&quot;, function () &#123; edit.deactivate(); &#125;) 结果 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Graphic&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;http://localhost/arcgis_js_api/library/3.17/3.17/dijit/themes/tundra/tundra.css&quot;/&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;http://localhost/arcgis_js_api/library/3.17/3.17/esri/css/esri.css&quot; /&gt; &lt;script type=&quot;text/Javascript&quot; src=&quot;http://localhost/arcgis_js_api/library/3.17/3.17/init.js&quot;&gt;&lt;/script&gt; &lt;style&gt; .MapClass&#123; width:100%; height:500px; border:1px solid #000; &#125; &lt;/style&gt; &lt;script&gt; require([&quot;esri/map&quot;,&quot;dojo/dom&quot;,&quot;dojo/on&quot;,&quot;esri/toolbars/edit&quot;,&quot;esri/geometry/Polygon&quot;, &quot;esri/layers/ArcGISDynamicMapServiceLayer&quot;, &quot;esri/graphic&quot;, &quot;esri/symbols/SimpleLineSymbol&quot;, &quot;esri/symbols/SimpleFillSymbol&quot;,&quot;dojo/colors&quot;,&quot;dojo/query&quot;, &quot;dojo/domReady!&quot; ], function ( Map,dom,on, Edit,Polygon, ArcGISDynamicMapServiceLayer, Graphic, SimpleLineSymbol, SimpleFillSymbol,Color,query ) &#123; var map = new Map(&quot;mapDiv&quot;); var url = &quot;http://localhost:6080/arcgis/rest/services/Test/MyService/MapServer&quot;; var layer = new ArcGISDynamicMapServiceLayer(url); map.addLayer(layer); //定义一个Edit对象 var edit = new Edit(map); //定义一个graphic，为了后来的交互编辑 var graphic; //给`添加客户端图形`按钮添加绑定事件 on(dom.byId(&quot;add&quot;),&quot;click&quot;,function()&#123; //定义线符号 var lineSymbol=new SimpleLineSymbol(SimpleLineSymbol.STYLE_DASH, new Color([255, 0, 0]), 3); //定义面符号 var fill=SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, lineSymbol, new Color([255, 0, 0])); //点的坐标对 var ring=[]; ring[0]=[ [510275, 3986100], [510508, 3986162], [510596, 3986032], [510271, 3985847], [510275, 3986100] ]; var geometry=new Polygon(&#123; &quot;rings&quot;:ring, &quot;spatialReference&quot;:map.spatialReference &#125;); graphic=new Graphic(geometry,fill); map.graphics.add(graphic); &#125;) //给按钮绑定事件 query(&quot;.btn&quot;).on(&quot;click&quot;,function(event)&#123; var value=event.currentTarget.defaultValue; switch(value)&#123; case &quot;移动客户端图形&quot;: //激活Edit工具（移动） edit.activate(Edit.MOVE,graphic); break; case &quot;拉伸客户端图形&quot;: //构建Edit参数 注：拉伸的时候，可以指定是否保持长宽比例 var options = &#123; uniformScaling:true &#125;; //激活Edit工具（拉伸客户端图形） edit.activate(Edit.SCALE,graphic,options) break; case &quot;旋转客户端图形&quot;: //激活Edit工具（旋转客户端图形） edit.activate(Edit.ROTATE,graphic) break; case &quot;编辑结点&quot;: //构建Edit参数 注：编辑折点的时候，要指定是否能添加或者删除结点。 var options = &#123; allowAddVertices:true,//能添加结点 allowDeleteVertices: true,//能删除结点 &#125;; edit.activate(Edit.EDIT_VERTICES, graphic, options); break; &#125; &#125;) //用完Edit工具，将工具关闭，点击地图（没有点击到Graphic时结束） map.on(&quot;click&quot;, function () &#123; edit.deactivate(); &#125;) &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;mapDiv&quot; class=&quot;MapClass&quot;&gt;&lt;/div&gt; &lt;input type=&quot;button&quot; id=&quot;add&quot; value=&quot;添加客户端图形&quot;&gt; &lt;input type=&quot;button&quot; class=&quot;btn&quot; value=&quot;移动客户端图形&quot;&gt; &lt;input type=&quot;button&quot; class=&quot;btn&quot; value=&quot;拉伸客户端图形&quot;&gt; &lt;input type=&quot;button&quot; class=&quot;btn&quot; value=&quot;旋转客户端图形&quot;&gt; &lt;input type=&quot;button&quot; class=&quot;btn&quot; value=&quot;编辑结点&quot;&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"ArcGIS","slug":"ArcGIS","permalink":"http://xdd7130.github.io/categories/ArcGIS/"}],"tags":[{"name":"ArcGIS API for JS","slug":"ArcGIS-API-for-JS","permalink":"http://xdd7130.github.io/tags/ArcGIS-API-for-JS/"},{"name":"webgis","slug":"webgis","permalink":"http://xdd7130.github.io/tags/webgis/"}]},{"title":"ArcGIS API For Javascript之动态图层","slug":"ArcGIS-API-for-JS18","date":"2019-08-06T08:42:34.000Z","updated":"2022-11-02T11:15:20.503Z","comments":true,"path":"2019/08/06/ArcGIS-API-for-JS18/","link":"","permalink":"http://xdd7130.github.io/2019/08/06/ArcGIS-API-for-JS18/","excerpt":"","text":"动态图层主要特点： 改变地图服务的现有图层 动态图层适用于海量图层的情况 不需要将shp文件发布为服务，服务器可以直接读取shp文件在前端显示 调用动态图层在前面已经说过动态图层并不是一种新的服务类型，而是地图服务的一种扩展，因此我们不需要发布服务，只需要对地图服务添加动态图层功能即可。启用地图服务的步骤为： 给相应的地图服务启用动态工作空间 选择服务器相应的硬盘地址并赋予其id 将相应位置注册到ArcGIS Server服务器（保证ArcGIS Server可以访问数据） 在Web端进行调用 启用动态图层我们打开Manager-&gt;登录，找到该服务，点击功能，选择允许每次请求修改图层顺序和符号-&gt;添加硬盘上的数据注:D:\\myshp文件夹下面有一个shp文件：lunkuoxian.shp因此我们选择工作空间类型为：shpfile文件夹，工作空间id在此处取名为my，硬盘路径：D：\\myshp点击确定，重新启动服务注册文件夹到服务器点击站点-&gt;数据存储-&gt;注册文件夹（因为我们是文件夹，所以是注册文件夹，如果是数据库，那么就要注册数据库）在Services Directory 查看动态图层是否启用 Web端调用代码实现首先我们加载地图12345678910111213141516require([&quot;esri/map&quot;, &quot;dojo/dom&quot;, &quot;dojo/on&quot;, &quot;esri/layers/ArcGISDynamicMapServiceLayer&quot;, &quot;esri/layers/FeatureLayer&quot;, &quot;esri/layers/TableDataSource&quot;, &quot;esri/layers/LayerDataSource&quot;, &quot;esri/renderers/SimpleRenderer&quot;, &quot;esri/symbols/SimpleMarkerSymbol&quot;, &quot;esri/symbols/SimpleLineSymbol&quot;, &quot;dojo/domReady!&quot;], function ( Map,dom,on, ArcGISDynamicMapServiceLayer, FeatureLayer, TableDataSource, LayerDataSource, SimpleRenderer, SimpleMarkerSymbol,SimpleLineSymbol) &#123; var map = new Map(&quot;mapDiv&quot;); var layer1 = new ArcGISDynamicMapServiceLayer(&quot;http://localhost:6080/arcgis/rest/services//Test/MyService/MapServer&quot;); map.addLayer(layer1); &#125;); 添加一个按钮（用于添加动态图层）1&lt;button id=&quot;btn&quot;&gt;添加动态图层&lt;/button&gt; 给按钮添加事件1234567891011121314151617181920212223242526on(dom.byId(&quot;btn&quot;),&quot;click&quot;,function(e)&#123; //定义一个数据源 var dataSource = new TableDataSource(); //此处为我们设置的命名空间 dataSource.workspaceId = &quot;my&quot;; //命名空间下面的shp dataSource.dataSourceName = &quot;lunkuoxian.shp&quot;; //定义一个图层数据源 var layerSource = new LayerDataSource(); //给图层数据源赋值 layerSource.dataSource = dataSource; //定义一个要素图层:注意链接为动态图层的地址 var layer2 = new FeatureLayer(&quot;http://localhost:6080/arcgis/rest/services/Test/MyService/MapServer/dynamicLayer&quot;, &#123; mode: FeatureLayer.MODE_ONDEMAND, outFields: [&quot;*&quot;], source: layerSource &#125;); //定义线符号 var lineSymbol = new SimpleLineSymbol(SimpleLineSymbol.STYLE_DASH, new dojo.Color([255, 0, 0]), 3); //定义渲染器 var renderer = new esri.renderer.SimpleRenderer(lineSymbol); //定义渲染器 layer2.setRenderer(renderer); layer2.refresh(); map.addLayer(layer2); &#125;) 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;http://localhost/arcgis_js_api/library/3.17/3.17/dijit/themes/tundra/tundra.css&quot;/&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;http://localhost/arcgis_js_api/library/3.17/3.17/esri/css/esri.css&quot; /&gt; &lt;script type=&quot;text/Javascript&quot; src=&quot;http://localhost/arcgis_js_api/library/3.17/3.17/init.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; require([&quot;esri/map&quot;, &quot;dojo/dom&quot;, &quot;dojo/on&quot;, &quot;esri/layers/ArcGISDynamicMapServiceLayer&quot;, &quot;esri/layers/FeatureLayer&quot;, &quot;esri/layers/TableDataSource&quot;, &quot;esri/layers/LayerDataSource&quot;, &quot;esri/renderers/SimpleRenderer&quot;, &quot;esri/symbols/SimpleLineSymbol&quot;, &quot;dojo/domReady!&quot;], function ( Map,dom,on, ArcGISDynamicMapServiceLayer, FeatureLayer, TableDataSource, LayerDataSource, SimpleRenderer,SimpleLineSymbol) &#123; var map = new Map(&quot;mapDiv&quot;); var layer1 = new ArcGISDynamicMapServiceLayer(&quot;http://localhost:6080/arcgis/rest/services//Test/MyService/MapServer&quot;); map.addLayer(layer1); on(dom.byId(&quot;btn&quot;),&quot;click&quot;,function(e)&#123; //定义一个数据源 var dataSource = new TableDataSource(); //此处为我们设置的命名空间 dataSource.workspaceId = &quot;my&quot;; //命名空间下面的shp dataSource.dataSourceName = &quot;lunkuoxian.shp&quot;; //定义一个图层数据源 var layerSource = new LayerDataSource(); //给图层数据源赋值 layerSource.dataSource = dataSource; //定义一个要素图层:注意链接为动态图层的地址 var layer2 = new FeatureLayer(&quot;http://localhost:6080/arcgis/rest/services/Test/MyService/MapServer/dynamicLayer&quot;, &#123; mode: FeatureLayer.MODE_ONDEMAND, outFields: [&quot;*&quot;], source: layerSource &#125;); //定义线符号 var lineSymbol = new SimpleLineSymbol(SimpleLineSymbol.STYLE_DASH, new dojo.Color([255, 0, 0]), 3); //定义渲染器 var renderer = new esri.renderer.SimpleRenderer(lineSymbol); //定义渲染器 layer2.setRenderer(renderer); layer2.refresh(); map.addLayer(layer2); &#125;) &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;mapDiv&quot; style=&quot;height:600px;&quot;&gt;&lt;/div&gt;&lt;button id=&quot;btn&quot;&gt;添加动态图层&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; 运行结果之后： 动态图层的属性查询在真实需求中,我们不仅仅是将shp在地图中显示那么简单，我们往往要查询该图层的属性信息,我们在前面代码的基础上添加上属性查询。 方法1（通过click直接获取）代码实现给要素图层添加点击事件123456789101112layer2.on(&quot;click&quot;, function(evt) &#123; //得到点击的graphics var graphic=evt.graphic; //得到该属性信息 var attributes=graphic.attributes; //得到该属性信息转换成字符串 var result=jsonUtil.stringify(attributes) //将结果弹出一下 alert(result); //获得要素图层的主键名称 &#125;) 全部代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;http://localhost/arcgis_js_api/library/3.17/3.17/dijit/themes/tundra/tundra.css&quot;/&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;http://localhost/arcgis_js_api/library/3.17/3.17/esri/css/esri.css&quot; /&gt; &lt;script type=&quot;text/Javascript&quot; src=&quot;http://localhost/arcgis_js_api/library/3.17/3.17/init.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; require([&quot;esri/map&quot;, &quot;dojo/dom&quot;, &quot;dojo/on&quot;, &quot;esri/layers/ArcGISDynamicMapServiceLayer&quot;, &quot;esri/layers/FeatureLayer&quot;, &quot;esri/layers/TableDataSource&quot;, &quot;esri/layers/LayerDataSource&quot;, &quot;esri/renderers/SimpleRenderer&quot;, &quot;esri/symbols/SimpleLineSymbol&quot;,&quot;dojo/json&quot;, &quot;dojo/domReady!&quot;], function ( Map,dom,on, ArcGISDynamicMapServiceLayer, FeatureLayer, TableDataSource, LayerDataSource, SimpleRenderer,SimpleLineSymbol,jsonUtil) &#123; var map = new Map(&quot;mapDiv&quot;); var layer1 = new ArcGISDynamicMapServiceLayer(&quot;http://localhost:6080/arcgis/rest/services//Test/MyService/MapServer&quot;); map.addLayer(layer1); on(dom.byId(&quot;btn&quot;),&quot;click&quot;,function(e)&#123; //定义一个数据源 var dataSource = new TableDataSource(); //此处为我们设置的命名空间 dataSource.workspaceId = &quot;my&quot;; //命名空间下面的shp dataSource.dataSourceName = &quot;lunkuoxian.shp&quot;; //定义一个图层数据源 var layerSource = new LayerDataSource(); //给图层数据源赋值 layerSource.dataSource = dataSource; //定义一个要素图层:注意链接为动态图层的地址 var layer2 = new FeatureLayer(&quot;http://localhost:6080/arcgis/rest/services/Test/MyService/MapServer/dynamicLayer&quot;, &#123; mode: FeatureLayer.MODE_ONDEMAND, outFields: [&quot;*&quot;], source: layerSource &#125;); //定义线符号 var lineSymbol = new SimpleLineSymbol(SimpleLineSymbol.STYLE_DASH, new dojo.Color([255, 0, 0]), 3); //定义渲染器 var renderer = new esri.renderer.SimpleRenderer(lineSymbol); //定义渲染器 layer2.setRenderer(renderer); layer2.refresh(); map.addLayer(layer2); layer2.on(&quot;click&quot;, function(evt) &#123; //得到点击的graphics var graphic=evt.graphic; //得到该属性信息 var attributes=graphic.attributes; //得到该属性信息转换成字符串 var result=jsonUtil.stringify(attributes) //将结果弹出一下 alert(result); //获得要素图层的主键名称 &#125;) &#125;) &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;mapDiv&quot; style=&quot;height:600px;&quot;&gt;&lt;/div&gt;&lt;button id=&quot;btn&quot;&gt;添加动态图层&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; 运行结果: 通过查询获得属性代码实现定义一个按钮（用户获得属性）1&lt;button id=&quot;attr&quot;&gt;用户弹出属性&lt;/button&gt; 给相应的按钮绑定事件123456789101112131415161718192021222324on(dom.byId(&quot;attr&quot;),&quot;click&quot;,function()&#123; //得到要素图层的主键属性 var idProperty = layer2.objectIdField; //定义查询参数 var query = new Query(); //是否返回几何形状 query.returnGeometry = false; //图层的主键名称（根据自己要求修改） query.objectIds = [247]; //查询条件1=1意思是：只根据主键查询，忽略where子句 query.where = &quot;1=1&quot;; //进行查询 layer2.selectFeatures(query, FeatureLayer.SELECTION_NEW,function(result)&#123; //因为我们根据主键查询，一定只有一个元素 var graphic=result[0]; //获得属性 var attributes=graphic.attributes; //得到该属性信息转换成字符串 var result=jsonUtil.stringify(attributes) //将结果弹出一下 alert(result); &#125;); &#125;) 全部代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;http://localhost/arcgis_js_api/library/3.17/3.17/dijit/themes/tundra/tundra.css&quot;/&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;http://localhost/arcgis_js_api/library/3.17/3.17/esri/css/esri.css&quot; /&gt; &lt;script type=&quot;text/Javascript&quot; src=&quot;http://localhost/arcgis_js_api/library/3.17/3.17/init.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; require([&quot;esri/map&quot;, &quot;dojo/dom&quot;, &quot;dojo/on&quot;, &quot;esri/layers/ArcGISDynamicMapServiceLayer&quot;, &quot;esri/layers/FeatureLayer&quot;, &quot;esri/layers/TableDataSource&quot;, &quot;esri/layers/LayerDataSource&quot;, &quot;esri/renderers/SimpleRenderer&quot;, &quot;esri/symbols/SimpleLineSymbol&quot;,&quot;dojo/json&quot;,&quot;esri/tasks/query&quot;, &quot;dojo/domReady!&quot;], function ( Map,dom,on, ArcGISDynamicMapServiceLayer, FeatureLayer, TableDataSource, LayerDataSource, SimpleRenderer,SimpleLineSymbol,jsonUtil,Query) &#123; var map = new Map(&quot;mapDiv&quot;); var layer1 = new ArcGISDynamicMapServiceLayer(&quot;http://localhost:6080/arcgis/rest/services//Test/MyService/MapServer&quot;); map.addLayer(layer1); on(dom.byId(&quot;btn&quot;),&quot;click&quot;,function(e)&#123; //定义一个数据源 var dataSource = new TableDataSource(); //此处为我们设置的命名空间 dataSource.workspaceId = &quot;my&quot;; //命名空间下面的shp dataSource.dataSourceName = &quot;lunkuoxian.shp&quot;; //定义一个图层数据源 var layerSource = new LayerDataSource(); //给图层数据源赋值 layerSource.dataSource = dataSource; //定义一个要素图层:注意链接为动态图层的地址 var layer2 = new FeatureLayer(&quot;http://localhost:6080/arcgis/rest/services/Test/MyService/MapServer/dynamicLayer&quot;, &#123; mode: FeatureLayer.MODE_ONDEMAND, outFields: [&quot;*&quot;], source: layerSource &#125;); //定义线符号 var lineSymbol = new SimpleLineSymbol(SimpleLineSymbol.STYLE_DASH, new dojo.Color([255, 0, 0]), 3); //定义渲染器 var renderer = new esri.renderer.SimpleRenderer(lineSymbol); //定义渲染器 layer2.setRenderer(renderer); layer2.refresh(); map.addLayer(layer2); on(dom.byId(&quot;attr&quot;),&quot;click&quot;,function()&#123; //得到要素图层的主键属性 var idProperty = layer2.objectIdField; //定义查询参数 var query = new Query(); //是否返回几何形状 query.returnGeometry = false; //图层的主键名称（根据自己要求修改） query.objectIds = [247]; //查询条件1=1意思是：只根据主键查询，忽略where子句 query.where = &quot;1=1&quot;; //进行查询 layer2.selectFeatures(query, FeatureLayer.SELECTION_NEW,function(result)&#123; //因为我们根据主键查询，一定只有一个元素 var graphic=result[0]; //获得属性 var attributes=graphic.attributes; //得到该属性信息转换成字符串 var result=jsonUtil.stringify(attributes) //将结果弹出一下 alert(result); &#125;); &#125;) &#125;) &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;mapDiv&quot; style=&quot;height:600px;&quot;&gt;&lt;/div&gt;&lt;button id=&quot;btn&quot;&gt;添加动态图层&lt;/button&gt;&lt;button id=&quot;attr&quot;&gt;用户弹出属性&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; 补充启用文件地理数据库三点不同文件的目录命名空间配置注册文件夹配置代码调用差别注意：忽略了要素集的存在，即调用是lunkuoxian，而不是vector.lunkuoxian，调用的时候后面没有*.shp","categories":[{"name":"ArcGIS","slug":"ArcGIS","permalink":"http://xdd7130.github.io/categories/ArcGIS/"}],"tags":[{"name":"ArcGIS API for JS","slug":"ArcGIS-API-for-JS","permalink":"http://xdd7130.github.io/tags/ArcGIS-API-for-JS/"},{"name":"webgis","slug":"webgis","permalink":"http://xdd7130.github.io/tags/webgis/"}]},{"title":"ArcGIS API For Javascript调用结果地图服务","slug":"ArcGIS-API-for-JS17","date":"2019-08-06T08:07:59.000Z","updated":"2022-11-02T11:15:20.500Z","comments":true,"path":"2019/08/06/ArcGIS-API-for-JS17/","link":"","permalink":"http://xdd7130.github.io/2019/08/06/ArcGIS-API-for-JS17/","excerpt":"","text":"结果地图服务也是GP服务的一种，当GP服务的结果返回栅格数据时，我们往往使用结果地图服务来对生成的栅格数据进行渲染，本实例是：克里金差值 ArcGIS API调用结果地图服务首先我们查看一下服务的定义： ####代码实现在页面添加地图（略）创建两个按钮（一个是画点，一个是进行插值运算）12&lt;input id=&quot;Btn&quot; type=&quot;button&quot; value=&quot;画点&quot; /&gt;&lt;input id=&quot;king&quot; type=&quot;button&quot; value=&quot;插值分析&quot; /&gt; 定义点集合对象1234567//定义点集合var pointSet = new FeatureSet();//定义点符号var psymbol = new SimpleMarkerSymbol(SimpleMarkerSymbol.STYLE_CROSS, 12,new SimpleLineSymbol(SimpleLineSymbol.STYLE_SOLID,new dojo.Color([255, 0, 0]), 2),new dojo.Color([0, 255, 0, 0.25])); 给画点的按钮绑定事件1234567891011121314151617181920//绑定画点的事件on(dom.byId(&quot;Btn&quot;),&quot;click&quot;,function(e)&#123; //定义绘图工具 var toolBar = new Draw(MyMap, &#123; showTooltips: true &#125;); //激活绘图工具 toolBar.activate(Draw.POINT); //定义一个i，为了给graphic赋予属性，为差值做准备。 var i=20; //给绘图工具绑定绘图完成事件 on(toolBar, &quot;draw-complete&quot;, function(result)&#123; //保证每一次i的值都不一样，如果所有点的属性都一样，是不可以差值的。 i=i+40; //获得几何形状 var geometry = result.geometry; //给图形一个m属性，我们后面对m进行差值 var graphicpoint = new Graphic(geometry, psymbol,&#123;&quot;m&quot;:i&#125;); pointSet.features.push(graphicpoint); MyMap.graphics.add(graphicpoint); &#125;); &#125;); 给插值按钮绑定事件12345678910111213141516171819//声明gp对象var gp;on(dom.byId(&quot;king&quot;),&quot;click&quot;,function(e)&#123; //定义gp服务对象 gp= new Geoprocessor(&quot;http://localhost:6080/arcgis/rest/services/Test/myKing/GPServer/king&quot;); //定义GP服务参数对象 var gpParams=&#123;&#125;; //添加点集合的字段信息 pointSet.fields=[&#123; &quot;name&quot;:&quot;m&quot;, &quot;type&quot;:&quot;esriFieldTypeSmallInteger&quot;, &quot;alias&quot;:&quot;m&quot; &#125;]; //添加Input参数 gpParams.Input=pointSet; //添加Z属性：即差值的属性 gpParams.Z=&quot;m&quot;; gp.submitJob(gpParams,completeCallback);&#125;) 回掉函数处理结果12345678910function completeCallback(jobInfo) &#123; gp.on(&quot;get-result-image-layer-complete&quot;,function(gpLayer)&#123; MyMap.addLayer(gpLayer[&quot;layer&quot;]) &#125;) gp.getResultImageLayer(jobInfo.jobId,&quot;out&quot;); &#125; 全部代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113&lt;!DOCTYPE html&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;/&gt; &lt;title&gt;GP&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;http://localhost/arcgis_js_api/library/3.17/3.17/dijit/themes/tundra/tundra.css&quot;/&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;http://localhost/arcgis_js_api/library/3.17/3.17/esri/css/esri.css&quot; /&gt; &lt;script type=&quot;text/Javascript&quot; src=&quot;http://localhost/arcgis_js_api/library/3.17/3.17/init.js&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; .MapClass&#123; width:100%; height:600px; border:1px solid #000; &#125; &lt;/style&gt; &lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt; require([&quot;esri/map&quot;, &quot;esri/layers/ArcGISDynamicMapServiceLayer&quot;, &quot;dojo/dom&quot;, &quot;esri/tasks/Geoprocessor&quot;, &quot;esri/tasks/FeatureSet&quot;, &quot;esri/symbols/SimpleMarkerSymbol&quot;, &quot;esri/symbols/SimpleLineSymbol&quot;, &quot;esri/toolbars/draw&quot;, &quot;esri/symbols/SimpleFillSymbol&quot;, &quot;dojo/on&quot;,&quot;esri/graphic&quot;, &quot;esri/layers/ImageParameters&quot;, &quot;dojo/domReady!&quot;], function (Map, ArcGISDynamicMapServiceLayer, dom, Geoprocessor, FeatureSet, SimpleMarkerSymbol, SimpleLineSymbol, Draw, SimpleFillSymbol,on,Graphic,ImageParameters) &#123; var MyMap = new Map(&quot;MyMapDiv&quot;); var layer = new ArcGISDynamicMapServiceLayer (&quot;http://localhost:6080/arcgis/rest/services/Test/ft/MapServer&quot;); MyMap.addLayer(layer) //定义点集合对象 var pointSet = new FeatureSet(); //定义点符号 var psymbol = new SimpleMarkerSymbol(SimpleMarkerSymbol.STYLE_CROSS, 12, new SimpleLineSymbol(SimpleLineSymbol.STYLE_SOLID, new dojo.Color([255, 0, 0]), 2), new dojo.Color([0, 255, 0, 0.25])); //绑定画点的事件 on(dom.byId(&quot;Btn&quot;),&quot;click&quot;,function(e)&#123; //定义绘图工具 var toolBar = new Draw(MyMap, &#123; showTooltips: true &#125;); //激活绘图工具 toolBar.activate(Draw.POINT); //定义一个i，为了给graphic赋予属性，为差值做准备。 var i=20; //给绘图工具绑定绘图完成事件 on(toolBar, &quot;draw-complete&quot;, function(result)&#123; //保证每一次i的值都不一样，如果所有点的属性都一样，是不可以差值的。 i=i+40; //获得几何形状 var geometry = result.geometry; //给图形一个m属性，我们后面对m进行差值 var graphicpoint = new Graphic(geometry, psymbol,&#123;&quot;m&quot;:i&#125;); pointSet.features.push(graphicpoint); MyMap.graphics.add(graphicpoint); &#125;); &#125;); var gp; on(dom.byId(&quot;king&quot;),&quot;click&quot;,function(e)&#123; //定义gp服务对象 gp= new Geoprocessor(&quot;http://localhost:6080/arcgis/rest/services/Test/myKing/GPServer/king&quot;); //定义GP服务参数对象 var gpParams=&#123;&#125;; //添加点集合的字段信息 pointSet.fields=[&#123; &quot;name&quot;:&quot;m&quot;, &quot;type&quot;:&quot;esriFieldTypeSmallInteger&quot;, &quot;alias&quot;:&quot;m&quot; &#125;]; //添加Input参数 gpParams.Input=pointSet; //添加Z属性：即差值的属性 gpParams.Z=&quot;m&quot;; //执行gp服务，注意这里是执行submitJob，因为是同步的gp服务 gp.submitJob(gpParams,completeCallback); &#125;) function completeCallback(jobInfo) &#123; //给gp服务绑定获得图层事件 gp.on(&quot;get-result-image-layer-complete&quot;,function(gpLayer)&#123; //将图层添加到地图中 MyMap.addLayer(gpLayer[&quot;layer&quot;]) &#125;) //注意out是服务定义的参数 gp.getResultImageLayer(jobInfo.jobId,&quot;out&quot;); &#125; &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;MyMapDiv&quot; class=&quot;MapClass&quot;&gt;&lt;/div&gt; &lt;input id=&quot;Btn&quot; type=&quot;button&quot; value=&quot;画点&quot; /&gt; &lt;input id=&quot;king&quot; type=&quot;button&quot; value=&quot;插值分析&quot; /&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"ArcGIS","slug":"ArcGIS","permalink":"http://xdd7130.github.io/categories/ArcGIS/"}],"tags":[{"name":"ArcGIS API for JS","slug":"ArcGIS-API-for-JS","permalink":"http://xdd7130.github.io/tags/ArcGIS-API-for-JS/"},{"name":"webgis","slug":"webgis","permalink":"http://xdd7130.github.io/tags/webgis/"}]},{"title":"ArcGIS API For Javascript调用GP服务","slug":"ArcGIS-API-for-JS16","date":"2019-08-06T07:59:51.000Z","updated":"2022-11-02T11:15:20.497Z","comments":true,"path":"2019/08/06/ArcGIS-API-for-JS16/","link":"","permalink":"http://xdd7130.github.io/2019/08/06/ArcGIS-API-for-JS16/","excerpt":"","text":"ArcGIS API中关于GP服务的调用是比较容易出错的，出错的大部分原因便是Web API调用GP服务的时候参数不对应导致的 ArcGIS API调用GP服务然后接下来我们将在Web中调用我们的GP服务 代码实现在页面加入地图（略）在页面添加两个按钮（第一个按钮用于画点，第二个按钮用于缓冲区分析）12&lt;input id=&quot;Btn&quot; type=&quot;button&quot; value=&quot;画点&quot; /&gt;&lt;input id=&quot;buffer&quot; type=&quot;button&quot; value=&quot;缓冲区分析&quot; /&gt; 定义一个点几何对象（与服务定义的类型对应）12//定义点几何对象var pointSet = new FeatureSet(); 定义点符号对象1234var psymbol = new SimpleMarkerSymbol(SimpleMarkerSymbol.STYLE_CROSS, 12,new SimpleLineSymbol(SimpleLineSymbol.STYLE_SOLID,new dojo.Color([255, 0, 0]), 2),new dojo.Color([0, 255, 0, 0.25])); 给画点按钮绑定点击事件1234567891011121314151617on(dom.byId(&quot;Btn&quot;),&quot;click&quot;,function(e)&#123; //定义绘图对象 var toolBar= new Draw(MyMap, &#123; showTooltips: true &#125;); //激活绘图对象 toolBar.activate(Draw.POINT); on(toolBar, &quot;draw-complete&quot;, function(result)&#123; //获得绘图结束的点对象 var geometry = result.geometry; //根据点对象生成相应的图形 var graphic = new Graphic(geometry, psymbol); //将点对象存储在点几何中 pointSet.features.push(graphic); //将图形存放在地图中，然后得以显示 MyMap.graphics.add(graphic); &#125;); &#125;); 给缓冲区分析按钮添加绑定事件12345678910111213141516on(dom.byId(&quot;buffer&quot;),&quot;click&quot;,function(e)&#123; //定义GP服务对象 var buffer = new Geoprocessor(&quot;http://localhost:6080/arcgis/rest/services/Test/MyBuffer/GPServer/Mybuffer&quot;); //构建GP服务参数 var gpParams=&#123;&#125;; //GP服务的Input参数 gpParams.Input=pointSet; //GP服务的dis参数 var dis=new LinearUnit(&#123; &quot;distance&quot;: 100, &quot;units&quot;: &quot;esriMeters&quot; &#125;); gpParams.dis=dis; //执行GP服务 buffer.execute(gpParams, showResult);&#125;) 处理GP服务返回的结果12345678910111213function showResult(results, messages)&#123; var features = results[0].value.features; for (var i = 0; i &lt; features.length; i++) &#123; var graphic = features[i]; //定义线符号 var lineSymbol=new SimpleLineSymbol(SimpleLineSymbol.STYLE_DASHDOT, new dojo.Color([255, 0, 0]), 1); //定义面符号 var PolygonSymbol = new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, lineSymbol, new dojo.Color([255, 255, 0, 0.25])); //设置面符号 graphic.setSymbol(PolygonSymbol); MyMap.graphics.add(graphic); &#125; &#125; 运行代码发现错误此时我们观察前台传给后台的参数123456Input:&#123; &quot;geometryType&quot;:&quot;esriGeometryPoint&quot;, &quot;features&quot;:[&#123;&quot;geometry&quot;:&#123;&quot;x&quot;:21264961.8441914,&quot;y&quot;:3997922.462940743,&quot;spatialReference&quot;:&#123;&quot;wkid&quot;:2334,&quot;latestWkid&quot;:2334&#125;&#125;&#125;], &quot;sr&quot;:&#123;&quot;wkid&quot;:2334,&quot;latestWkid&quot;:2334&#125; &#125;dis: &#123;&quot;distance&quot;:100,&quot;units&quot;:&quot;esriMeters&quot;&#125; 传给后台的参数和GP服务的参数对比，发现Input参数，缺少fields字段：修改错误我们给运行GP服务之前给Input参数添加上Fields字段:123456789101112131415161718on(dom.byId(&quot;buffer&quot;),&quot;click&quot;,function(e)&#123; //定义GP服务对象 var buffer = new Geoprocessor(&quot;http://localhost:6080/arcgis/rest/services/Test/MyBuffer/GPServer/Mybuffer&quot;); //构建GP服务参数 var gpParams=&#123;&#125;; //添加fields字段，为了和后台服务字段匹配 pointSet.fields=[]; //GP服务的Input参数 gpParams.Input=pointSet; //GP服务的dis参数 var dis=new LinearUnit(&#123; &quot;distance&quot;: 100, &quot;units&quot;: &quot;esriMeters&quot; &#125;); gpParams.dis=dis; //执行GP服务 buffer.execute(gpParams, showResult);&#125;); 全部代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111&lt;!DOCTYPE html&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;/&gt; &lt;title&gt;GP&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;http://localhost/arcgis_js_api/library/3.17/3.17/dijit/themes/tundra/tundra.css&quot;/&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;http://localhost/arcgis_js_api/library/3.17/3.17/esri/css/esri.css&quot; /&gt; &lt;script type=&quot;text/Javascript&quot; src=&quot;http://localhost/arcgis_js_api/library/3.17/3.17/init.js&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; .MapClass&#123; width:100%; height:600px; border:1px solid #000; &#125; &lt;/style&gt; &lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt; require([&quot;esri/map&quot;, &quot;esri/layers/ArcGISDynamicMapServiceLayer&quot;, &quot;dojo/dom&quot;, &quot;esri/tasks/Geoprocessor&quot;, &quot;esri/tasks/FeatureSet&quot;, &quot;esri/symbols/SimpleMarkerSymbol&quot;, &quot;esri/symbols/SimpleLineSymbol&quot;, &quot;esri/toolbars/draw&quot;, &quot;esri/symbols/SimpleFillSymbol&quot;, &quot;dojo/on&quot;,&quot;esri/graphic&quot;, &quot;esri/tasks/LinearUnit&quot;, &quot;dojo/domReady!&quot;], function (Map, ArcGISDynamicMapServiceLayer, dom, Geoprocessor, FeatureSet, SimpleMarkerSymbol, SimpleLineSymbol, Draw, SimpleFillSymbol,on,Graphic,LinearUnit) &#123; var MyMap = new Map(&quot;MyMapDiv&quot;); var layer = new ArcGISDynamicMapServiceLayer (&quot;http://localhost:6080/arcgis/rest/services/Test/ft/MapServer&quot;); MyMap.addLayer(layer); //定义点几何对象 var pointSet = new FeatureSet(); var psymbol = new SimpleMarkerSymbol(SimpleMarkerSymbol.STYLE_CROSS, 12, new SimpleLineSymbol(SimpleLineSymbol.STYLE_SOLID, new dojo.Color([255, 0, 0]), 2), new dojo.Color([0, 255, 0, 0.25])); on(dom.byId(&quot;Btn&quot;),&quot;click&quot;,function(e)&#123; //定义绘图对象 var toolBar= new Draw(MyMap, &#123; showTooltips: true &#125;); //激活绘图对象 toolBar.activate(Draw.POINT); on(toolBar, &quot;draw-complete&quot;, function(result)&#123; //获得绘图结束的点对象 var geometry = result.geometry; //根据点对象生成相应的图形 var graphic = new Graphic(geometry,psymbol); //将点对象存储在点几何中 pointSet.features.push(graphic); //将图形存放在地图中，然后得以显示 MyMap.graphics.add(graphic); &#125;); &#125;); on(dom.byId(&quot;buffer&quot;),&quot;click&quot;,function(e)&#123; //定义GP服务对象 var buffer = new Geoprocessor(&quot;http://localhost:6080/arcgis/rest/services/Test/MyBuffer/GPServer/Mybuffer&quot;); //构建GP服务参数 var gpParams=&#123;&#125;; //添加fields字段，为了和后台服务字段匹配 pointSet.fields=[]; //GP服务的Input参数 gpParams.Input=pointSet; //GP服务的dis参数 var dis=new LinearUnit(&#123; &quot;distance&quot;: 100, &quot;units&quot;: &quot;esriMeters&quot; &#125;); gpParams.dis=dis; //执行GP服务 buffer.execute(gpParams, showResult); &#125;); function showResult(results, messages) &#123; var features = results[0].value.features; for (var i = 0; i &lt; features.length; i++) &#123; var graphic = features[i]; //定义线符号 var lineSymbol=new SimpleLineSymbol(SimpleLineSymbol.STYLE_DASHDOT, new dojo.Color([255, 0, 0]), 1); //定义面符号 var PolygonSymbol = new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, lineSymbol, new dojo.Color([255, 255, 0, 0.25])); //设置面符号 graphic.setSymbol(PolygonSymbol); MyMap.graphics.add(graphic); &#125; &#125; &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;MyMapDiv&quot; class=&quot;MapClass&quot;&gt;&lt;/div&gt; &lt;input id=&quot;Btn&quot; type=&quot;button&quot; value=&quot;画点&quot; /&gt; &lt;input id=&quot;buffer&quot; type=&quot;button&quot; value=&quot;缓冲区分析&quot; /&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"ArcGIS","slug":"ArcGIS","permalink":"http://xdd7130.github.io/categories/ArcGIS/"}],"tags":[{"name":"ArcGIS API for JS","slug":"ArcGIS-API-for-JS","permalink":"http://xdd7130.github.io/tags/ArcGIS-API-for-JS/"},{"name":"webgis","slug":"webgis","permalink":"http://xdd7130.github.io/tags/webgis/"}]},{"title":"ArcGIS API For Javascript之渲染实现","slug":"ArcGIS-API-for-JS15","date":"2019-08-06T07:43:25.000Z","updated":"2022-11-02T11:15:20.493Z","comments":true,"path":"2019/08/06/ArcGIS-API-for-JS15/","link":"","permalink":"http://xdd7130.github.io/2019/08/06/ArcGIS-API-for-JS15/","excerpt":"","text":"在 GIS当中，总要时不时的制作几张专题图，制作专题图的过程中，不可避免的就要涉及到图层的渲染问题（即改变图层的颜色信息），渲染分为客户端渲染，服务器渲染，客户端渲染要求我们的服务必须是要素服务，或者是可以使用FeatureLayer接收的服务图层 需求首先我们查看一下数据（宿舍楼信息） 需求一（唯一值渲染）根据alias属性进行唯一值渲染 代码实现首先我们先将地图加载进来123var map = new esri.Map(&quot;MyMapDiv&quot;);var layer = new ArcGISDynamicMapServiceLayer(&quot;http://localhost:6080/arcgis/rest/services/my/fea/MapServer&quot;);map.addLayer(layer); 定义一个渲染按钮1&lt;button id=&quot;btn&quot;&gt;渲染&lt;/button&gt; 给按钮绑定相应的事件12345678910111213141516171819202122on(btn,&quot;click&quot;,function()&#123; //定义一个要素图层 var featureLayer = new FeatureLayer( &quot;http://localhost:6080/arcgis/rest/services/Test/ft/MapServer/1&quot;, &#123; mode:FeatureLayer.MODE_SNAPSHOT, outFields: [&quot;*&quot;] &#125;); //定义线符号 var lineSymbol=new SimpleLineSymbol(SimpleLineSymbol.STYLE_DASH, new Color([255, 0, 0]), 3); //定义面符号 var fill=new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, lineSymbol,new Color(&quot;#FFFFCC&quot;)); //定义唯一值渲染器，对字段alias进行渲染，fill是默认的渲染符号 var renderer = new UniqueValueRenderer(fill, &quot;alias&quot;); //设置渲染的方式 renderer.addValue(&quot;C区宿舍&quot;, new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, lineSymbol,new Color([0, 255, 0, 0.5]))); renderer.addValue(&quot;B区宿舍&quot;, new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, lineSymbol,new Color([0, 0, 255, 0.5]))); renderer.addValue(&quot;A区宿舍&quot;,new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, lineSymbol,new Color([255, 0, 255, 0.5]))); renderer.addValue(&quot;公共出口&quot;, new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, lineSymbol,new Color([255, 255, 255, 0.75]))); featureLayer.setRenderer(renderer); map.addLayer(featureLayer); &#125;) 全部代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;!DOCTYPE html&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;/&gt; &lt;title&gt;UniqueValueRenderer&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;http://localhost/arcgis_js_api/library/3.17/3.17/dijit/themes/tundra/tundra.css&quot;/&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;http://localhost/arcgis_js_api/library/3.17/3.17/esri/css/esri.css&quot; /&gt; &lt;script type=&quot;text/Javascript&quot; src=&quot;http://localhost/arcgis_js_api/library/3.17/3.17/init.js&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; .MapClass&#123; width:100%; height:600px; border:1px solid #000; &#125; &lt;/style&gt; &lt;script type=&quot;text/javascript&quot;&gt; require([&quot;esri/map&quot;, &quot;esri/layers/ArcGISDynamicMapServiceLayer&quot;, &quot;dojo/on&quot;, &quot;dojo/dom&quot;, &quot;dojo/colors&quot;, &quot;esri/symbols/SimpleFillSymbol&quot;, &quot;esri/layers/FeatureLayer&quot;, &quot;esri/symbols/SimpleLineSymbol&quot;, &quot;esri/renderers/UniqueValueRenderer&quot;, &quot;dojo/domReady!&quot;], function (Map, ArcGISDynamicMapServiceLayer,on,dom,Color,SimpleFillSymbol, FeatureLayer, SimpleLineSymbol,UniqueValueRenderer) &#123; var map = new esri.Map(&quot;MyMapDiv&quot;); var layer = new ArcGISDynamicMapServiceLayer(&quot;http://localhost:6080/arcgis/rest/services/Test/ft/MapServer&quot;); map.addLayer(layer); //获得id为btn的DOM元素 var btn=dom.byId(&quot;btn&quot;); //绑定相应的事件 on(btn,&quot;click&quot;,function()&#123; //定义一个要素图层 var featureLayer = new FeatureLayer( &quot;http://localhost:6080/arcgis/rest/services/Test/ft/MapServer/1&quot;, &#123; mode:FeatureLayer.MODE_SNAPSHOT, outFields: [&quot;*&quot;] &#125;); //定义线符号 var lineSymbol=new SimpleLineSymbol(SimpleLineSymbol.STYLE_DASH, new Color([255, 0, 0]), 3); //定义面符号 var fill=new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, lineSymbol,new Color(&quot;#FFFFCC&quot;)); //定义唯一值渲染器，对字段alias进行渲染，fill是默认的渲染符号 var renderer = new UniqueValueRenderer(fill, &quot;alias&quot;); //设置渲染的方式 renderer.addValue(&quot;C区宿舍&quot;, new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, lineSymbol,new Color([0, 255, 0, 0.5]))); renderer.addValue(&quot;B区宿舍&quot;, new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, lineSymbol,new Color([0, 0, 255, 0.5]))); renderer.addValue(&quot;A区宿舍&quot;,new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, lineSymbol,new Color([255, 0, 255, 0.5]))); renderer.addValue(&quot;公共出口&quot;, new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, lineSymbol,new Color([255, 255, 255, 0.75]))); featureLayer.setRenderer(renderer); map.addLayer(featureLayer); &#125;) &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;MyMapDiv&quot; class=&quot;MapClass&quot;&gt;&lt;/div&gt;&lt;button id=&quot;btn&quot;&gt;渲染&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; 运行结果之后： 需求二（分类渲染）根据面积字段实现分类渲染，由于代码只是修改了渲染器，所以直接将代码贴出来 全部代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;!DOCTYPE html&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;/&gt; &lt;title&gt;UniqueValueRenderer&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;http://localhost/arcgis_js_api/library/3.17/3.17/dijit/themes/tundra/tundra.css&quot;/&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;http://localhost/arcgis_js_api/library/3.17/3.17/esri/css/esri.css&quot; /&gt; &lt;script type=&quot;text/Javascript&quot; src=&quot;http://localhost/arcgis_js_api/library/3.17/3.17/init.js&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; .MapClass&#123; width:100%; height:600px; border:1px solid #000; &#125; &lt;/style&gt; &lt;script type=&quot;text/javascript&quot;&gt; require([&quot;esri/map&quot;, &quot;esri/layers/ArcGISDynamicMapServiceLayer&quot;, &quot;dojo/on&quot;, &quot;dojo/dom&quot;, &quot;dojo/colors&quot;, &quot;esri/symbols/SimpleFillSymbol&quot;, &quot;esri/layers/FeatureLayer&quot;, &quot;esri/symbols/SimpleLineSymbol&quot;, &quot;esri/renderers/ClassBreaksRenderer&quot;, &quot;dojo/domReady!&quot;], function (Map, ArcGISDynamicMapServiceLayer,on,dom,Color,SimpleFillSymbol, FeatureLayer, SimpleLineSymbol,ClassBreaksRenderer) &#123; var map = new esri.Map(&quot;MyMapDiv&quot;); var layer = new ArcGISDynamicMapServiceLayer(&quot;http://localhost:6080/arcgis/rest/services/Test/ft/MapServer&quot;); map.addLayer(layer); //获得id为btn的DOM元素 var btn=dom.byId(&quot;btn&quot;); //绑定相应的事件 on(btn,&quot;click&quot;,function()&#123; //定义一个要素图层 var featureLayer = new FeatureLayer( &quot;http://localhost:6080/arcgis/rest/services/Test/ft/MapServer/1&quot;, &#123; mode:FeatureLayer.MODE_SNAPSHOT, outFields: [&quot;*&quot;] &#125;); //定义线符号 var lineSymbol=new SimpleLineSymbol(SimpleLineSymbol.STYLE_DASH, new Color([255, 0, 0]), 3); //定义面符号 var fill=new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, lineSymbol,new Color(&quot;#FFFFCC&quot;)); //定义唯一值渲染器，对字段alias进行渲染，fill是默认的渲染符号 var renderer = new ClassBreaksRenderer(fill, &quot;OBJECTID&quot;); //设置渲染间隔 renderer.addBreak(0,20, new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, lineSymbol,new Color([0, 255, 0, 0.5]))); renderer.addBreak(20,30, new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, lineSymbol,new Color([0, 0, 255, 0.5]))); renderer.addBreak(30,40,new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, lineSymbol,new Color([255, 0, 255, 0.5]))); renderer.addBreak(40,60, new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, lineSymbol,new Color([255, 255, 255, 0.75]))); featureLayer.setRenderer(renderer); map.addLayer(featureLayer); &#125;) &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;MyMapDiv&quot; class=&quot;MapClass&quot;&gt;&lt;/div&gt;&lt;button id=&quot;btn&quot;&gt;渲染&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; 运行结果后： 需求三（服务器渲染）当数据量过大时，客户端渲染变显得有些慢了，此时可以使用服务器渲染，服务器渲染提供了两种渲染的方式：唯一值渲染，分类渲染，在此处我们用到的为分类渲染。 注意：服务器渲染不需要要素服务。 创建一个按钮（用于触发服务器渲染）1&lt;input type=&quot;button&quot; id=&quot;Btn&quot; value=&quot;服务器渲染&quot; /&gt; 给按钮绑定点击事件123456789101112131415161718192021222324252627282930313233343536on(btn,&quot;click&quot;,function(e)&#123; //定义线符号 var lineSymbol=new SimpleLineSymbol(SimpleLineSymbol.STYLE_DASH, new dojo.Color([255, 0, 0]), 3); //定义面符号 var fill=new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, lineSymbol,new dojo.Color(&quot;#FFFFCC&quot;)); //创建服务器渲染对象 var RenderAnalyst = new GenerateRendererTask(&quot;http://localhost:6080/arcgis/rest/services/Test/ft/MapServer/1&quot;); //创建服务器渲染参数对象 var params = new GenerateRendererParameters(); //创建颜色坡道对象 var colorRamp = new AlgorithmicColorRamp(); //颜色的起始位置 colorRamp.fromColor = dojo.colorFromHex(&quot;#998ec3&quot;); //颜色的终止位置 colorRamp.toColor = dojo.colorFromHex(&quot;#f1a340&quot;); //颜色的类型 colorRamp.algorithm = &quot;hsv&quot;; //告诉服务器我们需要什么样子的渲染器 var unidef = new ClassBreaksDefinition(); //分类的字段 unidef.classificationField = &quot;Shape.STArea()&quot;; //如何分类 unidef.classificationMethod=&quot;natural-breaks&quot;; //分为几类？ unidef.breakCount = 3; //默认的符号 unidef.baseSymbol=fill; //将自定义的颜色坡道告诉服务器 unidef.colorRamp=colorRamp; //给渲染参数对象赋值 params.classificationDefinition = unidef; //进行服务器渲染 RenderAnalyst.execute(params, showRender); &#125;); 处理服务器返回的结果123456789101112131415//处理服务器返回来的结果 function showRender(renderer) &#123; if (renderer != null) &#123; //定义要素图层，注意：这个地方我们用到并不是要素服务，而是地图服务 var featureLayer = new FeatureLayer(&quot;http://localhost:6080/arcgis/rest/services/Test/ft/MapServer/1&quot;,&#123; mode: FeatureLayer.MODE_SNAPSHOT, outFields: [&quot;*&quot;] &#125;); //赋予渲染器 featureLayer.setRenderer(renderer); featureLayer.refresh(); MyMap.addLayer(featureLayer); &#125; &#125; 全部代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107&lt;!DOCTYPE html&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;/&gt; &lt;title&gt;GenerateRendererTask&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;http://localhost/arcgis_js_api/library/3.17/3.17/dijit/themes/tundra/tundra.css&quot;/&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;http://localhost/arcgis_js_api/library/3.17/3.17/esri/css/esri.css&quot; /&gt; &lt;script type=&quot;text/Javascript&quot; src=&quot;http://localhost/arcgis_js_api/library/3.17/3.17/init.js&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; .MapClass&#123; width:100%; height:500px; border:1px solid #000; &#125; &lt;/style&gt; &lt;script type=&quot;text/javascript&quot;&gt; require([&quot;esri/map&quot;, &quot;esri/layers/ArcGISDynamicMapServiceLayer&quot;, &quot;dojo/dom&quot;, &quot;dojo/on&quot;, &quot;esri/tasks/GenerateRendererTask&quot;, &quot;esri/layers/FeatureLayer&quot;, &quot;esri/symbols/SimpleFillSymbol&quot;, &quot;esri/symbols/SimpleLineSymbol&quot;, &quot;esri/tasks/GenerateRendererParameters&quot;, &quot;esri/tasks/ClassBreaksDefinition&quot;, &quot;esri/tasks/AlgorithmicColorRamp&quot;, &quot;dojo/domReady!&quot;], function (Map, ArcGISDynamicMapServiceLayer, dom,on, GenerateRendererTask, FeatureLayer, SimpleFillSymbol, SimpleLineSymbol, GenerateRendererParameters, ClassBreaksDefinition, AlgorithmicColorRamp ) &#123; //服务器端渲染 var MyMap = new Map(&quot;MyMapDiv&quot;); var layer = new ArcGISDynamicMapServiceLayer (&quot;http://localhost:6080/arcgis/rest/services/Test/ft/MapServer/&quot;); MyMap.addLayer(layer) //获得id为Btn的DOM对象 var btn=dom.byId(&quot;Btn&quot;); //给btn绑定点击事件 on(btn,&quot;click&quot;,function(e)&#123; //定义线符号 var lineSymbol=new SimpleLineSymbol(SimpleLineSymbol.STYLE_DASH, new dojo.Color([255, 0, 0]), 3); //定义面符号 var fill=new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, lineSymbol,new dojo.Color(&quot;#FFFFCC&quot;)); //创建服务器渲染对象 var RenderAnalyst = new GenerateRendererTask(&quot;http://localhost:6080/arcgis/rest/services/Test/ft/MapServer/1&quot;); //创建服务器渲染参数对象 var params = new GenerateRendererParameters(); //创建颜色坡道对象 var colorRamp = new AlgorithmicColorRamp(); //颜色的起始位置 colorRamp.fromColor = dojo.colorFromHex(&quot;#998ec3&quot;); //颜色的终止位置 colorRamp.toColor = dojo.colorFromHex(&quot;#f1a340&quot;); //颜色的类型 colorRamp.algorithm = &quot;hsv&quot;; //告诉服务器我们需要什么样子的渲染器 var unidef = new ClassBreaksDefinition(); //分类的字段 unidef.classificationField = &quot;Shape.STArea()&quot;; //如何分类 unidef.classificationMethod=&quot;natural-breaks&quot;; //分为几类？ unidef.breakCount = 3; //默认的符号 unidef.baseSymbol=fill; //将自定义的颜色坡道告诉服务器 unidef.colorRamp=colorRamp; //给渲染参数对象赋值 params.classificationDefinition = unidef; //进行服务器渲染 RenderAnalyst.execute(params, showRender); &#125;); //处理服务器返回来的结果 function showRender(renderer) &#123; if (renderer != null) &#123; //定义要素图层，注意：这个地方我们用到并不是要素服务，而是地图服务 var featureLayer = new FeatureLayer(&quot;http://localhost:6080/arcgis/rest/services/Test/ft/MapServer/1&quot;,&#123; mode: FeatureLayer.MODE_SNAPSHOT, outFields: [&quot;*&quot;] &#125;); //赋予渲染器 featureLayer.setRenderer(renderer); featureLayer.refresh(); MyMap.addLayer(featureLayer); &#125; &#125; &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;MyMapDiv&quot; class=&quot;MapClass&quot;&gt;&lt;/div&gt;&lt;input type=&quot;button&quot; id=&quot;Btn&quot; value=&quot;服务器渲染&quot; /&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"ArcGIS","slug":"ArcGIS","permalink":"http://xdd7130.github.io/categories/ArcGIS/"}],"tags":[{"name":"ArcGIS API for JS","slug":"ArcGIS-API-for-JS","permalink":"http://xdd7130.github.io/tags/ArcGIS-API-for-JS/"},{"name":"webgis","slug":"webgis","permalink":"http://xdd7130.github.io/tags/webgis/"}]},{"title":"ArcGIS API For Javascript之查询功能","slug":"ArcGIS-API-for-JS14","date":"2019-08-06T07:26:24.000Z","updated":"2022-11-02T11:15:20.490Z","comments":true,"path":"2019/08/06/ArcGIS-API-for-JS14/","link":"","permalink":"http://xdd7130.github.io/2019/08/06/ArcGIS-API-for-JS14/","excerpt":"","text":"在ArcGIS API中查询功能是非常常用的，Esri给我们提供了三个类用于实现矢量数据查询功能。FindTask,QueryTask,IdentifyTask，他们之间的区别为： FindTask只能进行属性查询，QueryTask,IdentifyTask两个类既可以进行属性查询也可以进行空间查询。 对于QueryTask,IdentifyTask两个类，QueryTask只可应用于一个单独的图层，IdentifyTask可应用于地图服务和多个图层 QueryTask可以进行简单的统计功能。 需求利用FindTask实现简单的属性查询我们将name属性为J4的教学楼查询出来，在页面上显示J4是哪一个学院？（机电学院），并且将J4的楼高亮显示代码实现 在页面加入一个地图（略）在页面添加一个button和一个div（button用于属性查询，div用于显示楼层的名字）12&lt;input type=&quot;button&quot; value=&quot;属性查询&quot; id=&quot;Btn&quot;/&gt;&lt;div id=&quot;divShowResult&quot;&gt;&lt;/div&gt; 创建属性查询对象并给button绑定点击事件123456789101112131415161718//地图服务的URL var MapServer = &quot;http://localhost:6080/arcgis/rest/services/Test/MyService/MapServer&quot;; //创建属性查询对象 var findTask = new FindTask(MapServer); //创建属性查询参数 var findParams = new FindParameters(); on(dom.byId(&quot;Btn&quot;),&quot;click&quot;,function()&#123; //是否返回给我们几何信息 findParams.returnGeometry = true; //对哪一个图层进行属性查询 findParams.layerIds = [1]; //查询的字段 findParams.searchFields = [&quot;name&quot;]; //searchText和searchFields结合使用，即查询name=J4 findParams.searchText = &quot;J4&quot;; //执行查询对象 findTask.execute(findParams, ShowFindResult); &#125;) 处理属性查询返回给我们的数据12345678910111213141516171819202122232425262728293031323334function ShowFindResult(queryResult) &#123; //创建线符号 var lineSymbol=new SimpleLineSymbol(SimpleLineSymbol.STYLE_DASH, new dojo.Color([255, 0, 0]), 3); //创建面符号 var fill=new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, lineSymbol); if (queryResult.length == 0) &#123; dom.byId(&quot;divShowResult&quot;).innerHTML = &quot;&quot;; return; &#125; var htmls = &quot;&quot;; if (queryResult.length &gt;= 1) &#123; htmls = htmls + &quot;&lt;table style=\\&quot;width: 100%\\&quot;&gt;&quot;; htmls = htmls + &quot;&lt;tr&gt;&lt;td&gt;名称&lt;/td&gt;&lt;/tr&gt;&quot;; for (var i = 0; i &lt; queryResult.length; i++) &#123; //获得图形graphic var graphic = queryResult[i].feature; //赋予相应的符号 graphic.setSymbol(fill); //将graphic添加到地图中，从而实现高亮效果 map.graphics.add(graphic); //获得教学楼名称（此处是和shp属性表对应的） var ptName = graphic.attributes[&quot;alias&quot;]; if (i % 2 == 0) htmls = htmls + &quot;&lt;tr&gt;&quot;; else htmls = htmls + &quot;&lt;tr bgcolor=\\&quot;#F0F0F0\\&quot;&gt;&quot;; htmls = htmls + &quot;&lt;td&gt;&lt;a href=\\&quot;#\\&quot; \\&quot;&gt;&quot; + ptName + &quot;&lt;/a&gt;&lt;/td&gt;&quot;; htmls = htmls + &quot;&lt;/tr&gt;&quot;; &#125; htmls = htmls + &quot;&lt;/table&gt;&quot;; //将属性绑定在divShowResult上面 dom.byId(&quot;divShowResult&quot;).innerHTML = htmls; &#125; &#125; 全部代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697&lt;!DOCTYPE html&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;/&gt; &lt;title&gt;FindTask&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;http://localhost/arcgis_js_api/library/3.17/3.17/dijit/themes/tundra/tundra.css&quot;/&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;http://localhost/arcgis_js_api/library/3.17/3.17/esri/css/esri.css&quot; /&gt; &lt;script type=&quot;text/Javascript&quot; src=&quot;http://localhost/arcgis_js_api/library/3.17/3.17/init.js&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; .MapClass&#123; width:100%; height:600px; border:1px solid #000; &#125; &lt;/style&gt; &lt;script type=&quot;text/javascript&quot;&gt; require([&quot;esri/map&quot;, &quot;esri/layers/ArcGISDynamicMapServiceLayer&quot;, &quot;dojo/on&quot;, &quot;dojo/dom&quot;, &quot;esri/tasks/FindTask&quot;, &quot;esri/tasks/FindParameters&quot;, &quot;esri/symbols/SimpleLineSymbol&quot;, &quot;esri/symbols/SimpleFillSymbol&quot;, &quot;esri/graphic&quot;, &quot;dojo/domReady!&quot;], function (Map, ArcGISDynamicMapServiceLayer,on,dom, FindTask, FindParameters, SimpleLineSymbol,SimpleFillSymbol,Graphic) &#123; var map = new esri.Map(&quot;mapDiv&quot;); //地图服务的URL var MapServer = &quot;http://localhost:6080/arcgis/rest/services/Test/MyService/MapServer&quot;; var layer = new esri.layers.ArcGISDynamicMapServiceLayer(MapServer); map.addLayer(layer) //创建属性查询对象 var findTask = new FindTask(MapServer); //创建属性查询参数 var findParams = new FindParameters(); on(dom.byId(&quot;Btn&quot;),&quot;click&quot;,function()&#123; //是否返回给我们几何信息 findParams.returnGeometry = true; //对哪一个图层进行属性查询 findParams.layerIds = [1]; //查询的字段 findParams.searchFields = [&quot;name&quot;]; //searchText和searchFields结合使用，即查询name=J4 findParams.searchText = &quot;J4&quot;; //执行查询对象 findTask.execute(findParams, ShowFindResult); &#125;) function ShowFindResult(queryResult) &#123; //创建线符号 var lineSymbol=new SimpleLineSymbol(SimpleLineSymbol.STYLE_DASH, new dojo.Color([255, 0, 0]), 3); //创建面符号 var fill=new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, lineSymbol); if (queryResult.length == 0) &#123; dom.byId(&quot;divShowResult&quot;).innerHTML = &quot;&quot;; return; &#125; var htmls = &quot;&quot;; if (queryResult.length &gt;= 1) &#123; htmls = htmls + &quot;&lt;table style=\\&quot;width: 100%\\&quot;&gt;&quot;; htmls = htmls + &quot;&lt;tr&gt;&lt;td&gt;名称&lt;/td&gt;&lt;/tr&gt;&quot;; for (var i = 0; i &lt; queryResult.length; i++) &#123; //获得图形graphic var graphic = queryResult[i].feature; //赋予相应的符号 graphic.setSymbol(fill); //将graphic添加到地图中，从而实现高亮效果 map.graphics.add(graphic); //获得教学楼名称（此处是和shp属性表对应的） var ptName = graphic.attributes[&quot;alias&quot;]; if (i % 2 == 0) htmls = htmls + &quot;&lt;tr&gt;&quot;; else htmls = htmls + &quot;&lt;tr bgcolor=\\&quot;#F0F0F0\\&quot;&gt;&quot;; htmls = htmls + &quot;&lt;td&gt;&lt;a href=\\&quot;#\\&quot; \\&quot;&gt;&quot; + ptName + &quot;&lt;/a&gt;&lt;/td&gt;&quot;; htmls = htmls + &quot;&lt;/tr&gt;&quot;; &#125; htmls = htmls + &quot;&lt;/table&gt;&quot;; //将属性绑定在divShowResult上面 dom.byId(&quot;divShowResult&quot;).innerHTML = htmls; &#125; &#125; &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;mapDiv&quot; class=&quot;MapClass&quot;&gt;&lt;/div&gt; &lt;input type=&quot;button&quot; value=&quot;属性查询&quot; id=&quot;Btn&quot;/&gt; &lt;div id=&quot;divShowResult&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 运行之后的结果为： 利用QueryTask实现空间查询此时的的需求是：我们在地图上画一个图形，然后和图形相交的教学楼选择出来。12341.使用draw交互绘制几何形状2.根据geometry形状构建空间查询参数3.执行空间分析对象4.处理空间分析的结果 创建一个button和一个div（button用于激活绘图工具，div用户显示用户选择的教学楼的名称）12&lt;input type=&quot;button&quot; value=&quot;空间查询&quot; id=&quot;Btn&quot;/&gt;&lt;div id=&quot;divShowResult&quot;&gt;&lt;/div&gt; 给button绑定事件（激活绘图工具）1234567//定义一个绘图工具var toolBar = new Draw(map);//给button绑定事件on(dom.byId(&quot;Btn&quot;),&quot;click&quot;,function()&#123; //激活绘图工具，我要绘制一个面图形 toolBar.activate(Draw.POLYGON);&#125;) 给绘图工具绑定绘图完成事件，绘图完成执行queryGraphic函数,并将绘制的geometry传入函数1234567on(toolBar, &quot;draw-complete&quot;, function (result) &#123; //获得绘图得到的面 var geometry=result.geometry; //关闭绘图工具 toolBar.deactivate(); queryGraphic(geometry); &#125;); 编写queryGraphic函数123456789101112131415161718function queryGraphic(geometry) &#123; //创建查询对象，注意：服务的后面有一个编号，代表对那一个图层进行查询 var queryTask = new QueryTask(&quot;http://localhost:6080/arcgis/rest/services/Test/MyService/MapServer/1&quot;); //创建查询参数对象 var query = new Query(); //空间查询的几何对象 query.geometry = geometry; //服务器给我们返回的字段信息，*代表返回所有字段 query.outFields = [&quot;*&quot;]; //空间参考信息 query.outSpatialReference = map.spatialReference; //查询的标准，此处代表和geometry相交的图形都要返回 query.spatialRelationship = Query.SPATIAL_REL_INTERSECTS; //是否返回几何信息 query.returnGeometry = true; //执行空间查询 queryTask.execute(query, showQueryResult); &#125; 处理返回的结果信息12345678910111213141516171819202122232425262728293031323334function showQueryResult(queryResult) &#123; //创建线符号 var lineSymbol=new SimpleLineSymbol(SimpleLineSymbol.STYLE_DASH, new dojo.Color([255, 0, 0]), 3); //创建面符号 var fill=new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, lineSymbol); if (queryResult.features.length == 0) &#123; dom.byId(&quot;divShowResult&quot;).innerHTML = &quot;&quot;; return; &#125; var htmls = &quot;&quot;; if (queryResult.features.length &gt;= 1) &#123; htmls = htmls + &quot;&lt;table style=\\&quot;width: 100%\\&quot;&gt;&quot;; htmls = htmls + &quot;&lt;tr&gt;&lt;td&gt;名称&lt;/td&gt;&lt;/tr&gt;&quot;; for (var i = 0; i &lt; queryResult.features.length; i++) &#123; //得到graphic var graphic = queryResult.features[i]; //给图形赋予符号 graphic.setSymbol(fill); //添加到地图从而实现高亮效果 map.graphics.add(graphic); //获得教学楼的名称信息，此处应和shp的属性表对应 var ptName = graphic.attributes[&quot;alias&quot;]; if (i % 2 == 0) htmls = htmls + &quot;&lt;tr&gt;&quot;; else htmls = htmls + &quot;&lt;tr bgcolor=\\&quot;#F0F0F0\\&quot;&gt;&quot;; htmls = htmls + &quot;&lt;td&gt;&lt;a href=\\&quot;#\\&quot;\\&quot;&gt;&quot; + ptName + &quot;&lt;/a&gt;&lt;/td&gt;&quot;; htmls = htmls + &quot;&lt;/tr&gt;&quot;; &#125; htmls = htmls + &quot;&lt;/table&gt;&quot;; //将教学楼的名称信息和divShowResult绑定 dom.byId(&quot;divShowResult&quot;).innerHTML = htmls; &#125; &#125; 全部代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118&lt;!DOCTYPE html&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;/&gt; &lt;title&gt;QueryTask&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;http://localhost/arcgis_js_api/library/3.17/3.17/dijit/themes/tundra/tundra.css&quot;/&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;http://localhost/arcgis_js_api/library/3.17/3.17/esri/css/esri.css&quot; /&gt; &lt;script type=&quot;text/Javascript&quot; src=&quot;http://localhost/arcgis_js_api/library/3.17/3.17/init.js&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; .MapClass&#123; width:100%; height:600px; border:1px solid #000; &#125; &lt;/style&gt; &lt;script type=&quot;text/javascript&quot;&gt; require([&quot;esri/map&quot;, &quot;esri/layers/ArcGISDynamicMapServiceLayer&quot;, &quot;dojo/dom&quot;, &quot;dojo/on&quot;, &quot;esri/tasks/QueryTask&quot;, &quot;esri/toolbars/draw&quot;, &quot;esri/tasks/query&quot;, &quot;esri/symbols/SimpleLineSymbol&quot;, &quot;esri/symbols/SimpleFillSymbol&quot;, &quot;esri/graphic&quot;, &quot;dojo/domReady!&quot;], function (Map, ArcGISDynamicMapServiceLayer,dom, on, QueryTask, Draw, Query, SimpleLineSymbol,SimpleFillSymbol,Graphic) &#123; var map = new Map(&quot;mapdiv&quot;); var layer = new ArcGISDynamicMapServiceLayer (&quot;http://localhost:6080/arcgis/rest/services/Test/MyService/MapServer&quot;); map.addLayer(layer) //定义一个绘图工具 var toolBar = new Draw(map); //给button绑定事件 on(dom.byId(&quot;Btn&quot;),&quot;click&quot;,function()&#123; //激活绘图工具，我要绘制一个面图形 toolBar.activate(Draw.POLYGON); &#125;) on(toolBar, &quot;draw-complete&quot;, function (result) &#123; //获得绘图得到的面 var geometry=result.geometry; //关闭绘图工具 toolBar.deactivate(); queryGraphic(geometry); &#125;); function queryGraphic(geometry) &#123; //创建查询对象，注意：服务的后面有一个编号，代表对那一个图层进行查询 var queryTask = new QueryTask(&quot;http://localhost:6080/arcgis/rest/services/Test/MyService/MapServer/1&quot;); //创建查询参数对象 var query = new Query(); //空间查询的几何对象 query.geometry = geometry; //服务器给我们返回的字段信息，*代表返回所有字段 query.outFields = [&quot;*&quot;]; //空间参考信息 query.outSpatialReference = map.spatialReference; //查询的标准，此处代表和geometry相交的图形都要返回 query.spatialRelationship = Query.SPATIAL_REL_INTERSECTS; //是否返回几何信息 query.returnGeometry = true; //执行空间查询 queryTask.execute(query, showQueryResult); &#125; function showQueryResult(queryResult) &#123; //创建线符号 var lineSymbol=new SimpleLineSymbol(SimpleLineSymbol.STYLE_DASH, new dojo.Color([255, 0, 0]), 3); //创建面符号 var fill=new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, lineSymbol); if (queryResult.features.length == 0) &#123; dom.byId(&quot;divShowResult&quot;).innerHTML = &quot;&quot;; return; &#125; var htmls = &quot;&quot;; if (queryResult.features.length &gt;= 1) &#123; htmls = htmls + &quot;&lt;table style=\\&quot;width: 100%\\&quot;&gt;&quot;; htmls = htmls + &quot;&lt;tr&gt;&lt;td&gt;名称&lt;/td&gt;&lt;/tr&gt;&quot;; for (var i = 0; i &lt; queryResult.features.length; i++) &#123; //得到graphic var graphic = queryResult.features[i]; //给图形赋予符号 graphic.setSymbol(fill); //添加到地图从而实现高亮效果 map.graphics.add(graphic); //获得教学楼的名称信息，此处应和shp的属性表对应 var ptName = graphic.attributes[&quot;alias&quot;]; if (i % 2 == 0) htmls = htmls + &quot;&lt;tr&gt;&quot;; else htmls = htmls + &quot;&lt;tr bgcolor=\\&quot;#F0F0F0\\&quot;&gt;&quot;; htmls = htmls + &quot;&lt;td&gt;&lt;a href=\\&quot;#\\&quot;\\&quot;&gt;&quot; + ptName + &quot;&lt;/a&gt;&lt;/td&gt;&quot;; htmls = htmls + &quot;&lt;/tr&gt;&quot;; &#125; htmls = htmls + &quot;&lt;/table&gt;&quot;; //将教学楼的名称信息和divShowResult绑定 dom.byId(&quot;divShowResult&quot;).innerHTML = htmls; &#125; &#125; &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;mapdiv&quot; class=&quot;MapClass&quot;&gt;&lt;/div&gt; &lt;input type=&quot;button&quot; value=&quot;空间查询&quot; id=&quot;Btn&quot;/&gt; &lt;div id=&quot;divShowResult&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 运行之后的结果为： 利用QueryTask进行属性查询利用QueryTask进行属性查询和空间查询代码差不多。 #####全部代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104&lt;!DOCTYPE html&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;/&gt; &lt;title&gt;QueryTask&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;http://localhost/arcgis_js_api/library/3.17/3.17/dijit/themes/tundra/tundra.css&quot;/&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;http://localhost/arcgis_js_api/library/3.17/3.17/esri/css/esri.css&quot; /&gt; &lt;script type=&quot;text/Javascript&quot; src=&quot;http://localhost/arcgis_js_api/library/3.17/3.17/init.js&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; .MapClass&#123; width:100%; height:600px; border:1px solid #000; &#125; &lt;/style&gt; &lt;script type=&quot;text/javascript&quot;&gt; require([&quot;esri/map&quot;, &quot;esri/layers/ArcGISDynamicMapServiceLayer&quot;, &quot;dojo/dom&quot;, &quot;dojo/on&quot;, &quot;esri/tasks/QueryTask&quot;, &quot;esri/tasks/query&quot;, &quot;esri/symbols/SimpleLineSymbol&quot;, &quot;esri/symbols/SimpleFillSymbol&quot;, &quot;esri/graphic&quot;, &quot;dojo/domReady!&quot;], function (Map, ArcGISDynamicMapServiceLayer,dom, on, QueryTask, Query, SimpleLineSymbol,SimpleFillSymbol,Graphic) &#123; //根据div的id属性创建地图 var map = new Map(&quot;mapDiv&quot;); //定义一个动态地图服务 var layer = new ArcGISDynamicMapServiceLayer (&quot;http://localhost:6080/arcgis/rest/services/Test/MyService/MapServer&quot;); //将图层添加到地图 map.addLayer(layer) //给属性查询按钮添加click事件 on(dom.byId(&quot;Btn&quot;),&quot;click&quot;,function(e)&#123; //定义查询对象 var queryTask = new QueryTask (&quot;http://localhost:6080/arcgis/rest/services/Test/MyService/MapServer/1&quot;); //定义查询参数对象 var query = new Query(); //查询条件，类似于sql语句的where子句 query.where = &quot;name = &apos;J4&apos;&quot;;; //返回的字段信息：*代表返回全部字段 query.outFields = [&quot;*&quot;]; //是否返回几何形状 query.returnGeometry = true; //执行属性查询 queryTask.execute(query, showQueryResult); &#125;) //属性查询完成之后，用showQueryResult来处理返回的结果 function showQueryResult(queryResult) &#123; //创建线符号 var lineSymbol=new SimpleLineSymbol(SimpleLineSymbol.STYLE_DASH, new dojo.Color([255, 0, 0]), 3); //创建面符号 var fill=new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, lineSymbol); if (queryResult.features.length == 0) &#123; dom.byId(&quot;divShowResult&quot;).innerHTML = &quot;&quot;; return; &#125; var htmls = &quot;&quot;; if (queryResult.features.length &gt;= 1) &#123; htmls = htmls + &quot;&lt;table style=\\&quot;width: 100%\\&quot;&gt;&quot;; htmls = htmls + &quot;&lt;tr&gt;&lt;td&gt;名称&lt;/td&gt;&lt;/tr&gt;&quot;; for (var i = 0; i &lt; queryResult.features.length; i++) &#123; //获得图形graphic var graphic = queryResult.features[i]; //赋予相应的符号 graphic.setSymbol(fill); //将graphic添加到地图中，从而实现高亮效果 map.graphics.add(graphic); //获得教学楼名称（此处是和shp属性表对应的） var ptName = graphic.attributes[&quot;alias&quot;]; if (i % 2 == 0) htmls = htmls + &quot;&lt;tr&gt;&quot;; else htmls = htmls + &quot;&lt;tr bgcolor=\\&quot;#F0F0F0\\&quot;&gt;&quot;; htmls = htmls + &quot;&lt;td&gt;&lt;a href=\\&quot;#\\&quot; \\&quot;&gt;&quot; + ptName + &quot;&lt;/a&gt;&lt;/td&gt;&quot;; htmls = htmls + &quot;&lt;/tr&gt;&quot;; &#125; htmls = htmls + &quot;&lt;/table&gt;&quot;; //将属性绑定在divShowResult上面 dom.byId(&quot;divShowResult&quot;).innerHTML = htmls; &#125; &#125; &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;mapDiv&quot; class=&quot;MapClass&quot;&gt;&lt;/div&gt; &lt;input type=&quot;button&quot; value=&quot;属性查询&quot; id=&quot;Btn&quot;/&gt; &lt;div id=&quot;divShowResult&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 运行之后的结果： 利用IdentifyTask实现空间查询IdentifyTask的使用与QueryTask十分类似，唯一不同的是IdentifyTask可以作用于多个图层，而QueryTask是作用于一个图层的。 全部代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131&lt;!DOCTYPE html&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;/&gt; &lt;title&gt;WebGIS&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;http://localhost/arcgis_js_api/library/3.17/3.17/dijit/themes/tundra/tundra.css&quot;/&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;http://localhost/arcgis_js_api/library/3.17/3.17/esri/css/esri.css&quot; /&gt; &lt;script type=&quot;text/Javascript&quot; src=&quot;http://localhost/arcgis_js_api/library/3.17/3.17/init.js&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; .MapClass&#123; width:100%; height:600px; border:1px solid #000; &#125; &lt;/style&gt; &lt;script type=&quot;text/javascript&quot;&gt; require([&quot;esri/map&quot;, &quot;esri/layers/ArcGISDynamicMapServiceLayer&quot;, &quot;dojo/on&quot;, &quot;dojo/dom&quot;, &quot;esri/tasks/IdentifyTask&quot;, &quot;esri/tasks/IdentifyParameters&quot;, &quot;esri/toolbars/draw&quot;, &quot;esri/symbols/SimpleFillSymbol&quot;, &quot;esri/symbols/SimpleLineSymbol&quot;, &quot;esri/graphic&quot;, &quot;dojo/domReady!&quot;], function (Map, ArcGISDynamicMapServiceLayer, on, dom, IdentifyTask, IdentifyParameters, Draw, SimpleFillSymbol, SimpleLineSymbol, Graphic ) &#123; var map = new Map(&quot;mapDiv&quot;); //地图服务的url MapServer = &quot;http://localhost:6080/arcgis/rest/services/Test/MyService/MapServer&quot;; //定义一个动态地图服务 var layer = new ArcGISDynamicMapServiceLayer(MapServer); map.addLayer(layer) //定义绘图对象 var toolBar = new Draw(map); //绑定点击事件 on(dom.byId(&quot;Btn&quot;),&quot;click&quot;,function(e)&#123; //激活绘图工具：绘制面 toolBar.activate(esri.toolbars.Draw.POLYGON); &#125;) //给绘图工具绑定绘图完成事件 on(toolBar, &quot;draw-complete&quot;, function (result) &#123; //获得绘图得到的面 var geometry=result.geometry; //关闭绘图工具 toolBar.deactivate(); //执行空间查询 identifyQuery(geometry); &#125;); function identifyQuery(geometry) &#123; //定义空间查询对象，注意他的参数是整个地图服务，而不是单个图层 var identifyTask = new IdentifyTask(MapServer); //定义空间查询参数对象 var params = new IdentifyParameters(); //容差 params.tolerance = 5; //是否返回几何信息 params.returnGeometry = true; //空间查询的图层，此时是两个图层 params.layerIds = [1,3]; //空间查询的条件 params.layerOption = IdentifyParameters.LAYER_OPTION_ALL; params.width = map.width; params.height = map.height; //空间查询的几何对象 params.geometry = geometry; params.mapExtent = map.extent; //执行空间查询 identifyTask.execute(params,showQueryResult); &#125; //通过此函数处理查询之后的信息 function showQueryResult(idResults) &#123; //创建线符号 var lineSymbol=new SimpleLineSymbol(SimpleLineSymbol.STYLE_DASH, new dojo.Color([255, 0, 0]), 3); //创建面符号 var fill=new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, lineSymbol); if (idResults.length &gt; 0) &#123; var htmls = &quot;&lt;table style=\\&quot;width: 100%\\&quot;&gt;&quot;; htmls = htmls + &quot;&lt;tr bgcolor=\\&quot;#E0E0E0\\&quot;&gt;&lt;td&gt; 图层 &lt;/td&gt;&lt;td&gt; 名 称&lt;/td&gt;&lt;/tr&gt;&quot;; for (var i = 0; i &lt; idResults.length; i++) &#123; var result = idResults[i]; //获得图形graphic var graphic = result.feature; //设置图形的符号 graphic.setSymbol(fill); //获得教学楼的名称信息 var namevalue = result.feature.attributes.alias; if (i % 2 == 1) &#123; htmls = htmls + &quot;&lt;tr bgcolor=\\&quot;#E0E0E0\\&quot;&gt;&lt;td&gt;&quot; + result.layerName + &quot;&lt;/td&gt;&lt;td&gt;&quot; + namevalue + &quot;&lt;/td&gt;&lt;/tr&gt;&quot;; &#125; else &#123; htmls = htmls + &quot;&lt;tr&gt;&lt;td&gt;&quot; + result.layerName + &quot;&lt;/td&gt;&lt;td&gt;&quot; + namevalue + &quot;&lt;/td&gt;&lt;/tr&gt;&quot;; &#125; map.graphics.add(graphic); &#125; htmls = htmls + &quot;&lt;/table&gt;&quot;; document.getElementById(&quot;divShowResult&quot;).innerHTML = htmls; &#125; else &#123; document.getElementById(&quot;divShowResult&quot;).innerHTML = &quot;&quot;; &#125; &#125; &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;mapDiv&quot; class=&quot;MapClass&quot;&gt;&lt;/div&gt; &lt;input type=&quot;button&quot; value=&quot;空间查询---多边形&quot; id=&quot;Btn&quot;/&gt; &lt;div id=&quot;divShowResult&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 运行之后的结果：","categories":[{"name":"ArcGIS","slug":"ArcGIS","permalink":"http://xdd7130.github.io/categories/ArcGIS/"}],"tags":[{"name":"ArcGIS API for JS","slug":"ArcGIS-API-for-JS","permalink":"http://xdd7130.github.io/tags/ArcGIS-API-for-JS/"},{"name":"webgis","slug":"webgis","permalink":"http://xdd7130.github.io/tags/webgis/"}]},{"title":"ArcGIS API For Javascript之GraphicsLayer","slug":"ArcGIS-API-for-JS13","date":"2019-08-06T07:10:35.000Z","updated":"2022-11-02T11:15:20.489Z","comments":true,"path":"2019/08/06/ArcGIS-API-for-JS13/","link":"","permalink":"http://xdd7130.github.io/2019/08/06/ArcGIS-API-for-JS13/","excerpt":"","text":"在ArcGIS API中有一种图层叫做GraphicsLayer，GraphicsLayer是一种客户端图层，GraphicsLayer中的图形我们称作Graphic，它对应着 esri/graphic，一个Graphic对象由四部分组成：geometry,symbol,attribute,infoTemplate组成，Graphic对象在我们开发中用到的非常多。例如：利用Graphic实现图形的高亮显示等等。 需求根据具体坐标生成Graphic在我们的实际开发当中可能会存在这样的需求：根据坐标以及形状生成相应的图形然后在地图显示出来在上面说过一个Graphic由四部分组成，在需求中我们已经知道坐标形状，即已经知道了geometry,因此我们可以直接根据坐标生成相应的geometry，从而创建Graphic，然后添加到地图中来。 代码实现我们首先创建一个html页面，引入相应的文件将地图加载进来1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Graphic&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;http://localhost/arcgis_js_api/library/3.17/3.17/dijit/themes/tundra/tundra.css&quot;/&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;http://localhost/arcgis_js_api/library/3.17/3.17/esri/css/esri.css&quot; /&gt; &lt;script type=&quot;text/Javascript&quot; src=&quot;http://localhost/arcgis_js_api/library/3.17/3.17/init.js&quot;&gt;&lt;/script&gt; &lt;style&gt; .MapClass&#123; width:100%; height:500px; border:1px solid #000; &#125; &lt;/style&gt; &lt;script&gt; require([&quot;esri/map&quot;,&quot;esri/layers/ArcGISDynamicMapServiceLayer&quot;, &quot;dojo/domReady!&quot;],function(Map,ArcGISDynamicMapServiceLayer)&#123; var map = new Map(&quot;mapDiv&quot;); var layer = new ArcGISDynamicMapServiceLayer (&quot;http://localhost:6080/arcgis/rest/services/Test/MyService/MapServer&quot;); map.addLayer(layer); &#125;) &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;mapDiv&quot; class=&quot;MapClass&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 创建四个按钮，将四类不同的Graphic添加到GraphicsLayer中1234&lt;button&gt;添加点&lt;/button&gt;&lt;button&gt;添加线&lt;/button&gt;&lt;button&gt;添加面&lt;/button&gt;&lt;button&gt;添加圆&lt;/button&gt; 引入相应的模块，其中包括：dojo/on（用于绑定事件的模块）esri/symbols/SimpleMarkerSymbol（点符号类）esri/symbols/SimpleLineSymbol（线符号类）esri/symbols/SimpleFillSymbol（面符号类）esri/geometry/Point（点类）esri/geometry/Polyline（折线类）esri/geometry/Polygon（面类）esri/geometry/Circle（圆类）dojo/query（dojo的选择器，用于选择DOM元素）esri/graphic（图形类）esri/layers/GraphicsLayer（客户端图层类）为相应的按钮添加绑定事件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778//创建客户端图层var graphicsLayer=new GraphicsLayer();//将客户端图层添加到地图中map.addLayer(graphicsLayer);//通过query查询到button对象var btns=query(&quot;button&quot;);on(btns,&quot;click&quot;,function(event)&#123; //获得按钮的文本 var text=this.innerHTML; //定义线符号 var lineSymbol=new SimpleLineSymbol(SimpleLineSymbol.STYLE_DASH, new Color([255, 0, 0]), 3); //定义点符号l var pSymbol=new SimpleMarkerSymbol(SimpleMarkerSymbol.STYLE_CIRCLE,10, lineSymbol, new Color([255, 0, 0])); //定义面符号 var fill=SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, lineSymbol, new Color([255, 0, 0])); //声明一个类型和图形 var geometry; var graphic; //根据文本定义相应的geometry switch(text) &#123; case &quot;添加点&quot;: geometry=new Point(&#123; &quot;x&quot;:510706, &quot;y&quot;:3986100, &quot;spatialReference&quot;:map.spatialReference &#125;); graphic=new Graphic(geometry,pSymbol); break; case &quot;添加线&quot;: //点的坐标对 var paths=[]; paths[0]=[ [510326,3985702], [510994, 3985676], [511078, 3985903], [510433, 3985928] ]; geometry=new Polyline(&#123; &quot;paths&quot;:paths, &quot;spatialReference&quot;:map.spatialReference &#125;) graphic=new Graphic(geometry,lineSymbol); break; case &quot;添加面&quot;: //点的坐标对 var ring=[]; ring[0]=[ [510275, 3986100], [510508, 3986162], [510596, 3986032], [510271, 3985847], [510275, 3986100] ]; geometry=new Polygon(&#123; &quot;rings&quot;:ring, &quot;spatialReference&quot;:map.spatialReference &#125;); graphic=new Graphic(geometry,fill); break; case &quot;添加圆&quot;: //圆心 var p=new Point(&#123; &quot;x&quot;:510706, &quot;y&quot;:3986100, &quot;spatialReference&quot;:map.spatialReference &#125;); //半径 var r=20; geometry=new Circle(p,&#123; &quot;radius&quot;:r &#125;); graphic=new Graphic(geometry,fill); break; &#125; //将图形添加到图层中 graphicsLayer.add(graphic); 全部代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Graphic&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;http://localhost/arcgis_js_api/library/3.17/3.17/dijit/themes/tundra/tundra.css&quot;/&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;http://localhost/arcgis_js_api/library/3.17/3.17/esri/css/esri.css&quot; /&gt; &lt;script type=&quot;text/Javascript&quot; src=&quot;http://localhost/arcgis_js_api/library/3.17/3.17/init.js&quot;&gt;&lt;/script&gt; &lt;style&gt; .MapClass&#123; width:100%; height:500px; border:1px solid #000; &#125; &lt;/style&gt; &lt;script&gt; require([&quot;esri/map&quot;,&quot;esri/layers/ArcGISDynamicMapServiceLayer&quot;, &quot;esri/layers/GraphicsLayer&quot;, &quot;dojo/on&quot;,&quot;dojo/query&quot;,&quot;dojo/colors&quot;, &quot;esri/graphic&quot;,&quot;esri/symbols/SimpleMarkerSymbol&quot;, &quot;esri/symbols/SimpleLineSymbol&quot;, &quot;esri/symbols/SimpleFillSymbol&quot;, &quot;esri/geometry/Point&quot;, &quot;esri/geometry/Polyline&quot;,&quot;esri/geometry/Polygon&quot;, &quot;esri/geometry/Circle&quot;, &quot;dojo/domReady!&quot;], function(Map,ArcGISDynamicMapServiceLayer, GraphicsLayer,on,query,Color,Graphic, SimpleMarkerSymbol,SimpleLineSymbol, SimpleFillSymbol,Point,Polyline,Polygon,Circle)&#123; var map = new Map(&quot;mapDiv&quot;); var layer = new ArcGISDynamicMapServiceLayer (&quot;http://localhost:6080/arcgis/rest/services/Test/MyService/MapServer&quot;); map.addLayer(layer); //创建客户端图层 var graphicsLayer=new GraphicsLayer(); //将客户端图层添加到地图中 map.addLayer(graphicsLayer); //通过query查询到button对象 var btns=query(&quot;button&quot;); on(btns,&quot;click&quot;,function(event)&#123; //获得按钮的文本 var text=this.innerHTML; //定义线符号 var lineSymbol=new SimpleLineSymbol(SimpleLineSymbol.STYLE_DASH, new Color([255, 0, 0]), 3); //定义点符号l var pSymbol=new SimpleMarkerSymbol(SimpleMarkerSymbol.STYLE_CIRCLE,10, lineSymbol, new Color([255, 0, 0])); //定义面符号 var fill=SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, lineSymbol, new Color([255, 0, 0])); //声明一个类型和图形 var geometry; var graphic; //根据文本定义相应的geometry switch(text) &#123; case &quot;添加点&quot;: geometry=new Point(&#123; &quot;x&quot;:510706, &quot;y&quot;:3986100, &quot;spatialReference&quot;:map.spatialReference &#125;); graphic=new Graphic(geometry,pSymbol); break; case &quot;添加线&quot;: //点的坐标对 var paths=[]; paths[0]=[ [510326,3985702], [510994, 3985676], [511078, 3985903], [510433, 3985928] ]; geometry=new Polyline(&#123; &quot;paths&quot;:paths, &quot;spatialReference&quot;:map.spatialReference &#125;) graphic=new Graphic(geometry,lineSymbol); break; case &quot;添加面&quot;: //点的坐标对 var ring=[]; ring[0]=[ [510275, 3986100], [510508, 3986162], [510596, 3986032], [510271, 3985847], [510275, 3986100] ]; geometry=new Polygon(&#123; &quot;rings&quot;:ring, &quot;spatialReference&quot;:map.spatialReference &#125;); graphic=new Graphic(geometry,fill); break; case &quot;添加圆&quot;: //圆心 var p=new Point(&#123; &quot;x&quot;:510706, &quot;y&quot;:3986100, &quot;spatialReference&quot;:map.spatialReference &#125;); //半径 var r=20; geometry=new Circle(p,&#123; &quot;radius&quot;:r &#125;); graphic=new Graphic(geometry,fill); break; &#125; //将图形添加到图层中 graphicsLayer.add(graphic); &#125;) &#125;) &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;mapDiv&quot; class=&quot;MapClass&quot;&gt;&lt;/div&gt; &lt;button&gt;添加点&lt;/button&gt; &lt;button&gt;添加线&lt;/button&gt; &lt;button&gt;添加面&lt;/button&gt; &lt;button&gt;添加圆&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; 代码解释 我们利用dojo/query查询到所有的button对象，利用dojo/on模块给所有的button对象绑定事件。 在此例子中，有一个缺点：便是将点的坐标写死了，因此我们可以将点的坐标存放在一个json文件中，从而读取文件生成相应的点坐标 GraphicsLayer的属性查询在前面我们提到过，Graphic是可以存在属性的，在实际开发当中，有时我们需要将相应的属性查询出来，在此时我提供一个简单的方法，便是根据 GraphicsLayer的点击事件来查询Graphic的属性。 代码实现首先我们添加一系列带有属性的Graphic（此处我们只用点图形便可以）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//创建客户端图层 var graphicsLayer=new GraphicsLayer(); //将客户端图层添加到地图中 map.addLayer(graphicsLayer); //添加点图形的函数 function addGraphic() &#123; //定义线符号 var lineSymbol=new SimpleLineSymbol(SimpleLineSymbol.STYLE_DASH, new Color([255, 0, 0]), 3); //定义点符号l var pSymbol=new SimpleMarkerSymbol(SimpleMarkerSymbol.STYLE_CIRCLE,10, lineSymbol, new Color([255, 0, 0])); //声明形状 var geometry; //声明和图形 var graphic; //添加第一个点图形 geometry=new Point(&#123; &quot;x&quot;:510706, &quot;y&quot;:3986100, &quot;spatialReference&quot;:map.spatialReference, attributes:&#123; &quot;h&quot;:100 &#125; &#125;); graphic=new Graphic(geometry,pSymbol); graphicsLayer.add(graphic); //添加第二个点图形 geometry=new Point(&#123; &quot;x&quot;:510326, &quot;y&quot;:3985702, &quot;spatialReference&quot;:map.spatialReference, attributes:&#123; &quot;h&quot;:200 &#125; &#125;); graphic=new Graphic(geometry,pSymbol); graphicsLayer.add(graphic); //添加第三个点图形 geometry=new Point(&#123; &quot;x&quot;:510275, &quot;y&quot;:3986100, &quot;spatialReference&quot;:map.spatialReference, attributes:&#123; &quot;h&quot;:300 &#125; &#125;); graphic=new Graphic(geometry,pSymbol); graphicsLayer.add(graphic); &#125; //调用添加点图形的函数 addGraphic(); 给GraphicsLayer绑定相应的事件12345//绑定事件 on(graphicsLayer,&quot;click&quot;,function(event)&#123; var graphic=event.graphic; alert(graphic.attributes[&quot;h&quot;]); &#125;) 全部代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Graphic&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;http://localhost/arcgis_js_api/library/3.17/3.17/dijit/themes/tundra/tundra.css&quot;/&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;http://localhost/arcgis_js_api/library/3.17/3.17/esri/css/esri.css&quot; /&gt; &lt;script type=&quot;text/Javascript&quot; src=&quot;http://localhost/arcgis_js_api/library/3.17/3.17/init.js&quot;&gt;&lt;/script&gt; &lt;style&gt; .MapClass&#123; width:100%; height:500px; border:1px solid #000; &#125; &lt;/style&gt; &lt;script&gt; require([&quot;esri/map&quot;,&quot;esri/layers/ArcGISDynamicMapServiceLayer&quot;, &quot;esri/layers/GraphicsLayer&quot;, &quot;dojo/on&quot;,&quot;dojo/query&quot;,&quot;dojo/colors&quot;, &quot;esri/graphic&quot;,&quot;esri/symbols/SimpleMarkerSymbol&quot;, &quot;esri/symbols/SimpleLineSymbol&quot;, &quot;esri/geometry/Point&quot;, &quot;dojo/domReady!&quot;], function(Map,ArcGISDynamicMapServiceLayer, GraphicsLayer,on,query,Color,Graphic, SimpleMarkerSymbol,SimpleLineSymbol,Point)&#123; var map = new Map(&quot;mapDiv&quot;); var layer = new ArcGISDynamicMapServiceLayer (&quot;http://localhost:6080/arcgis/rest/services/Test/MyService/MapServer&quot;); map.addLayer(layer); //创建客户端图层 var graphicsLayer=new GraphicsLayer(); //将客户端图层添加到地图中 map.addLayer(graphicsLayer); //添加点图形的函数 function addGraphic() &#123; //定义线符号 var lineSymbol=new SimpleLineSymbol(SimpleLineSymbol.STYLE_DASH, new Color([255, 0, 0]), 3); //定义点符号l var pSymbol=new SimpleMarkerSymbol(SimpleMarkerSymbol.STYLE_CIRCLE,10, lineSymbol, new Color([255, 0, 0])); //声明形状 var geometry; //声明和图形 var graphic; //添加第一个点图形 geometry=new Point(&#123; &quot;x&quot;:510706, &quot;y&quot;:3986100, &quot;spatialReference&quot;:map.spatialReference, attributes:&#123; &quot;h&quot;:100 &#125; &#125;); graphic=new Graphic(geometry,pSymbol); graphicsLayer.add(graphic); //添加第二个点图形 geometry=new Point(&#123; &quot;x&quot;:510326, &quot;y&quot;:3985702, &quot;spatialReference&quot;:map.spatialReference, attributes:&#123; &quot;h&quot;:200 &#125; &#125;); graphic=new Graphic(geometry,pSymbol); graphicsLayer.add(graphic); //添加第三个点图形 geometry=new Point(&#123; &quot;x&quot;:510275, &quot;y&quot;:3986100, &quot;spatialReference&quot;:map.spatialReference, attributes:&#123; &quot;h&quot;:300 &#125; &#125;); graphic=new Graphic(geometry,pSymbol); graphicsLayer.add(graphic); &#125; //调用添加点图形的函数 addGraphic(); //绑定事件 on(graphicsLayer,&quot;click&quot;,function(event)&#123; var graphic=event.graphic; alert(graphic.attributes[&quot;h&quot;]); &#125;) &#125;) &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;mapDiv&quot; class=&quot;MapClass&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 代码解释 需要注意的是graphicsLayer的事件机制是针对于graphic图形的,也就是当图形graphic被点击时被触发，此时回调函数也会将那个图形被点击传给我们，从而得到图形的属性 有的同学不太喜欢新建一个graphicsLayer,而是使用map.graphics.add()方法添加一个图形graphic，其实原理是一样的，因为map本身有一个默认的graphicsLayer即：map.graphics返回的便是一个graphicsLayer对象 在此代码当中我们只是将获得到的属性信息alert了一下，在真实需求当中我们可能会利用相应的属性信息做很多的事情。 实现用户交互画图（Draw工具）在部分项目中，有这么一个需求：让用户在地图上自己绘制一个图形，然后将图形添加到地图当中，要实现这个功能我们需要借助esri提供给我们的工具条实现：esri/toolbars/draw，利用该工具条我们可以得到用户交互画出来的geometry,从而根据geometry生成相应的graphic，使用该工具的一般步骤为： 1.创建绘图对象2.激活绘图工具3.得到图形Geometry4.创建Graphic5.添加到地图 代码实现创建5个button（和第一个例子一样）创建绘图对象1var toolbar = new Draw(map, &#123; showTooltips: true &#125;); 给每一个button绑定相应的事件（激活绘图工具）123456789101112131415161718192021222324252627282930313233343536373839404142query(&quot;button&quot;).on(&quot;click&quot;,function(event)&#123; var value=this.innerHTML; switch(value)&#123; case &quot;绘制点&quot;:&#123; //激活绘图工具（画点） toolbar.activate(Draw.POINT, &#123; showTooltips:true &#125;) break; &#125; case &quot;绘制折线&quot;:&#123; //激活绘图工具（画折线） toolbar.activate(Draw.POLYLINE, &#123; showTooltips:true &#125;) break; &#125; case &quot;绘制面&quot;:&#123; //激活绘图工具（绘制面） toolbar.activate(Draw.POLYGON, &#123; showTooltips:true &#125;) break; &#125; case &quot;徒手线&quot;:&#123; //激活绘图工具（徒手线） toolbar.activate(Draw.FREEHAND_POLYLINE, &#123; showTooltips:true &#125;) break; &#125; case &quot;徒手面&quot;:&#123; //激活绘图工具（徒手面） toolbar.activate(Draw.FREEHAND_POLYGON, &#123; showTooltips:true &#125;) break; &#125; &#125; &#125;); 给绘图工具绑定绘图完成事件123456789101112131415161718192021222324on(toolbar,&quot;draw-complete&quot;, function (result) &#123; //获得几何形状 var geometry=result.geometry; //获得形状的类型 var type=geometry.type; //声明图形对象 var graphic; //通过几何形状的类型，创建不同的图形 switch (type) &#123; case &quot;point&quot;: graphic= new Graphic(geometry, marker); break; case &quot;polyline&quot;: graphic= new Graphic(geometry, lineSymbol); break; case &quot;polygon&quot;: graphic= new Graphic(geometry, fill); break; &#125; map.graphics.add(graphic); //关掉绘图工具 toolbar.deactivate();&#125;); 全部代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101&lt;!DOCTYPE html&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;/&gt; &lt;title&gt;WebGIS&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;http://localhost/arcgis_js_api/library/3.17/3.17/dijit/themes/tundra/tundra.css&quot;/&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;http://localhost/arcgis_js_api/library/3.17/3.17/esri/css/esri.css&quot; /&gt; &lt;script type=&quot;text/Javascript&quot; src=&quot;http://localhost/arcgis_js_api/library/3.17/3.17/init.js&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; .MapClass&#123; width:100%; height:500px; border:1px solid #000; &#125; &lt;/style&gt; &lt;script type=&quot;text/javascript&quot;&gt; require([&quot;esri/map&quot;,&quot;dojo/dom&quot;,&quot;dojo/on&quot;, &quot;esri/layers/ArcGISDynamicMapServiceLayer&quot;, &quot;dojo/query&quot;,&quot;esri/toolbars/draw&quot;, &quot;esri/symbols/SimpleLineSymbol&quot;,&quot;esri/graphic&quot;,&quot;esri/symbols/SimpleMarkerSymbol&quot;, &quot;esri/symbols/SimpleFillSymbol&quot;,&quot;dojo/domReady!&quot;], function (Map,dom,on, ArcGISDynamicMapServiceLayer,query, Draw, SimpleLineSymbol,Graphic,SimpleMarkerSymbol,SimpleFillSymbol) &#123; var map = new esri.Map(&quot;MyMapDiv&quot;); var layer = new ArcGISDynamicMapServiceLayer (&quot;http://localhost:6080/arcgis/rest/services/Test/MyService/MapServer&quot;); map.addLayer(layer) var toolbar = new Draw(map, &#123; showTooltips: true &#125;); var lineSymbol = new SimpleLineSymbol(SimpleLineSymbol.STYLE_DASH, new dojo.Color([255, 0, 0]), 3); var marker= new SimpleMarkerSymbol(SimpleMarkerSymbol.STYLE_CIRCLE,10, lineSymbol, new dojo.Color([255, 0, 0])); var fill= new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, lineSymbol, new dojo.Color([255, 0, 0])); on(toolbar,&quot;draw-complete&quot;, function (result) &#123; var geometry=result.geometry; var type=geometry.type; var graphic; switch (type) &#123; case &quot;point&quot;: graphic= new Graphic(geometry, marker); break; case &quot;polyline&quot;: graphic= new Graphic(geometry, lineSymbol); break; case &quot;polygon&quot;: graphic= new Graphic(geometry, fill); break; &#125; map.graphics.add(graphic); toolbar.deactivate(); &#125;); query(&quot;button&quot;).on(&quot;click&quot;,function(event)&#123; var value=this.innerHTML; switch(value)&#123; case &quot;绘制点&quot;:&#123; toolbar.activate(Draw.POINT, &#123; showTooltips:true &#125;) break; &#125; case &quot;绘制折线&quot;:&#123; toolbar.activate(Draw.POLYLINE, &#123; showTooltips:true &#125;) break; &#125; case &quot;绘制面&quot;:&#123; toolbar.activate(Draw.POLYGON, &#123; showTooltips:true &#125;) break; &#125; case &quot;徒手线&quot;:&#123; toolbar.activate(Draw.FREEHAND_POLYLINE, &#123; showTooltips:true &#125;) break; &#125; case &quot;徒手面&quot;:&#123; toolbar.activate(Draw.FREEHAND_POLYGON, &#123; showTooltips:true &#125;) break; &#125; &#125; &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;MyMapDiv&quot; class=&quot;MapClass&quot;&gt;&lt;/div&gt; &lt;button&gt;绘制点&lt;/button&gt; &lt;button&gt;绘制折线&lt;/button&gt; &lt;button&gt;绘制面&lt;/button&gt; &lt;button&gt;徒手线&lt;/button&gt; &lt;button&gt;徒手面&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; 代码解释 在使用绘图工具时，最主要的不同为：在激活绘图工具时的赋予的参数的不同。 graphic只是客户端图形，并不改变服务本身，如果想要改变服务本身的数据，需要使用要素服务，用到esri/toolbars/Edit工具。 总结通过上面几个需求得知，在生成graphic时，最主要是有用这个图形的几何信息，几何信息可以通过多方面获得，例如： 通过具体的坐标生成geometry（实现） 通过draw工具动态获得geometry（实现） 我们还可以通过map的点击事件获得点的geometry（可以尝试自己实现）。 一旦拥有了图形的几何信息，我们就可以直接创建graphic，从而添加到地图中来","categories":[{"name":"ArcGIS","slug":"ArcGIS","permalink":"http://xdd7130.github.io/categories/ArcGIS/"}],"tags":[{"name":"ArcGIS API for JS","slug":"ArcGIS-API-for-JS","permalink":"http://xdd7130.github.io/tags/ArcGIS-API-for-JS/"},{"name":"webgis","slug":"webgis","permalink":"http://xdd7130.github.io/tags/webgis/"}]},{"title":"ArcGIS API For Javascript之地图操作及小部件","slug":"ArcGIS-API-for-JS12","date":"2019-08-06T06:22:30.000Z","updated":"2022-11-02T11:15:20.489Z","comments":true,"path":"2019/08/06/ArcGIS-API-for-JS12/","link":"","permalink":"http://xdd7130.github.io/2019/08/06/ArcGIS-API-for-JS12/","excerpt":"","text":"开发一个GIS系统不可避免的就要涉及一些简单的地图操作，比如：拉框放大，拉框缩小，平移，全图等相关操作。除了这些基本的地图操作，Esri给我们提供的一些小部件也非常有用，其中几个重要的小部件有：鹰眼，书签，比例尺等等。在此篇博文中，主要介绍地图的基本操作和几个常用的小部件。 地图的基本操作在ArcGIS API中给我们提供了一个类叫做Navigation，通过这个类我们可以实现对地图的基本操作，Navigation类的用法可以分为以下几步： 创建Navigation对象 激活Navigation的相应状态 地图操作代码实现创建五个按钮12345&lt;button&gt;拉框放大&lt;/button&gt;&lt;button&gt;拉框缩小&lt;/button&gt;&lt;button&gt;平移&lt;/button&gt;&lt;button&gt;全图&lt;/button&gt;&lt;button&gt;漫游&lt;/button&gt; 添加地图（省略）给相应按钮添加绑定事1234567891011121314151617181920212223//给按钮添加绑定事件query(&quot;button&quot;).on(&quot;click&quot;,function(event)&#123; //获得按钮的文本信息 var value=this.innerHTML; switch(value)&#123; case &quot;平移&quot;: navToolbar.activate(Navigation.PAN); break; case &quot;拉框缩小&quot;: navToolbar.activate(Navigation.ZOOM_OUT); break; case &quot;拉框放大&quot;: navToolbar.activate(Navigation.ZOOM_IN); break; case &quot;全图&quot;: navToolbar.zoomToFullExtent(); break; case &quot;漫游&quot;: //默认是漫游操作 navToolbar.deactivate(); break; &#125;&#125;) 全部代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;!DOCTYPE html&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;/&gt; &lt;title&gt;Geometric _Network&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;http://localhost/arcgis_js_api/library/3.17/3.17/dijit/themes/tundra/tundra.css&quot;/&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;http://localhost/arcgis_js_api/library/3.17/3.17/esri/css/esri.css&quot; /&gt; &lt;script type=&quot;text/Javascript&quot; src=&quot;http://localhost/arcgis_js_api/library/3.17/3.17/init.js&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; .MapClass&#123; width:100%; height:600px; border:1px solid #000; &#125; &lt;/style&gt; &lt;script type=&quot;text/javascript&quot;&gt; require([&quot;esri/map&quot;, &quot;dojo/on&quot;, &quot;dojo/dom&quot;, &quot;esri/layers/ArcGISDynamicMapServiceLayer&quot;, &quot;dojo/query&quot;,&quot;esri/toolbars/navigation&quot;, &quot;dojo/domReady!&quot;], function (Map,on,dom, ArcGISDynamicMapServiceLayer,query,Navigation ) &#123; var map = new Map(&quot;mapDiv&quot;,&#123; logo: false &#125;); var layer = new ArcGISDynamicMapServiceLayer (&quot;http://localhost:6080/arcgis/rest/services/Test/MyService/MapServer&quot;); map.addLayer(layer) //创建地图操作对象 var navToolbar = new Navigation(map); //给按钮添加绑定事件 query(&quot;button&quot;).on(&quot;click&quot;,function(event)&#123; //获得按钮的文本信息 var value=this.innerHTML; switch(value)&#123; case &quot;平移&quot;: navToolbar.activate(Navigation.PAN); break; case &quot;拉框缩小&quot;: navToolbar.activate(Navigation.ZOOM_OUT); break; case &quot;拉框放大&quot;: navToolbar.activate(Navigation.ZOOM_IN); break; case &quot;全图&quot;: navToolbar.zoomToFullExtent(); break; case &quot;漫游&quot;: //默认是漫游操作 navToolbar.deactivate(); break; &#125; &#125;) &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body class=&quot;tundra&quot;&gt; &lt;div id=&quot;mapDiv&quot; class=&quot;MapClass&quot;&gt;&lt;/div&gt; &lt;button&gt;拉框放大&lt;/button&gt; &lt;button&gt;拉框缩小&lt;/button&gt; &lt;button&gt;平移&lt;/button&gt; &lt;button&gt;全图&lt;/button&gt; &lt;button&gt;漫游&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; API中的小部件关于API中提供的小部件有两种使用方式： 将小部件绑定在一个DOM元素上面 将小部件绑定在地图的上面 代码实现首先我们将小部件绑定在DOM元素上面我们创建一个DOM元素用于存放鹰眼控件1&lt;div id=&quot;view&quot;&gt;&lt;/div&gt; 创建小部件（并指定小部件绑定在哪一个DOM元素上面）12345//1.创建小部件对象var overviewMapDijit = new OverviewMap(&#123; map: map, visible: true, &#125;,dom.byId(&quot;view&quot;));//指定将小部件绑定在哪个DOM元素上面 启用小部件12//2.启用小部件overviewMapDijit.startup(); 代码结果（绑定在DOM） 全部代码（绑定在DOM）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt; &lt;!--The viewport meta tag is used to improve the presentation and behavior of the samples on iOS devices--&gt; &lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1, maximum-scale=1,user-scalable=no&quot;&gt; &lt;title&gt;Overview Map&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;http://localhost/arcgis_js_api/library/3.17/3.17/dijit/themes/tundra/tundra.css&quot;/&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;http://localhost/arcgis_js_api/library/3.17/3.17/esri/css/esri.css&quot; /&gt; &lt;script type=&quot;text/Javascript&quot; src=&quot;http://localhost/arcgis_js_api/library/3.17/3.17/init.js&quot;&gt;&lt;/script&gt; &lt;style&gt; .MapClass&#123; width:600px; height:400px; border:1px solid #000; &#125; #view &#123; height: 100px; width: 100px; border:1px solid red; border-right-color:blue; position:relative; left:800px; top:-200px; &#125; &lt;/style&gt; &lt;script&gt; require([&quot;esri/map&quot;,&quot;dojo/dom&quot;,&quot;esri/dijit/OverviewMap&quot;,&quot;dojo/domReady!&quot;], function ( Map,dom, OverviewMap)&#123; var map = new Map(&quot;mapDiv&quot;, &#123; basemap: &quot;topo&quot; &#125;); //1.创建小部件对象 var overviewMapDijit = new OverviewMap(&#123; map: map, visible: true, &#125;,dom.byId(&quot;view&quot;));//指定将小部件绑定在哪个DOM元素上面 //2.启用小部件 overviewMapDijit.startup(); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;mapDiv&quot; class=&quot;MapClass&quot;&gt;&lt;/div&gt; &lt;div id=&quot;view&quot;&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 补充（将小部件绑定在地图上）只需要在创建小部件的时候，修改一个属性即可123456var overviewMapDijit = new OverviewMap(&#123; //指定将小部件绑定在地图的哪一个位置：可以填写top-right,bottom-right,bottom-left 和top-left. attachTo: &quot;top-right&quot;, map: map, visible: true, &#125;); 运行结果（绑定在地图） 全部代码（绑定在地图）123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt; &lt;!--The viewport meta tag is used to improve the presentation and behavior of the samples on iOS devices--&gt; &lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1, maximum-scale=1,user-scalable=no&quot;&gt; &lt;title&gt;Overview Map&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;http://localhost/arcgis_js_api/library/3.17/3.17/dijit/themes/tundra/tundra.css&quot;/&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;http://localhost/arcgis_js_api/library/3.17/3.17/esri/css/esri.css&quot; /&gt; &lt;script type=&quot;text/Javascript&quot; src=&quot;http://localhost/arcgis_js_api/library/3.17/3.17/init.js&quot;&gt;&lt;/script&gt; &lt;style&gt; .MapClass&#123; width:100%; height:600; &#125; &lt;/style&gt; &lt;script&gt; require([&quot;esri/map&quot;,&quot;dojo/dom&quot;,&quot;esri/dijit/OverviewMap&quot;,&quot;dojo/domReady!&quot;], function ( Map,dom, OverviewMap)&#123; var map = new Map(&quot;mapDiv&quot;, &#123; basemap: &quot;topo&quot; &#125;); //1.创建小部件对象 var overviewMapDijit = new OverviewMap(&#123; //指定将小部件绑定在地图的哪一个位置：可以填写top-right,bottom-right,bottom-left 和top-left. attachTo: &quot;top-right&quot;, map: map, visible: true, &#125;); //2.启用小部件 overviewMapDijit.startup(); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;mapDiv&quot; class=&quot;MapClass&quot;&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"ArcGIS","slug":"ArcGIS","permalink":"http://xdd7130.github.io/categories/ArcGIS/"}],"tags":[{"name":"ArcGIS API for JS","slug":"ArcGIS-API-for-JS","permalink":"http://xdd7130.github.io/tags/ArcGIS-API-for-JS/"},{"name":"webgis","slug":"webgis","permalink":"http://xdd7130.github.io/tags/webgis/"}]},{"title":"ArcGIS API For Javascript之调用动态地图服务","slug":"ArcGIS-API-for-JS11","date":"2019-08-06T05:40:02.000Z","updated":"2022-11-02T11:15:20.481Z","comments":true,"path":"2019/08/06/ArcGIS-API-for-JS11/","link":"","permalink":"http://xdd7130.github.io/2019/08/06/ArcGIS-API-for-JS11/","excerpt":"","text":"主要记录一下在ArcGIS API如何调用自己发布的动态地图服务,利用动态地图服务我们可以完成哪一些需求等等。 调用动态地图服务 在ArcGIS API 中给我们提供了一个类叫做ArcGISDynamicMapServiceLayer利用这个类，我们可以获得发布的地图服务。调用动态地图服务一般只需要两步： 通过地图服务的URL创建一个ArcGISDynamicMapServiceLayer对象将动态地图服务的对象添加到地图容器中123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Hello World&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;http://localhost/arcgis_js_api/library/3.17/3.17/dijit/themes/tundra/tundra.css&quot;/&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;http://localhost/arcgis_js_api/library/3.17/3.17/esri/css/esri.css&quot; /&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;http://localhost/arcgis_js_api/library/3.17/3.17/init.js&quot;&gt;&lt;/script&gt; &lt;script&gt; require([&quot;esri/map&quot;,&quot;esri/layers/ArcGISDynamicMapServiceLayer&quot;, &quot;dojo/domReady!&quot;], function(Map,ArcGISDynamicMapServiceLayer)&#123; var map = new Map(&quot;mapDiv&quot;); //利用url创建一个动态地图服务对象 var layer=new ArcGISDynamicMapServiceLayer(&quot;http://localhost:6080/arcgis/rest/services/Test/MyServer/MapServer&quot;); //将地图服务对象添加到地图容器中 map.addLayer(layer); &#125;) &lt;/script&gt;&lt;/head&gt;&lt;body class=&quot;tundra&quot;&gt;&lt;div id=&quot;mapDiv&quot; style=&quot;width:900px; height:600px; border:1px solid #000;&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 在ArcGIS API中与ArcMap不同的是：一个服务图层相当于一组图层的集合（即多个图层） 需求在真实开发过程中，动态地图服务可以帮助我们完成很多的功能需求，例如： 根据需求隐藏服务中的某一个图层（动态地图服务可以实现，但是切片地图服务就不能实现） 通过属性查询地图服务中的信息 通过空间查询地图服务中的信息（包括点查询，线查询，面查询等等） 根据需求隐藏服务中的某一个图层我们发布的地图服务中有四个图层在本需求中,我们主要是给页面添加一个按钮，然后将地图服务中的road2隐藏,代码如下123456789101112require([&quot;esri/map&quot;,&quot;dojo/dom&quot;,&quot;dojo/on&quot;,&quot;esri/layers/ArcGISDynamicMapServiceLayer&quot;, &quot;dojo/domReady!&quot;], function(Map,dom,on,ArcGISDynamicMapServiceLayer)&#123; var map = new Map(&quot;mapDiv&quot;); var layer=new ArcGISDynamicMapServiceLayer(&quot;http://localhost:6080/arcgis/rest/services/Test/MyServer/MapServer&quot;); map.addLayer(layer); //给id为btn的按钮绑定click事件 on(dom.byId(&quot;btn&quot;),&quot;click&quot;,function() &#123; layer.setVisibleLayers([1,2,3]); &#125;) &#125;) 代码解释： 此代码功能的实现非常简单，只利用了setVisibleLayers方法，告诉服务，我要显示图层编号为1，2，3的图层。 在require中加载了一个新的模块dojo/dom模块，此模块给我们提供了一个方法dom.byId(id),我们可以通过id获得dom对象，类似于document.getElementById()方法。 在require中加载了一个新的模块dojo/on模块，在dojo中on是用来绑定事件的,on(target,type,listener)的第一个参数是给哪一个对象绑定事件，第二个参数是事件的类型，第三个是参数是回调函数。 通过属性查询地图服务中的信息根据属性查询出我们想要的要素图形，然后将该图形高亮（在本事例中查询教学楼的信息，例如根据教学楼的名称将该楼层成高亮）在实现这个功能的时候我们分几步开始考虑： 在网页上新建一个文本框 将文本框中的教学楼名称获取，并创建属性查询对象 将查询到的楼层信息（几何信息）获取，利用graphics高亮显示 创建一个文本框12Name:&lt;input class=&quot;nm&quot; type=&quot;text&quot;&gt;&lt;input type=&quot;button&quot; value=&quot;查询&quot;&gt; 将文本框中的教学楼名称获取，并创建属性查询对象1234567891011121314query(&quot;#btn&quot;).on(&quot;click&quot;,function()&#123; //获得教学楼的名称 var name=query(&quot;.nm&quot;)[0].value; //实例化查询参数 var findParams = new esri.tasks.FindParameters(); findParams.returnGeometry = true; findParams.layerIds = [3]; findParams.searchFields = [&quot;name&quot;]; findParams.searchText = name; //实例化查询对象 var FindTask = new esri.tasks.FindTask(&quot;http://localhost:6080/arcgis/rest/services/Test/MyServer/MapServer&quot;); //进行查询 FindTask.execute(findParams,ShowFindResult) &#125;) 将查询到的楼层信息（几何信息）获取，利用graphics高亮显示123456789101112131415161718192021function showFindResult(queryResult) &#123; if (queryResult.length == 0) &#123; alert(&quot;没有该元素&quot;); return; &#125; for (var i = 0; i &lt; queryResult.length; i++) &#123; //获得该图形的形状 var graphic = queryResult[i].feature; var geometry = graphic.geometry; //定义高亮图形的符号 //1.定义面的边界线符号 var outline= new SimpleLineSymbol(SimpleLineSymbol.STYLE_DASHDOT,new Color([255, 0, 0]), 1); //2.定义面符号 var PolygonSymbol = new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, outline,new Color([0, 255, 0, 1])); //创建客户端图形 var graphic = new Graphic(geometry, PolygonSymbol); //将客户端图形添加到map中 map.graphics.add(graphic); &#125; &#125; 完整代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Hello World&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;http://localhost/arcgis_js_api/library/3.17/3.17/dijit/themes/tundra/tundra.css&quot;/&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;http://localhost/arcgis_js_api/library/3.17/3.17/esri/css/esri.css&quot; /&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;http://localhost/arcgis_js_api/library/3.17/3.17/init.js&quot;&gt;&lt;/script&gt; &lt;script&gt; require([&quot;esri/map&quot;,&quot;dojo/query&quot;,&quot;dojo/on&quot;, &quot;esri/layers/ArcGISDynamicMapServiceLayer&quot;, &quot;esri/tasks/FindTask&quot;, &quot;esri/tasks/FindParameters&quot;, &quot;esri/symbols/SimpleLineSymbol&quot;, &quot;esri/symbols/SimpleFillSymbol&quot;, &quot;esri/Color&quot;, &quot;esri/graphic&quot;, &quot;dojo/domReady!&quot;], function(Map,query,on,ArcGISDynamicMapServiceLayer,FindTask,FindParameters,SimpleLineSymbol,SimpleFillSymbol,Color,Graphic)&#123; var map = new Map(&quot;mapDiv&quot;); var layer=new ArcGISDynamicMapServiceLayer(&quot;http://localhost:6080/arcgis/rest/services/Test/MyServer/MapServer&quot;); map.addLayer(layer); query(&quot;#btn&quot;).on(&quot;click&quot;,function()&#123; //获得教学楼的名称 var name=query(&quot;.nm&quot;)[0].value; //实例化查询参数 var findParams = new FindParameters(); findParams.returnGeometry = true; findParams.layerIds = [3]; findParams.searchFields = [&quot;name&quot;]; findParams.searchText = name; //实例化查询对象 var findTask = new FindTask(&quot;http://localhost:6080/arcgis/rest/services/Test/MyServer/MapServer&quot;); //进行查询 findTask.execute(findParams,showFindResult) &#125;); function showFindResult(queryResult) &#123; if (queryResult.length == 0) &#123; alert(&quot;没有该元素&quot;); return; &#125; for (var i = 0; i &lt; queryResult.length; i++) &#123; //获得该图形的形状 var feature= queryResult[i].feature; var geometry = feature.geometry; //定义高亮图形的符号 //1.定义面的边界线符号 var outline= new SimpleLineSymbol(SimpleLineSymbol.STYLE_DASHDOT,new Color([255, 0, 0]), 1); //2.定义面符号 var PolygonSymbol = new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, outline,new Color([0, 255, 0, 1])); //创建客户端图形 var graphic = new Graphic(geometry, PolygonSymbol); //将客户端图形添加到map中 map.graphics.add(graphic); &#125; &#125; &#125;) &lt;/script&gt;&lt;/head&gt;&lt;body class=&quot;tundra&quot;&gt;&lt;div id=&quot;mapDiv&quot; style=&quot;width:900px; height:580px; border:1px solid #000;&quot;&gt;&lt;/div&gt; Name:&lt;input class=&quot;nm&quot; type=&quot;text&quot;&gt; &lt;input id=&quot;btn&quot; type=&quot;button&quot; value=&quot;查询&quot;&gt;&lt;/body&gt;&lt;/html&gt; 代码解释 FindTask 是Esri提供的一个属性查询的类，他所对应的参数为：FindParameters，FindTask只能用于属性查询，不能用于空间查询 FindTask类中有一个方法叫做execute,execute的第一个参数是属性查询的参数，第二个参数是一个回调函数（即是一个异步函数），当服务器返回数据时，此函数才会被触发。 dojo/query是dojo提供的一个DOM选择器，他的功能非常强大，与JQuery中的$符一样强大，可以根据id选择query（”#id”）,也可以根据类名选择query（”.classname”），query方法还有很多强大的地方，具体可以参考官方文档 query(“#btn”).on()是dojo提供给我们第二种绑定事件的方式。 graphicesri提供给我们使用的客户端图层，利用graphic，我们可以完成很多操作，graphic具体的使用，将在Draw工具时说明。 通过空间查询地图服务中的信息相信大家都遇到过这种问题，当我点击地图时，将我点击的图形进行高亮显示，此时就用到了空间查询。为了实现该功能我们可以分为以下几步： 因为要点击地图，所以首先我们给地图绑定点击事件 获得点击的地图坐标(点坐标)，并创建空间查询参数对象 将教学楼与点相交的楼层查询出来，然后利用graphic进行高亮显示 给地图绑定点击事件1map.on(&quot;click&quot;,mapClick); 获得点击的地图坐标(点坐标)，并创建空间查询参数对象123456789101112131415function mapClick(e)&#123; //获得用户点击的地图坐标 var point=e.mapPoint; //实例化查询参数 query=new Query(); query.geometry = point; query.outFields = [&quot;*&quot;]; query.outSpatialReference = map.spatialReference; query.spatialRelationship = Query.SPATIAL_REL_INTERSECTS; query.returnGeometry = true; //实例化查询对象 var queryTask = new QueryTask(&quot;http://localhost:6080/arcgis/rest/services/Test/MyServer/MapServer/3&quot;); //进行查询 queryTask.execute(query,showFindResult) &#125; 将教学楼与点相交的楼层查询出来，然后利用graphic进行高亮显示123456789101112131415161718192021function showFindResult(queryResult) &#123; if (queryResult.features == 0) &#123; alert(&quot;没有该元素&quot;); return; &#125; for (var i = 0; i &lt; queryResult.features.length; i++) &#123; //获得该图形的形状 var feature = queryResult.features[i]; var geometry = feature.geometry; //定义高亮图形的符号 //1.定义面的边界线符号 var outline= new SimpleLineSymbol(SimpleLineSymbol.STYLE_DASHDOT,new Color([255, 0, 0]), 1); //2.定义面符号 var PolygonSymbol = new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, outline,new Color([0, 255, 0, 1])); //创建客户端图形 var graphic = new Graphic(geometry, PolygonSymbol); //将客户端图形添加到map中 map.graphics.add(graphic); &#125; &#125; 完整代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Hello World&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;http://localhost/arcgis_js_api/library/3.17/3.17/dijit/themes/tundra/tundra.css&quot;/&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;http://localhost/arcgis_js_api/library/3.17/3.17/esri/css/esri.css&quot; /&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;http://localhost/arcgis_js_api/library/3.17/3.17/init.js&quot;&gt;&lt;/script&gt; &lt;script&gt; require([&quot;esri/map&quot;,&quot;dojo/query&quot;,&quot;dojo/on&quot;, &quot;esri/layers/ArcGISDynamicMapServiceLayer&quot;, &quot;esri/tasks/QueryTask&quot;, &quot;esri/tasks/query&quot;, &quot;esri/symbols/SimpleLineSymbol&quot;, &quot;esri/symbols/SimpleFillSymbol&quot;, &quot;esri/Color&quot;, &quot;esri/graphic&quot;, &quot;dojo/domReady!&quot;], function(Map,query,on,ArcGISDynamicMapServiceLayer,QueryTask,Query,SimpleLineSymbol,SimpleFillSymbol,Color,Graphic)&#123; var map = new Map(&quot;mapDiv&quot;); var layer=new ArcGISDynamicMapServiceLayer(&quot;http://localhost:6080/arcgis/rest/services/Test/MyServer/MapServer&quot;); map.addLayer(layer); map.on(&quot;click&quot;,mapClick); function mapClick(e)&#123; //获得用户点击的地图坐标 var point=e.mapPoint; //实例化查询参数 query=new Query(); query.geometry = point; query.outFields = [&quot;*&quot;]; query.outSpatialReference = map.spatialReference; query.spatialRelationship = Query.SPATIAL_REL_INTERSECTS; query.returnGeometry = true; //实例化查询对象 var queryTask = new QueryTask(&quot;http://localhost:6080/arcgis/rest/services/Test/MyServer/MapServer/3&quot;); //进行查询 queryTask.execute(query,showFindResult) &#125; function showFindResult(queryResult) &#123; if (queryResult.features == 0) &#123; alert(&quot;没有该元素&quot;); return; &#125; for (var i = 0; i &lt; queryResult.features.length; i++) &#123; //获得该图形的形状 var feature = queryResult.features[i]; var geometry = feature.geometry; //定义高亮图形的符号 //1.定义面的边界线符号 var outline= new SimpleLineSymbol(SimpleLineSymbol.STYLE_DASHDOT,new Color([255, 0, 0]), 1); //2.定义面符号 var PolygonSymbol = new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, outline,new Color([0, 255, 0, 1])); //创建客户端图形 var graphic = new Graphic(geometry, PolygonSymbol); //将客户端图形添加到map中 map.graphics.add(graphic); &#125; &#125; &#125;) &lt;/script&gt;&lt;/head&gt;&lt;body class=&quot;tundra&quot;&gt;&lt;div id=&quot;mapDiv&quot; style=&quot;width:900px; height:580px; border:1px solid #000;&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 代码解释 QueryTask是esri提供给我们的一个工具类，可用于属性查询，也可用于空间查询，QueryTask只能作用于地图服务的某一个图层，而不能作用于一整个地图服务（IdentifyTask类可作用于一整个地图服务） Query类是QueryTask参数类，用于设定空间查询的参数。 QueryTask类中有一个方法叫做execute,execute的第一个参数是查询的参数，第二个参数是一个回调函数（即是一个异步函数），当服务器返回数据时，此函数才会被触发 补充绑定事件之后，在某些情况下也解除事件的绑定，下面提供几种方法解除事件绑定直接通过事件句柄解除（dojo新版本）1234//绑定事件var handle=map.on(&quot;click&quot;,mapClick);//解除事件handle.remove(); 通过老版本的方法解除1234//绑定事件var handle=map.on(&quot;click&quot;,mapClick);//解除事件dojo.disconnect(handle)","categories":[{"name":"ArcGIS","slug":"ArcGIS","permalink":"http://xdd7130.github.io/categories/ArcGIS/"}],"tags":[{"name":"ArcGIS API for JS","slug":"ArcGIS-API-for-JS","permalink":"http://xdd7130.github.io/tags/ArcGIS-API-for-JS/"},{"name":"webgis","slug":"webgis","permalink":"http://xdd7130.github.io/tags/webgis/"}]},{"title":"ArcGIS API For JavaScript之添加地图","slug":"ArcGIS-API-for-JS10","date":"2019-08-05T10:35:33.000Z","updated":"2022-11-02T11:15:20.480Z","comments":true,"path":"2019/08/05/ArcGIS-API-for-JS10/","link":"","permalink":"http://xdd7130.github.io/2019/08/05/ArcGIS-API-for-JS10/","excerpt":"","text":"在ArcGIS API For JS中，esri.Map类可以说是最重要的一个类，Map作为地图图层的容器，存放各种地图服务，同时Map具有一些常用的属性和事件可以帮助我们完成一些复杂的操作。接下来我们使用Map类开始我们的HelloWorld程序。 步骤首先新建一个Hello_World.html,同时引入我们的init.js,esri.css样式文件123&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;http://localhost/arcgis_js_api/library/3.17/3.17/dijit/themes/tundra/tundra.css&quot;/&gt;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;http://localhost/arcgis_js_api/library/3.17/3.17/esri/css/esri.css&quot; /&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;http://localhost/arcgis_js_api/library/3.17/3.17/init.js&quot;&gt;&lt;/script&gt; 创建一个div作为Map的容器(div容器必须设置宽高，不然地图不会显示)1&lt;div id=&quot;mapDiv&quot; style=&quot;width:900px; height:600px; border:1px solid #000;&quot;&gt;&lt;/div&gt; 创建Map容器，并且加入地图1234567require([&quot;esri/map&quot;,&quot;dojo/domReady!&quot;], function(Map)&#123; var myMap = new Map(&quot;mapDiv&quot;,&#123; basemap:&quot;topo&quot; &#125;); &#125;) 完整代码12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Hello World&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;http://localhost/arcgis_js_api/library/3.17/3.17/dijit/themes/tundra/tundra.css&quot;/&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;http://localhost/arcgis_js_api/library/3.17/3.17/esri/css/esri.css&quot; /&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;http://localhost/arcgis_js_api/library/3.17/3.17/init.js&quot;&gt;&lt;/script&gt; &lt;script&gt; require([&quot;esri/map&quot;,&quot;dojo/domReady!&quot;], function(Map)&#123; var myMap = new Map(&quot;mapDiv&quot;,&#123; basemap:&quot;topo&quot; &#125;); &#125;) &lt;/script&gt;&lt;/head&gt;&lt;body class=&quot;tundra&quot;&gt; &lt;div id=&quot;mapDiv&quot; style=&quot;width:900px; height:600px; border:1px solid #000;&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 代码讲解： require函数是dojo提供的一个全局函数，只要引入init.js便可使用，require函数支持AMD（异步模块定义，Asynchronous Module Definition）规范。 require函数有两个参数，第一个参数是一个数组（用于加载的模块），第二个参数是一个回调函数，注意前后加载的顺序一定要一致，例如require的第一个参数是esri.map,回调函数的第一个参数必须是Map require加载的第二个是dojo/domReady！,dojo/domReady！是一个插件（如果加载的模块以感叹号结尾，一般都为插件），此插件的作用是，当Html的dom加载完毕后在执行此函数，类似与window.onload事件。 Map类中有一个比较特殊的属性叫做basemap,在arcgis api中，esri自己定义了一些底图可直接供我们使用，这些底层的调用，我们可以根据制定basemap属性直接调用已经定义好的底图。esri给我们定义的底图有：streets ,satellite ,hybrid, topo, gray,dark-gray, oceans, national-geographic,terrain, osm, dark-gray-vector, gray-vector,streets-vector, streets-night-vector, streets-relief-vector, streets-navigation-vector,topo-vector.terrain, dark-gray, dark-gray-vector, gray-vector, streets-vector,streets-night-vector, streets-relief-vector, streets-navigation-vector , topo-vector,注意：要使用esri定义的底图属性basemap电脑必须联网。 需求在实际开发过程中，大家不喜欢logo的存在可以设置Map的属性logo：false在开发的过程中，对于地图的放大缩小，一般用代码来控制地图的放大，缩小，拉框放大，拉框缩小等等，所以一般隐藏地图自带的按钮，设置属性slider：false","categories":[{"name":"ArcGIS","slug":"ArcGIS","permalink":"http://xdd7130.github.io/categories/ArcGIS/"}],"tags":[{"name":"ArcGIS API for JS","slug":"ArcGIS-API-for-JS","permalink":"http://xdd7130.github.io/tags/ArcGIS-API-for-JS/"},{"name":"webgis","slug":"webgis","permalink":"http://xdd7130.github.io/tags/webgis/"}]},{"title":"ArcGIS API For JavaScript本地部署（IIS）","slug":"ArcGIS-API-for-JS09","date":"2019-08-05T10:23:24.000Z","updated":"2022-11-02T11:15:20.479Z","comments":true,"path":"2019/08/05/ArcGIS-API-for-JS09/","link":"","permalink":"http://xdd7130.github.io/2019/08/05/ArcGIS-API-for-JS09/","excerpt":"","text":"在windows系统，我们总是将ArcGIS API For JavaScript部署在IIS中，而不是部署在Tomcat中，其实在IIS中的配置和Tomcat中的配置ArcGIS API几乎没有什么差别，在本篇文章中，主要讲解在IIS中的配置ArcGIS API。部署本地环境在IIS主要分为以下几个步骤： 下载ArcGIS API For JavaScript函数库 安装IIS软件并进行配置 修改相应的js文件（2个文件） 将修改好的函数库复制到指定位置 测试ArcGIS API For JavaScript函数库是否安装成功。### 下载ArcGIS API For JavaScript函数库ArcGIS API For JavaScript下载的函数库如图所示:### 安装IIS软件并进行配置（略）### 修改相应的js文件（2个文件）修改 文件一（init.js）位置：arcgis_js_v317_api\\arcgis_js_api\\library\\3.17\\3.17\\init.js将[HOSTNAME_AND_PATH_TO_JSAPI]替换成localhost/arcgis_js_api/library/3.17/3.17/修改文件二（dojo.js）位置：arcgis_js_v317_api\\arcgis_js_api\\library\\3.17\\3.17\\dojo\\dojo.js将[HOSTNAME_AND_PATH_TO_JSAPI]替换成localhost/arcgis_js_api/library/3.17/3.17/","categories":[{"name":"ArcGIS","slug":"ArcGIS","permalink":"http://xdd7130.github.io/categories/ArcGIS/"}],"tags":[{"name":"ArcGIS API for JS","slug":"ArcGIS-API-for-JS","permalink":"http://xdd7130.github.io/tags/ArcGIS-API-for-JS/"},{"name":"webgis","slug":"webgis","permalink":"http://xdd7130.github.io/tags/webgis/"}]},{"title":"ArcGIS Server之发布地理编码服务","slug":"ArcGIS-API-for-JS08","date":"2019-08-05T09:48:35.000Z","updated":"2022-11-02T11:15:20.469Z","comments":true,"path":"2019/08/05/ArcGIS-API-for-JS08/","link":"","permalink":"http://xdd7130.github.io/2019/08/05/ArcGIS-API-for-JS08/","excerpt":"","text":"地理编码服务是指建立地理位置坐标与给定地址的过程，简单的说就是将一个地址的描述信息映射为地图上所对应的空间位置，地理编码服务是GIS中比较重要的一个功能。有的时候我们知道一个具体的地理坐标，却想知道这个地方的地址，就称作逆地理编码。 地理编码工具（Geocoding Tools）locator制作打开arcCatalog，找到工具箱ArcToolbox中的Geocoding Tools—Create Address Locator，界面如下： locator已经制作完成，接下来就是发布地理编码服务右键locator工具，选择Share as—Geocode Service，界面如下： 到这里，地理编码服务已经结束，最后是测试一下发布的服务是否成功（1）测试Find Address Candidates（2）测试Reverse Geocode","categories":[{"name":"ArcGIS","slug":"ArcGIS","permalink":"http://xdd7130.github.io/categories/ArcGIS/"}],"tags":[{"name":"ArcGIS API for JS","slug":"ArcGIS-API-for-JS","permalink":"http://xdd7130.github.io/tags/ArcGIS-API-for-JS/"},{"name":"webgis","slug":"webgis","permalink":"http://xdd7130.github.io/tags/webgis/"}]},{"title":"ArcGIS Server之发布网络分析服务","slug":"ArcGIS-API-for-JS07","date":"2019-08-05T09:30:10.000Z","updated":"2022-11-02T11:15:20.455Z","comments":true,"path":"2019/08/05/ArcGIS-API-for-JS07/","link":"","permalink":"http://xdd7130.github.io/2019/08/05/ArcGIS-API-for-JS07/","excerpt":"","text":"ArcGIS中网络分析分为 : 最短路径分析，服务区信息等等,如果想要在Web应用程序中使用网络分析服务，需要将我们的数据发布为网络分析服务 发布网络分析服务步骤如下： 1.利用ArcMap创建网络（如何创建网络，请查看ArcGIS帮助文档）2.将创建的地图进行符号化3.开启网络分析权限,添加分析图层4.修改属性，将其发布为网络服务 利用ArcMap创建网络创建的网络为： 将创建的地图进行符号化 开启网络分析权限并添加分析图层右击空白处Network Analyst网络分析工具条如果想要进行最短路径分析，进行新建路径注：将路径图层名称修改为英文名（此处改为Route）如果进行服务区分析，添加服务区图层 修改属性并将其发布为网络服务利用ArcMap链接ArcGIS Server ，并取名为mynet（存放在Test目录下），到达服务编辑器 查看服务是否发布成功从网站出输入网址http://localhost:6080/arcgis/rest/services,进入Test文件夹，可以看到我们刚刚发布的网络服务：","categories":[{"name":"ArcGIS","slug":"ArcGIS","permalink":"http://xdd7130.github.io/categories/ArcGIS/"}],"tags":[{"name":"ArcGIS API for JS","slug":"ArcGIS-API-for-JS","permalink":"http://xdd7130.github.io/tags/ArcGIS-API-for-JS/"},{"name":"webgis","slug":"webgis","permalink":"http://xdd7130.github.io/tags/webgis/"}]},{"title":"ArcGIS Server之发布结果地图服务","slug":"ArcGIS-API-for-JS06","date":"2019-08-05T09:09:57.000Z","updated":"2022-11-02T11:15:20.450Z","comments":true,"path":"2019/08/05/ArcGIS-API-for-JS06/","link":"","permalink":"http://xdd7130.github.io/2019/08/05/ArcGIS-API-for-JS06/","excerpt":"","text":"什么是结果地图服务？在ArcGIS中空间插值应该是我们经常用到的操作，但是在ArcGIS API却并没有提供相应的功能，上篇提到用GP服务来实现我们的功能，但是又有一个问题存在，插值之后的数据时栅格数据，在客户端我们应该怎么接受插值后的栅格数据呢，接受到的栅格信息我们又要怎么显示呢？此时就用到了我们的结果地图服务！！，所谓的结果地图服务，便是为了接受GP服务返回栅格数据的情况。 发布结果地图服务以空间插值为例，创建我们的结果地图服务，创建结果地图服务一般步骤如下： 1.创建模型2.修改我们的模型参数3.运行新创建的模型4.将运行后的结果进行渲染5.将模型发布为服务 创建空间插值模型注：参数一定要用英文 修改我们的模型参数将Input的类型改为要素集 运行新创建的模型运行我们的模型结果将运行后的结果进行渲染（很重要）注：很重要，如果选择的渲染方式不好，那么Web端返回的结果变不是很好。 将模型发布为服务点击地理处理-&gt;结果-&gt;右键模型共享为地理处理服务，服务名称为：Myking，存放在Test文件夹下面：修改服务参数为同步，并查看地图服务结果注：一定要勾选查看含地图服务的结果，很重要！！很重要！！很重要！！修改服务属性参数","categories":[{"name":"ArcGIS","slug":"ArcGIS","permalink":"http://xdd7130.github.io/categories/ArcGIS/"}],"tags":[{"name":"ArcGIS API for JS","slug":"ArcGIS-API-for-JS","permalink":"http://xdd7130.github.io/tags/ArcGIS-API-for-JS/"},{"name":"webgis","slug":"webgis","permalink":"http://xdd7130.github.io/tags/webgis/"}]},{"title":"ArcGIS Server之发布GP服务-返回矢量数据","slug":"ArcGIS-API-for-JS05","date":"2019-08-05T08:51:51.000Z","updated":"2022-11-02T11:15:20.442Z","comments":true,"path":"2019/08/05/ArcGIS-API-for-JS05/","link":"","permalink":"http://xdd7130.github.io/2019/08/05/ArcGIS-API-for-JS05/","excerpt":"","text":"什么是GP服务在WebGIS开发当中，虽然ArcGIS API提供给我们很多的接口，但是现实需求总是千变万化的，很多可能部分需求在我们的API中没有实现，而GP服务就弥补了这一个缺点，我们可以将ArcGIS中的GP工具发布为服务，提供给我们前端调用。 GP服务的分类GP服务从返回类型上可以分为： 返回矢量数据返回栅格数据 GP服务的参数对应在ArcGIS中，GP工具的参数和GP服务的参数是有一个对应参数的，在现实开发中，GP服务总是容易调用失败，这很有可能便是GP服务的参数不对应导致，因此：当我们发布GP服务时，参数便是我们高度重视的地方。以下是GP服务和GP工具参数对应表： 发布GP服务 在本实例中以缓冲区分析为例，发布一个GP服务。在ArcGIS10.1版本以后，发布GP服务之前需要将GP工具成功运行一次才可。发布GP服务的步骤大致分为以下几步： 1.创建GP模型2.修改模型参数，运行模型3.在结果窗口将运行成功的GP模型共享为服务 创建GP模型新建一个工具箱并创建一个新模型取名为Mybuffer右键Mybuffer点击编辑构建缓冲区模型 修改模型参数并运行模型修改Input变量的数据类型，改为输入要素集设置临时命名空间，右键空白处，点击模型属性，设置环境点击保存运行模型运行成功 在结果窗口将运行成功的GP模型共享为服务点击地理处理-&gt;结果打开结果窗口右键模型共享为地理处理服务","categories":[{"name":"ArcGIS","slug":"ArcGIS","permalink":"http://xdd7130.github.io/categories/ArcGIS/"}],"tags":[{"name":"ArcGIS API for JS","slug":"ArcGIS-API-for-JS","permalink":"http://xdd7130.github.io/tags/ArcGIS-API-for-JS/"},{"name":"webgis","slug":"webgis","permalink":"http://xdd7130.github.io/tags/webgis/"}]},{"title":"ArcGIS Server之发布影像服务","slug":"ArcGIS-API-for-JS04","date":"2019-08-05T08:25:58.000Z","updated":"2022-11-02T11:15:20.432Z","comments":true,"path":"2019/08/05/ArcGIS-API-for-JS04/","link":"","permalink":"http://xdd7130.github.io/2019/08/05/ArcGIS-API-for-JS04/","excerpt":"","text":"在实际开发过程中，为了满足用户不同的需求，Esri制定了各种不同的服务类型，每一种服务类型都有着自己的优点，同时特定的服务类型可以实现特性的功能，此篇博客便说一说影像服务 什么是影像服务？影像服务是将栅格数据和影像数据作为服务发布出去。此时客户端便可以对栅格数据的进行访问。例如：查看栅格的波段信息，查看栅格某一个像元的值等等。 什么数据可以发布为影像服务？发布影像服务，对于原始数据是有一定的要求的，当数据出现问题时，数据是不可以发布成功的，影像服务支持的数据主要有： 栅格数据集栅格图层镶嵌数据集镶嵌图层 发布影像服务发布影像服务非常简单，与地图服务不同的是：发布影像服务需要在ArcCatalog中进行，主要分步骤为： 1.在ArcCatalog找到我们要栅格数据集。2.通过ArcCatalog将我们的栅格共享为影像服务。3.查看服务是否发布成功 在ArcCatalog找到我们要栅格数据集发布的数据为数字高程模型（DEM） 将栅格数据共享为影像服务。到达服务编辑器，发布最简单的影像服务，直接点击发布即可-&gt;发布成功。 可能发生的错误（若服务发布成功，此处可略去）错误发生发布服务告知我服务定义失败 错误原因此错误发生的原因是你的DEM存放在某一个数据库中，导致数据在数据库中但是数据的格式有错误。例如，我想把dem导出来，却发现也不能导出，如图所示： 如何解决错误1.用ArcMap打开相应的Dem2.从ArcMap中将相应的栅格数据导出到硬盘上3.重新发布，即可成功。 用ArcMap打开相应的Dem 从ArcMap中将相应的栅格数据导出到硬盘上然后在catalog中重新发布。","categories":[{"name":"ArcGIS","slug":"ArcGIS","permalink":"http://xdd7130.github.io/categories/ArcGIS/"}],"tags":[{"name":"ArcGIS API for JS","slug":"ArcGIS-API-for-JS","permalink":"http://xdd7130.github.io/tags/ArcGIS-API-for-JS/"},{"name":"webgis","slug":"webgis","permalink":"http://xdd7130.github.io/tags/webgis/"}]},{"title":"ArcGIS Server之发布要素服务","slug":"ArcGIS-API-for-JS03","date":"2019-08-05T07:02:49.000Z","updated":"2022-11-02T11:15:20.425Z","comments":true,"path":"2019/08/05/ArcGIS-API-for-JS03/","link":"","permalink":"http://xdd7130.github.io/2019/08/05/ArcGIS-API-for-JS03/","excerpt":"","text":"什么是要素服务？要素服务可用来通过 Internet 提供要素，并提供显示要素时所要使用的符号系统。之后，客户端可执行查询操作以获取要素，并执行相应的编辑操作。要素服务提供了可用于提高客户端编辑体验的模板。此外，要素服务也可以对关系类和非空间表中的数据进行查询和编辑。简单的说，要素服务的数据是通过ArcSDE将数据储存在数据库中，当客户端请求要素服务时，服务器从数据库中读取数据生成图片，将图片返还给客户端。 要素服务的优点要素服务由于数据是储存在数据库中，所以实现的功能多。例如：客户端对服务中的要素进行增删改查，要素服务可以进行渲染，改变图层的颜色 要素服务数据要求1、所有数据必须来自单个 ArcSDE 地理数据库。2、所有数据必须通过地理数据库注册。3、如果要允许编辑数据，将需要 ArcSDE 数据的写入权限。使用 OS 身份验证时，必须向 ArcGIS 4、Server 帐户授予这些权限。5、支持版本化和未版本化数据；但是，如果需要使用服务编辑非简单类型（例如，网络边），则需要进行版本化。 发布要素服务发布要素服务一般分为以下几个步骤： 1、准备一个 ArcSDE 地理数据库（本实例准备的是SQL Server2008 R2数据库）2、创建一个数据库，并将其升级为地理数据库3、将数据存储到SDE数据库中，并设置数据的属性4、将SDE数据库注册到ArcGIS Server，并发布服务。 准备一个 ArcSDE 地理数据库1、安装SQL Server2008 R2数据库。2、若服务器安装了ArcGIS Desktop,那么便不需要单独安装ArcSDE，如果服务器没有安装ArcGIS Desktop，可以选择安装ArcGIS Desktop或者ArcSDE。3、若Linux操作系统，只能单独安装ArcSDE软件 创建一个数据库，并将其升级为地理数据库安装完成后 SQL Server2008 R2后，创建一个mydb数据库打开ArcCatalog连接mydb数据库 注：实例名便是数据库中的Server name（一定要对应），然后输入用户名，密码，最后选择我们刚刚创建的数据库mydb 点击确定，出现我们刚刚创建的数据库localhost. sde 将mydb数据库升级为地理数据库右击localhost. sde-&gt;启用地理数据库，弹出该画面注：授权文件为ArcGIS Server授权文件（ecp文件） 将数据存储到SDE数据库中，并设置数据的属性将数据导入ArcSDE数据库:右键localhost.sde-&gt;导入-&gt;要素类（多个） 将SDE数据库注册到ArcGIS Server，并发布服务。1.将要发布的图层拖拽到ArcMap2.点击文件-&gt;共享为-&gt;服务-&gt;发布服务3.注册数据库到ArcGIS Server 点击功能选择Feature Access点击分析出现错误：点击错误注册地里数据库","categories":[{"name":"ArcGIS","slug":"ArcGIS","permalink":"http://xdd7130.github.io/categories/ArcGIS/"}],"tags":[{"name":"ArcGIS API for JS","slug":"ArcGIS-API-for-JS","permalink":"http://xdd7130.github.io/tags/ArcGIS-API-for-JS/"},{"name":"webgis","slug":"webgis","permalink":"http://xdd7130.github.io/tags/webgis/"}]},{"title":"ArcGIS Server之发布切片地图服务","slug":"ArcGIS-API-for-JS02","date":"2019-08-05T02:17:48.000Z","updated":"2022-11-02T11:15:20.421Z","comments":true,"path":"2019/08/05/ArcGIS-API-for-JS02/","link":"","permalink":"http://xdd7130.github.io/2019/08/05/ArcGIS-API-for-JS02/","excerpt":"","text":"参考：https://github.com/CarpenterGISer/ArcGIS-API-For-Javacsript 什么是切片地图服务？切片地图服务又叫缓存第服务区，地图缓存是使地图和图像服务更快运行的一种非常有效的方法。创建地图缓存时，服务器会在若干个不同的比例级别上绘制整个地图并存储地图图像的副本。然后，服务器可在某人请求使用地图时分发这些图像。对于服务器来说，每次请求使用地图时，返回缓存的图像要比绘制地图快得多。 注：此图片的意思是，将同一幅地图按照不同的比例进行切片，得到相应的地图切片。 切片地图服务优点1、由于切片地图服务中的图片不需要服务器实时生成，本身存在服务器的硬盘上，所以大大提高了服务器的性能。2、图像的详细程度不会对服务器分发副本的速度造成显著影响。 切片地图服务缺点1、切片地图服务由于图片事先存在，所以该服务实现的功能有限，例如想隐藏服务中的某一个图层不可以实现。2、当缓存级别较高时，占用的硬盘存储量较大 利用ArcMap发布切片地图服务利用ArcMap发布切片地图服务与发布动态地图服务类似，主要分为以下几步： 1、用ArcMap打开我们想要发布为服务的数据2、符号化我们的数据（可选）3、利用ArcMap连接ArcGIS Server4、修改地图服务属性（修改为切片地图服务）5、发布服务到ArcGIS Server （步骤1-3略）步骤4:修改地图服务属性 点击缓存-&gt;使用缓存中的切片-&gt;切片方案-&gt;设置缓存级别 注： 这个地方设置的是5个级别，可以看到缓存的大小是小于5M，当设置的级别越多时，缓存的大小基本成几何倍数增长 查看硬盘缓存可以去ArcGIS Server站点目录查看缓存（我的站点是在：C:\\arcgisserver）进入C:\\arcgisserver\\directories\\arcgiscache可以看到我们刚刚发布的服务myTile 注：如果发布的不是切片地图服务。此目录下面是不会有相应的文件夹的 去ArcGIS REST Services Directory查看服务 在网址上输入http://localhost:6080/arcgis/rest/services进入服务目录，进入 Test文件夹可以看到我们发布的两个服务 注：可以看到myTile后面也加了一个（MapServer），可以得知切片地图服务也是属于地图服务的一种。","categories":[{"name":"ArcGIS","slug":"ArcGIS","permalink":"http://xdd7130.github.io/categories/ArcGIS/"}],"tags":[{"name":"ArcGIS API for JS","slug":"ArcGIS-API-for-JS","permalink":"http://xdd7130.github.io/tags/ArcGIS-API-for-JS/"},{"name":"webgis","slug":"webgis","permalink":"http://xdd7130.github.io/tags/webgis/"}]},{"title":"ArcGIS Server之发布动态地图服务","slug":"ArcGIS-API-for-JS01","date":"2019-08-05T02:17:48.000Z","updated":"2022-11-02T11:15:20.419Z","comments":true,"path":"2019/08/05/ArcGIS-API-for-JS01/","link":"","permalink":"http://xdd7130.github.io/2019/08/05/ArcGIS-API-for-JS01/","excerpt":"","text":"参考：https://github.com/CarpenterGISer/ArcGIS-API-For-Javacsript 在WebGIS开发过程中，我们所需要的数据不仅仅来自于ArcGIS online，有时候我们需要发布自己的数据服务,在这里主要说明一下如何利用ArcGIS Server发布自己的动态地图服务。 什么是地图服务?地图服务是一种利用 ArcGIS 使地图可通过 Web 进行访问的方法。我们首先在 ArcMap 中制作地图，然后将地图作为服务发布到 ArcGIS Server 站点上。这样，Internet 用户便可在 Web应用程序、ArcGIS for Desktop、ArcGIS Online 以及其他客户端应用程序中使用此地图服务。当地图服务发布成功后，我们可以通过网址（http://localhost:6080/arcgis/rest/services）来查看地图服务所支持的操作，地图服务所包含的数据，以及我们还可以通过网址来测试地图服务的功能 地图服务之动态地图服务我们常用的地图服务主要分为两种：动态地图服务，切片地图服务（也叫瓦片地图服务），地图服务其实可以理解为图层的集合，在本篇中主要说的是动态地图服务，动态地图服务的特点： 1、动态地图会在用户发出请求时进行绘制。2、地图服务具有允许客户端（例如 ArcGIS web API）动态更改每个图层的行为和外观。3、可以执行属性查询，空间查询等相关功能。 利用ArcMap发布动态地图服务利用ArcMap发布自己的服务，主要分为以下几步： 1、用ArcMap打开我们想要发布为服务的数据2、符号化我们的数据（可选）3、利用ArcMap连接ArcGIS Server发布服务 查看地图服务若发布到本地，打开并登录服务管理器（http://localhost:6080/arcgis/manager/）接下来我们可以使用ArcGIS API For js,来调用我们的服务做一些事情啦","categories":[{"name":"ArcGIS","slug":"ArcGIS","permalink":"http://xdd7130.github.io/categories/ArcGIS/"}],"tags":[{"name":"ArcGIS API for JS","slug":"ArcGIS-API-for-JS","permalink":"http://xdd7130.github.io/tags/ArcGIS-API-for-JS/"},{"name":"webgis","slug":"webgis","permalink":"http://xdd7130.github.io/tags/webgis/"}]},{"title":"ArcGIS","slug":"ArcGIS","date":"2019-07-13T13:35:13.000Z","updated":"2022-11-02T11:15:20.537Z","comments":true,"path":"2019/07/13/ArcGIS/","link":"","permalink":"http://xdd7130.github.io/2019/07/13/ArcGIS/","excerpt":"","text":"","categories":[{"name":"ArcGIS","slug":"ArcGIS","permalink":"http://xdd7130.github.io/categories/ArcGIS/"}],"tags":[{"name":"ArcGIS","slug":"ArcGIS","permalink":"http://xdd7130.github.io/tags/ArcGIS/"}]},{"title":"React","slug":"react","date":"2019-07-13T13:35:13.000Z","updated":"2022-11-02T11:15:20.671Z","comments":true,"path":"2019/07/13/react/","link":"","permalink":"http://xdd7130.github.io/2019/07/13/react/","excerpt":"","text":"","categories":[{"name":"React","slug":"React","permalink":"http://xdd7130.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://xdd7130.github.io/tags/React/"}]},{"title":"vue其他","slug":"vue其他","date":"2019-07-13T13:35:13.000Z","updated":"2022-11-02T11:15:20.678Z","comments":true,"path":"2019/07/13/vue其他/","link":"","permalink":"http://xdd7130.github.io/2019/07/13/vue其他/","excerpt":"","text":"IntellIJ IDEA 配置支持Vue参考：https://www.jianshu.com/p/01d832e028ea第一步：先安装vue插件:file –&gt; settings –&gt; plugins，然后什么都不用输入，直接点击Browse repositories… 紧接着左上方输入“vue”，点击搜索结果里的vue.js，右边会有绿色install按钮，安装成功后重启idea，这样idea就能识别.vue文件了。第二步：设置vue新建文件模板。 安装Element-uivue2.0 + element UI 中 el-table 数据导出Excel最近后台项目中有需要将游戏用户提交的返利数据信息导出为excel表的形式，所以对此功能进行了简单的总结： 安装相关依赖12主要是两个依赖:(xlsx 和 file-saver)npm install --save xlsx file-saver 对于这两个插件使用，github上边有更加详细的参考12https://github.com/SheetJS/js-xlsx](https://github.com/SheetJS/js-xlsx)https://github.com/eligrey/FileSaver.js](https://github.com/eligrey/FileSaver.js 在组件头里边引入插件(测试的时候，下边代码放到入口js文件main.js的时候没有效果，遗留问题，有待解决)（放到组件头里边能够实现效果）12import FileSaver from 'file-saver'import XLSX from 'xlsx' 在对应组件里边methods里边写一个方法（到处的时候进行调用）1234567891011121314exportExcel () &#123; /* generate workbook object from table */ let wb = XLSX.utils.table_to_book(document.querySelector('#rebateSetTable')); /* get binary string as output */ let wbout = XLSX.write(wb, &#123; bookType: 'xlsx', bookSST: true, type: 'array' &#125;); try &#123; FileSaver.saveAs(new Blob([wbout], &#123; type: 'application/octet-stream' &#125;), '用户提交返利表.xlsx'); &#125; catch (e) &#123; if (typeof console !== 'undefined') console.log(e, wbout) &#125; return wbout &#125;, 提示：上边方法中：XLSX.uitls.table_to_book( 放入的是table 的DOM 节点 ) ，sheetjs.xlsx 即为导出表格的名字，可修改！ 点击导出按钮执行 exportExcel 的方法即可 。123&lt;div class=\"export\"&gt; &lt;el-button @click=\"exportExcel\" style=\"margin-top: 2px;\" size=\"medium\" type=\"success\"&gt;导出&lt;/el-button&gt;&lt;/div&gt; vue element-ui自定义主题样式新建一个element-variables.scss，并在(main|app).js入口文件引入1234import Vue from 'vue'import Element from 'element-ui'import '@/styles/element-variables.scss' 在 element-variables.scss，修改你要的主题或组件预设的样式变量即可1234567891011121314/* 改变 主题/样式相关 变量 */$--color-primary: #1ABCB0;$--select-option-hover-background: #def1f2;$--select-option-selected-hover: #1abcb0;$--table-row-hover-background: #f2f2f2;$--table-header-color: #444;$--pagination-button-disabled-fill: transparent;$--pagination-fill: transparent;/* 改变 icon 字体路径变量，必需 */$--font-path: '~element-ui/lib/theme-chalk/fonts';/* 改变 路径变量，必需 */@import \"~element-ui/packages/theme-chalk/src/index\"; 默认 element-variables.scss 全部变量内容123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713/* Element Chalk Variables *//* Transition-------------------------- */$--all-transition: all .3s cubic-bezier(.645,.045,.355,1) !default;$--fade-transition: opacity 300ms cubic-bezier(0.23, 1, 0.32, 1) !default;$--fade-linear-transition: opacity 200ms linear !default;$--md-fade-transition: transform 300ms cubic-bezier(0.23, 1, 0.32, 1), opacity 300ms cubic-bezier(0.23, 1, 0.32, 1) !default;$--border-transition-base: border-color .2s cubic-bezier(.645,.045,.355,1) !default;$--color-transition-base: color .2s cubic-bezier(.645,.045,.355,1) !default;/* Colors-------------------------- */$--color-white: #fff !default;$--color-black: #000 !default;$--color-primary: #1ABCB0 !default;$--color-primary-light-1: mix($--color-white, $--color-primary, 10%) !default; /* 53a8ff */$--color-primary-light-2: mix($--color-white, $--color-primary, 20%) !default; /* 66b1ff */$--color-primary-light-3: mix($--color-white, $--color-primary, 30%) !default; /* 79bbff */$--color-primary-light-4: mix($--color-white, $--color-primary, 40%) !default; /* 8cc5ff */$--color-primary-light-5: mix($--color-white, $--color-primary, 50%) !default; /* a0cfff */$--color-primary-light-6: mix($--color-white, $--color-primary, 60%) !default; /* b3d8ff */$--color-primary-light-7: mix($--color-white, $--color-primary, 70%) !default; /* c6e2ff */$--color-primary-light-8: mix($--color-white, $--color-primary, 80%) !default; /* d9ecff */$--color-primary-light-9: mix($--color-white, $--color-primary, 90%) !default; /* ecf5ff */$--color-success: #67c23a !default;$--color-warning: #e6a23c !default;$--color-danger: #f56c6c !default;$--color-info: #909399 !default;$--color-success-light: mix($--color-white, $--color-success, 80%) !default;$--color-warning-light: mix($--color-white, $--color-warning, 80%) !default;$--color-danger-light: mix($--color-white, $--color-danger, 80%) !default;$--color-info-light: mix($--color-white, $--color-info, 80%) !default;$--color-success-lighter: mix($--color-white, $--color-success, 90%) !default;$--color-warning-lighter: mix($--color-white, $--color-warning, 90%) !default;$--color-danger-lighter: mix($--color-white, $--color-danger, 90%) !default;$--color-info-lighter: mix($--color-white, $--color-info, 90%) !default;$--color-text-primary: #303133 !default;$--color-text-regular: #606266 !default;$--color-text-secondary: #909399 !default;$--color-text-placeholder: #c0c4cc !default;/* Link-------------------------- */$--link-color: $--color-primary-light-2 !default;$--link-hover-color: $--color-primary !default;/* Background-------------------------- */$--background-color-base: #f5f7fa !default;/* Border-------------------------- */$--border-width-base: 1px !default;$--border-style-base: solid !default;$--border-color-base: #dcdfe6 !default;$--border-color-light: #e4e7ed !default;$--border-color-lighter: #ebeef5 !default;$--border-color-extra-light: #f2f6fc !default;$--border-color-hover: $--color-text-placeholder !default;$--border-base: $--border-width-base $--border-style-base $--border-color-base !default;$--border-radius-base: 4px !default;$--border-radius-small: 2px !default;$--border-radius-circle: 100% !default;/* Box-shadow-------------------------- */$--box-shadow-base: 0 2px 4px rgba(0, 0, 0, .12), 0 0 6px rgba(0, 0, 0, .04) !default;$--box-shadow-dark: 0 2px 4px rgba(0, 0, 0, .12), 0 0 6px rgba(0, 0, 0, .12) !default;$--box-shadow-light: 0 2px 12px 0 rgba(0, 0, 0, 0.1) !default;/* Fill-------------------------- */$--fill-base: $--color-white !default;/* Font-------------------------- */$--font-path: 'fonts' !default;$--font-size-base: 14px !default;$--font-size-small: 13px !default;$--font-size-large: 18px !default;$--font-color-disabled-base: #bbb !default;$--font-weight-primary: 500 !default;$--font-line-height-primary: 24px !default;/* Size-------------------------- */$--size-base: 14px !default;/* z-index-------------------------- */$--index-normal: 1 !default;$--index-top: 1000 !default;$--index-popper: 2000 !default;/* Disable base-------------------------- */$--disabled-fill-base: $--background-color-base !default;$--disabled-color-base: $--color-text-placeholder !default;$--disabled-border-base: $--border-color-light !default;/* Icon-------------------------- */$--icon-color: #666 !default;$--icon-color-base: $--color-info !default;/* Checkbox-------------------------- */$--checkbox-font-size: 14px !default;$--checkbox-font-weight: $--font-weight-primary !default;$--checkbox-color: $--color-text-regular !default;$--checkbox-input-height: 14px !default;$--checkbox-input-width: 14px !default;$--checkbox-input-border-radius: $--border-radius-small !default;$--checkbox-input-fill: $--color-white !default;$--checkbox-input-border: $--border-base !default;$--checkbox-input-border-color: $--border-color-base !default;$--checkbox-icon-color: $--color-white !default;$--checkbox-disabled-input-border-color: $--border-color-base !default;$--checkbox-disabled-input-fill: #edf2fc !default;$--checkbox-disabled-icon-color: $--color-text-placeholder !default;$--checkbox-disabled-checked-input-fill: $--border-color-extra-light !default;$--checkbox-disabled-checked-input-border-color: $--border-color-base !default;$--checkbox-disabled-checked-icon-color: $--color-text-placeholder !default;$--checkbox-checked-text-color: $--color-primary !default;$--checkbox-checked-input-border-color: $--color-primary !default;$--checkbox-checked-input-fill: $--color-primary !default;$--checkbox-checked-icon-color: $--fill-base !default;$--checkbox-input-border-color-hover: $--color-primary !default;$--checkbox-bordered-height: 40px !default;$--checkbox-bordered-padding: 9px 20px 9px 10px !default;$--checkbox-bordered-medium-padding: 7px 20px 7px 10px !default;$--checkbox-bordered-small-padding: 5px 15px 5px 10px !default;$--checkbox-bordered-mini-padding: 3px 15px 3px 10px !default;$--checkbox-bordered-medium-input-height: 14px !default;$--checkbox-bordered-medium-input-width: 14px !default;$--checkbox-bordered-medium-height: 36px !default;$--checkbox-bordered-small-input-height: 12px !default;$--checkbox-bordered-small-input-width: 12px !default;$--checkbox-bordered-small-height: 32px !default;$--checkbox-bordered-mini-input-height: 12px !default;$--checkbox-bordered-mini-input-width: 12px !default;$--checkbox-bordered-mini-height: 28px !default;$--checkbox-button-font-size: $--font-size-base !default;$--checkbox-button-checked-fill: $--color-primary !default;$--checkbox-button-checked-color: $--color-white !default;$--checkbox-button-checked-border-color: $--color-primary !default;/* Radio-------------------------- */$--radio-font-size: 14px !default;$--radio-font-weight: $--font-weight-primary !default;$--radio-color: $--color-text-regular !default;$--radio-input-height: 14px !default;$--radio-input-width: 14px !default;$--radio-input-border-radius: $--border-radius-circle !default;$--radio-input-fill: $--color-white !default;$--radio-input-border: $--border-base !default;$--radio-input-border-color: $--border-color-base !default;$--radio-icon-color: $--color-white !default;$--radio-disabled-input-border-color: $--disabled-border-base !default;$--radio-disabled-input-fill: $--disabled-fill-base !default;$--radio-disabled-icon-color: $--disabled-fill-base !default;$--radio-disabled-checked-input-border-color: $--disabled-border-base !default;$--radio-disabled-checked-input-fill: $--disabled-fill-base !default;$--radio-disabled-checked-icon-color: $--color-text-placeholder !default;$--radio-checked-text-color: $--color-primary !default;$--radio-checked-input-border-color: $--color-primary !default;$--radio-checked-input-fill: $--color-white !default;$--radio-checked-icon-color: $--color-primary !default;$--radio-input-border-color-hover: $--color-primary !default;$--radio-bordered-height: 40px !default;$--radio-bordered-padding: 12px 20px 0 10px !default;$--radio-bordered-medium-padding: 10px 20px 0 10px !default;$--radio-bordered-small-padding: 8px 15px 0 10px !default;$--radio-bordered-mini-padding: 6px 15px 0 10px !default;$--radio-bordered-medium-input-height: 14px !default;$--radio-bordered-medium-input-width: 14px !default;$--radio-bordered-medium-height: 36px !default;$--radio-bordered-small-input-height: 12px !default;$--radio-bordered-small-input-width: 12px !default;$--radio-bordered-small-height: 32px !default;$--radio-bordered-mini-input-height: 12px !default;$--radio-bordered-mini-input-width: 12px !default;$--radio-bordered-mini-height: 28px !default;$--radio-button-font-size: $--font-size-base !default;$--radio-button-checked-fill: $--color-primary !default;$--radio-button-checked-color: $--color-white !default;$--radio-button-checked-border-color: $--color-primary !default;$--radio-button-disabled-checked-fill: $--border-color-extra-light !default;/* Select-------------------------- */$--select-border-color-hover: $--border-color-hover !default;$--select-disabled-border: $--disabled-border-base !default;$--select-font-size: $--font-size-base !default;$--select-close-hover-color: $--color-text-secondary !default;$--select-input-color: $--color-text-placeholder !default;$--select-multiple-input-color: #666 !default;$--select-input-focus-background: $--color-primary !default;$--select-input-font-size: 14px !default;$--select-option-color: $--color-text-regular !default;$--select-option-disabled-color: $--color-text-placeholder !default;$--select-option-disabled-background: $--color-white !default;$--select-option-height: 34px !default;$--select-option-hover-background: $--border-color-base !default;$--select-option-selected: $--color-primary !default;$--select-option-selected-hover: red !default;$--select-group-color: $--color-info !default;$--select-group-height: 30px !default;$--select-group-font-size: 12px !default;$--select-dropdown-background: $--color-white !default;$--select-dropdown-shadow: $--box-shadow-light !default;$--select-dropdown-empty-color: #999 !default;$--select-dropdown-max-height: 274px !default;$--select-dropdown-padding: 6px 0 !default;$--select-dropdown-empty-padding: 10px 0 !default;$--select-dropdown-border: solid 1px $--border-color-light !default;/* Alert-------------------------- */$--alert-padding: 8px 16px !default;$--alert-border-radius: $--border-radius-base !default;$--alert-title-font-size: 13px !default;$--alert-description-font-size: 12px !default;$--alert-close-font-size: 12px !default;$--alert-close-customed-font-size: 13px !default;$--alert-success-color: $--color-success-lighter !default;$--alert-info-color: $--color-info-lighter !default;$--alert-warning-color: $--color-warning-lighter !default;$--alert-danger-color: $--color-danger-lighter !default;$--alert-icon-size: 16px !default;$--alert-icon-large-size: 28px !default;/* Message Box-------------------------- */$--msgbox-width: 420px !default;$--msgbox-border-radius: 4px !default;$--msgbox-font-size: $--font-size-large !default;$--msgbox-content-font-size: $--font-size-base !default;$--msgbox-content-color: $--color-text-regular !default;$--msgbox-error-font-size: 12px !default;$--msgbox-padding-primary: 15px !default;$--msgbox-success-color: $--color-success !default;$--msgbox-info-color: $--color-info !default;$--msgbox-warning-color: $--color-warning !default;$--msgbox-danger-color: $--color-danger !default;/* Message-------------------------- */$--message-shadow: $--box-shadow-base !default;$--message-min-width: 380px !default;$--message-background-color: #edf2fc !default;$--message-padding: 15px 15px 15px 20px !default;$--message-content-color: $--color-text-regular !default;$--message-close-color: $--color-text-placeholder !default;$--message-close-size: 16px !default;$--message-close-hover-color: $--color-text-secondary !default;$--message-success-color: $--color-success !default;$--message-info-color: $--color-info !default;$--message-warning-color: $--color-warning !default;$--message-danger-color: $--color-danger !default;/* Notification-------------------------- */$--notification-width: 330px !default;$--notification-padding: 14px 26px 14px 13px !default;$--notification-radius: 8px !default;$--notification-shadow: $--box-shadow-light !default;$--notification-border-color: $--border-color-lighter !default;$--notification-icon-size: 24px !default;$--notification-close-font-size: $--message-close-size !default;$--notification-group-margin: 13px !default;$--notification-font-size: $--font-size-base !default;$--notification-color: $--color-text-regular !default;$--notification-title-font-size: 16px !default;$--notification-title-color: $--color-text-primary !default;$--notification-close-color: $--color-text-secondary !default;$--notification-close-hover-color: $--color-text-regular !default;$--notification-success-color: $--color-success !default;$--notification-info-color: $--color-info !default;$--notification-warning-color: $--color-warning !default;$--notification-danger-color: $--color-danger !default;/* Input-------------------------- */$--input-font-size: $--font-size-base !default;$--input-color: $--color-text-regular !default;$--input-width: 140px !default;$--input-height: 40px !default;$--input-border: $--border-base !default;$--input-border-color: $--border-color-base !default;$--input-border-radius: $--border-radius-base !default;$--input-border-color-hover: $--border-color-hover !default;$--input-fill: $--color-white !default;$--input-fill-disabled: $--disabled-fill-base !default;$--input-color-disabled: $--font-color-disabled-base !default;$--input-icon-color: $--color-text-placeholder !default;$--input-placeholder-color: $--color-text-placeholder !default;$--input-max-width: 314px !default;$--input-hover-border: $--border-color-hover !default;$--input-clear-hover-color: $--color-text-secondary !default;$--input-focus-border: $--color-primary !default;$--input-focus-fill: $--color-white !default;$--input-disabled-fill: $--disabled-fill-base !default;$--input-disabled-border: $--disabled-border-base !default;$--input-disabled-color: $--disabled-color-base !default;$--input-disabled-placeholder-color: $--color-text-placeholder !default;$--input-medium-font-size: 14px !default;$--input-medium-height: 36px !default;$--input-small-font-size: 13px !default;$--input-small-height: 32px !default;$--input-mini-font-size: 12px !default;$--input-mini-height: 28px !default;/* Cascader-------------------------- */$--cascader-menu-fill: $--fill-base !default;$--cascader-menu-font-size: $--font-size-base !default;$--cascader-menu-radius: $--border-radius-base !default;$--cascader-menu-border: $--border-base !default;$--cascader-menu-border-color: $--border-color-base !default;$--cascader-menu-border-width: $--border-width-base !default;$--cascader-menu-color: $--color-text-regular !default;$--cascader-menu-option-color-active: $--color-text-secondary !default;$--cascader-menu-option-fill-active: rgba($--color-text-secondary, 0.12) !default;$--cascader-menu-option-color-hover: $--color-text-regular !default;$--cascader-menu-option-fill-hover: rgba($--color-text-primary, 0.06) !default;$--cascader-menu-option-color-disabled: #999 !default;$--cascader-menu-option-fill-disabled: rgba($--color-black, 0.06) !default;$--cascader-menu-option-empty-color: #666 !default;$--cascader-menu-group-color: #999 !default;$--cascader-menu-shadow: 0 1px 2px rgba($--color-black, 0.14), 0 0 3px rgba($--color-black, 0.14) !default;$--cascader-menu-option-pinyin-color: #999 !default;$--cascader-menu-submenu-shadow: 1px 1px 2px rgba($--color-black, 0.14), 1px 0 2px rgba($--color-black, 0.14) !default;/* Group-------------------------- */$--group-option-flex: 0 0 (1/5) * 100% !default;$--group-option-offset-bottom: 12px !default;$--group-option-fill-hover: rgba($--color-black, 0.06) !default;$--group-title-color: $--color-black !default;$--group-title-font-size: $--font-size-base !default;$--group-title-width: 66px !default;/* Tab-------------------------- */$--tab-font-size: $--font-size-base !default;$--tab-border-line: 1px solid #e4e4e4 !default;$--tab-header-color-active: $--color-text-secondary !default;$--tab-header-color-hover: $--color-text-regular !default;$--tab-header-color: $--color-text-regular !default;$--tab-header-fill-active: rgba($--color-black, 0.06) !default;$--tab-header-fill-hover: rgba($--color-black, 0.06) !default;$--tab-vertical-header-width: 90px !default;$--tab-vertical-header-count-color: $--color-white !default;$--tab-vertical-header-count-fill: $--color-text-secondary !default;/* Button-------------------------- */$--button-font-size: 14px !default;$--button-font-weight: $--font-weight-primary !default;$--button-border-radius: $--border-radius-base !default;$--button-padding-vertical: 12px !default;$--button-padding-horizontal: 20px !default;$--button-medium-font-size: 14px !default;$--button-medium-border-radius: $--border-radius-base !default;$--button-medium-padding-vertical: 10px !default;$--button-medium-padding-horizontal: 20px !default;$--button-small-font-size: 12px !default;$--button-small-border-radius: #&#123;$--border-radius-base - 1&#125; !default;$--button-small-padding-vertical: 9px !default;$--button-small-padding-horizontal: 15px !default;$--button-mini-font-size: 12px !default;$--button-mini-border-radius: #&#123;$--border-radius-base - 1&#125; !default;$--button-mini-padding-vertical: 7px !default;$--button-mini-padding-horizontal: 15px !default;$--button-default-color: $--color-text-regular !default;$--button-default-fill: $--color-white !default;$--button-default-border: $--border-color-base !default;$--button-disabled-color: $--color-text-placeholder !default;$--button-disabled-fill: $--color-white !default;$--button-disabled-border: $--border-color-lighter !default;$--button-primary-border: $--color-primary !default;$--button-primary-color: $--color-white !default;$--button-primary-fill: $--color-primary !default;$--button-success-border: $--color-success !default;$--button-success-color: $--color-white !default;$--button-success-fill: $--color-success !default;$--button-warning-border: $--color-warning !default;$--button-warning-color: $--color-white !default;$--button-warning-fill: $--color-warning !default;$--button-danger-border: $--color-danger !default;$--button-danger-color: $--color-white !default;$--button-danger-fill: $--color-danger !default;$--button-info-border: $--color-info !default;$--button-info-color: $--color-white !default;$--button-info-fill: $--color-info !default;$--button-hover-tint-percent: 20% !default;$--button-active-shade-percent: 10% !default;/* cascader-------------------------- */$--cascader-height: 200px !default;/* Switch-------------------------- */$--switch-on-color: $--color-primary !default;$--switch-off-color: $--border-color-base !default;$--switch-disabled-color: $--border-color-lighter !default;$--switch-disabled-text-color: $--color-text-placeholder !default;$--switch-font-size: $--font-size-base !default;$--switch-core-border-radius: 10px !default;$--switch-width: 40px !default;$--switch-height: 20px !default;$--switch-button-size: 16px !default;/* Dialog-------------------------- */$--dialog-background-color: $--color-primary-light-4 !default;$--dialog-box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3) !default;$--dialog-close-hover-color: $--color-primary !default;$--dialog-title-font-size: $--font-size-large !default;$--dialog-font-size: 14px !default;$--dialog-line-height: $--font-line-height-primary !default;$--dialog-padding-primary: 20px !default;/* Table-------------------------- */$--table-border-color: $--border-color-lighter !default;$--table-border: 1px solid $--table-border-color !default;$--table-text-color: $--color-text-regular !default;$--table-header-color: $--color-text-secondary !default;$--table-row-hover-background: $--background-color-base !default;$--table-current-row-background: $--color-primary-light-9 !default;$--table-header-background: $--color-white !default;$--table-footer-background: $--color-text-placeholder !default;$--table-fixed-box-shadow: 0 0 10px rgba(0, 0, 0, .12) !default;/* Pagination-------------------------- */$--pagination-font-size: 13px !default;$--pagination-fill: $--color-white !default;$--pagination-color: $--color-text-primary !default;$--pagination-border-radius: 3px !default;$--pagination-button-color: $--color-text-primary !default;$--pagination-button-width: 35.5px !default;$--pagination-button-height: 28px !default;$--pagination-button-disabled-color: $--color-text-placeholder !default;$--pagination-button-disabled-fill: $--color-white !default;$--pagination-hover-fill: $--color-primary !default;$--pagination-hover-color: $--color-white !default;/* Popover-------------------------- */$--popover-fill: $--color-white !default;$--popover-font-size: $--font-size-base !default;$--popover-border-color: $--border-color-lighter !default;$--popover-arrow-size: 6px !default;$--popover-padding: 12px !default;$--popover-padding-large: 18px 20px !default;$--popover-title-font-size: 16px !default;$--popover-title-color: $--color-text-primary !default;/* Tooltip-------------------------- */$--tooltip-fill: $--color-text-primary !default;$--tooltip-color: $--color-white !default;$--tooltip-font-size: 12px !default;$--tooltip-border-color: $--color-text-primary !default;$--tooltip-arrow-size: 6px !default;$--tooltip-padding: 10px !default;/* Tag-------------------------- */$--tag-padding: 0 10px !default;$--tag-fill: rgba($--color-primary, 0.10) !default;$--tag-color: $--color-primary !default;$--tag-border: rgba($--color-primary, 0.20) !default;$--tag-font-size: 12px !default;$--tag-border-radius: 4px !default;$--tag-info-fill: rgba($--color-info, 0.10) !default;$--tag-info-border: rgba($--color-info, 0.20) !default;$--tag-info-color: $--color-info !default;$--tag-primary-fill: rgba($--color-primary, 0.10) !default;$--tag-primary-border: rgba($--color-primary, 0.20) !default;$--tag-primary-color: $--color-primary !default;$--tag-success-fill: rgba($--color-success, 0.10) !default;$--tag-success-border: rgba($--color-success, 0.20) !default;$--tag-success-color: $--color-success !default;$--tag-warning-fill: rgba($--color-warning, 0.10) !default;$--tag-warning-border: rgba($--color-warning, 0.20) !default;$--tag-warning-color: $--color-warning !default;$--tag-danger-fill: rgba($--color-danger, 0.10) !default;$--tag-danger-border: rgba($--color-danger, 0.20) !default;$--tag-danger-color: $--color-danger !default;/* Tree-------------------------- */$--tree-node-hover-color: $--background-color-base !default;$--tree-text-color: $--color-text-regular !default;$--tree-expand-icon-color: $--color-text-placeholder !default;/* Dropdown-------------------------- */$--dropdown-menu-box-shadow: $--box-shadow-light !default;$--dropdown-menuItem-hover-fill: $--color-primary-light-9 !default;$--dropdown-menuItem-hover-color: $--link-color !default;/* Badge-------------------------- */$--badge-fill: $--color-danger !default;$--badge-radius: 10px !default;$--badge-font-size: 12px !default;$--badge-padding: 6px !default;$--badge-size: 18px !default;/* Card--------------------------*/$--card-border-color: $--border-color-lighter !default;$--card-border-radius: 4px !default;$--card-padding: 20px !default;/* Slider--------------------------*/$--slider-main-background-color: $--color-primary !default;$--slider-runway-background-color: $--border-color-light !default;$--slider-button-hover-color: mix($--color-primary, black, 97%) !default;$--slider-stop-background-color: $--color-white !default;$--slider-disable-color: $--color-text-placeholder !default;$--slider-margin: 16px 0 !default;$--slider-border-radius: 3px !default;$--slider-height: 6px !default;$--slider-button-size: 16px !default;$--slider-button-wrapper-size: 36px !default;$--slider-button-wrapper-offset: -15px !default;/* Steps--------------------------*/$--steps-border-color: $--disabled-border-base !default;$--steps-border-radius: 4px !default;$--steps-padding: 20px !default;/* Menu--------------------------*/$--menu-item-font-size: $--font-size-base !default;$--menu-item-color: $--color-text-primary !default;$--menu-item-fill: $--color-white !default;$--menu-item-hover-fill: $--color-primary-light-9 !default;/* Rate--------------------------*/$--rate-height: 20px !default;$--rate-font-size: $--font-size-base !default;$--rate-icon-size: 18px !default;$--rate-icon-margin: 6px !default;$--rate-icon-color: $--color-text-placeholder !default;/* DatePicker--------------------------*/$--datepicker-color: $--color-text-regular !default;$--datepicker-off-color: $--color-text-placeholder !default;$--datepicker-header-color: $--color-text-regular !default;$--datepicker-icon-color: $--color-text-primary !default;$--datepicker-border-color: $--disabled-border-base !default;$--datepicker-inner-border-color: #e4e4e4 !default;$--datepicker-inrange-color: $--border-color-extra-light !default;$--datepicker-inrange-hover-color: $--border-color-extra-light !default;$--datepicker-active-color: $--color-primary !default;$--datepicker-text-hover-color: $--color-primary !default;$--datepicker-cell-hover-color: #fff !default;/* Loading--------------------------*/$--loading-spinner-size: 42px !default;$--loading-fullscreen-spinner-size: 50px !default;/* Scrollbar--------------------------*/$--scrollbar-background-color: rgba($--color-text-secondary, .3) !default;$--scrollbar-hover-background-color: rgba($--color-text-secondary, .5) !default;/* Carousel--------------------------*/$--carousel-arrow-font-size: 12px !default;$--carousel-arrow-size: 36px !default;$--carousel-arrow-background: rgba(31, 45, 61, 0.11) !default;$--carousel-arrow-hover-background: rgba(31, 45, 61, 0.23) !default;$--carousel-indicator-width: 30px !default;$--carousel-indicator-height: 2px !default;$--carousel-indicator-padding-horizontal: 4px !default;$--carousel-indicator-padding-vertical: 12px !default;$--carousel-indicator-out-color: $--border-color-hover !default;/* Collapse--------------------------*/$--collapse-border-color: $--border-color-lighter !default;$--collapse-header-height: 48px !default;$--collapse-header-padding: 20px !default;$--collapse-header-fill: $--color-white !default;$--collapse-header-color: $--color-text-primary !default;$--collapse-header-size: 13px !default;$--collapse-content-fill: $--color-white !default;$--collapse-content-size: 13px !default;$--collapse-content-color: $--color-text-primary !default;/* Transfer--------------------------*/$--transfer-border-color: $--border-color-lighter !default;$--transfer-border-radius: $--border-radius-base !default;$--transfer-panel-width: 200px !default;$--transfer-panel-header-height: 40px !default;$--transfer-panel-header-background: $--background-color-base !default;$--transfer-panel-footer-height: 40px !default;$--transfer-panel-body-height: 246px !default;$--transfer-item-height: 30px !default;$--transfer-item-hover-background: $--color-text-secondary !default;$--transfer-filter-height: 32px !default;/* Header --------------------------*/$--header-padding: 0 20px !default;/* Footer--------------------------*/$--footer-padding: 0 20px !default;/* Main--------------------------*/$--main-padding: 20px !default;/* Break-point--------------------------*/$--sm: 768px !default;$--md: 992px !default;$--lg: 1200px !default;$--xl: 1920px !default;$--breakpoints: ( 'xs' : (max-width: $--sm - 1), 'sm' : (min-width: $--sm), 'md' : (min-width: $--md), 'lg' : (min-width: $--lg), 'xl' : (min-width: $--xl));$--breakpoints-spec: ( 'xs-only' : (max-width: $--sm - 1), 'sm-and-up' : (min-width: $--sm), 'sm-only': \"(min-width: #&#123;$--sm&#125;) and (max-width: #&#123;$--md&#125; - 1)\", 'sm-and-down': (max-width: $--md - 1), 'md-and-up' : (min-width: $--md), 'md-only': \"(min-width: #&#123;$--md&#125;) and (max-width: #&#123;$--lg &#125; - 1)\", 'md-and-down': (max-width: $--lg - 1), 'lg-and-up' : (min-width: $--lg), 'lg-only': \"(min-width: #&#123;$--lg&#125;) and (max-width: #&#123;$--xl &#125; - 1)\", 'lg-and-down': (max-width: $--xl - 1), 'xl-only' : (min-width: $--xl),);","categories":[{"name":"Vue","slug":"Vue","permalink":"http://xdd7130.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://xdd7130.github.io/tags/Vue/"}]},{"title":"git","slug":"git","date":"2019-07-04T14:24:57.000Z","updated":"2022-11-02T11:15:20.550Z","comments":true,"path":"2019/07/04/git/","link":"","permalink":"http://xdd7130.github.io/2019/07/04/git/","excerpt":"","text":"git 初始化一个Git仓库，使用git init命令。 添加文件到Git仓库，分两步： 12使用命令git add &lt;file&gt;，注意，可反复多次使用，添加多个文件；使用命令git commit -m &lt;message&gt;，完成。 工作区和暂存区 首先需要理解工作区和版本库的概念： 工作区（Working Directory）：就是可以在电脑上看到的目录，比如目录文件夹，就是一个工作区；版本库（Repository）: 工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。git的版本库中存放很多的东西，其中最重要的就是stage(index)的暂存区，还有git为我们创建的第一个分支master，以及指向maste分支的一个HEAD指针。 将文件提交到版本库中需要两个步骤(也可以说是三个步骤)： 1234git status 可以查看哪些文件在本次修改了，以便我们清楚在下一步应该提交哪些文件git add &lt;filePath&gt; 此命令是将file文件提交到暂存区，此命令是单个文件提交，也可以用git add . 将工作区所有文件都提交，但一般没有这个必要，只需要将本次修改提交就好；git commit -m'提交描述' 次命令是将暂存区的所有文件提交到版本库中的当前分支上，一般提交在后面加上本次修改的描述。 版本回退总结： HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset –hard commit_id。穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。 12341、git log命令显示从最近到最远的提交日志2、如果嫌输出信息太多，看得眼花缭乱的，可以试试加上--pretty=oneline参数：$ git log --pretty=oneline看到的一大串类似1094adb...的是commit id（版本号）3、要把当前版本回退到上一个版本，就可以使用git reset命令：$ git reset --hard HEAD^ 撤销修改1$ git checkout -- readme.txt 一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。总之，就是让这个文件回到最近一次git commit或git add时的状态。 场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout – file。场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD ，就回到了场景1，第二步按场景1操作。场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。 删除文件命令git rm用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容。 远程仓库添加远程仓库1、要关联一个远程库，使用命令git remote add origin git@server-name:path/repo-name.git； 2、关联后，使用命令git push -u origin master第一次推送master分支的所有内容； 3、此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改； 分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而SVN在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就完成了同步，方便！ 从远程库克隆若我们从零开发，那么最好的方式是先创建远程库，然后，从远程库克隆。1、首先，登陆GitHub，创建一个新的仓库。2、勾选Initialize this repository with a README，这样GitHub会自动为我们创建一个README.md文件。创建完毕后，可以看到README.md文件。3、用命令git clone克隆一个本地库。 分支管理创建与合并分支总结：1234567891011查看分支：git branch创建分支：git branch &lt;name&gt;切换分支：git checkout &lt;name&gt;创建+切换分支：git checkout -b &lt;name&gt;合并某分支到当前分支：git merge &lt;name&gt;删除分支：git branch -d &lt;name&gt; 1、创建dev分支，然后切换到dev分支：$ git checkout -b devgit checkout命令加上-b参数表示创建并切换，相当于以下两条命令：$ git branch dev$ git checkout dev 2、用git branch命令查看当前分支，git branch命令会列出所有分支，当前分支前面会标一个*号：$ git branch3、我们就可以在dev分支上正常提交4、dev分支的工作完成，我们就可以切换回master分支：git checkout master5、我们把dev分支的工作成果合并到master分支上：git merge devgit merge命令用于合并指定分支到当前分支6、合并完成后，就可以放心地删除dev分支了：git branch -d dev7、删除后，查看branch，就只剩下master分支了 解决冲突当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。 解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。 用git log –graph命令可以看到分支合并图。 分支管理策略 在实际开发中，我们应该按照几个基本原则进行分支管理： 首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活； 那在哪干活呢？干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本； 你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。 Bug分支修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场。 Feature分支开发一个新feature，最好新建一个分支； 如果要丢弃一个没有被合并过的分支，可以通过git branch -D 【name】强行删除。 多人协作多人协作的工作模式通常是这样： 1、首先，可以试图用git push origin 【branch-name】推送自己的修改； 2、如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并； 3、如果合并有冲突，则解决冲突，并在本地提交； 4、没有冲突或者解决掉冲突后，再用git push origin 【branch-name】推送就能成功！ 如果git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令git branch –set-upstream-to 【branch-name】 origin/【branch-name】。 这就是多人协作的工作模式，一旦熟悉了，就非常简单。 Rebaserebase操作可以把本地未push的分叉提交历史整理成直线； rebase的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比。 标签管理创建标签命令git tag 【tagname】用于新建一个标签，默认为HEAD，也可以指定一个commit id； 命令git tag -a 【tagname】 -m “blablabla…”可以指定标签信息； 命令git tag可以查看所有标签 操作标签命令git push origin 【tagname】可以推送一个本地标签； 命令git push origin –tags可以推送全部未推送过的本地标签； 命令git tag -d 【tagname】可以删除一个本地标签； 命令git push origin :refs/tags/【tagname】可以删除一个远程标签。 git命令汇总Git Cheat Sheet","categories":[{"name":"git","slug":"git","permalink":"http://xdd7130.github.io/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://xdd7130.github.io/tags/git/"}]},{"title":"前端工作流搭建","slug":"前端工作流","date":"2019-07-03T14:24:57.000Z","updated":"2022-11-02T11:15:20.680Z","comments":true,"path":"2019/07/03/前端工作流/","link":"","permalink":"http://xdd7130.github.io/2019/07/03/前端工作流/","excerpt":"","text":"1. 工作流创建github申请注册建立ZJHBT仓库 若仓库类型为Private,可以在setting —&gt; Collaborator给其他人开启自己版本库的权限。（最多3个，否则需包月） Jenkins安装 安装java 环境，下载对应版本，这里下载jdk-8u211-windows-x64.exe，须有Orale账户 本项目Jenkins账户，访问网址http:xx.xx.xx（默认端口8080，可修改） Jenkins与git配置参考：https://juejin.im/post/5ad1980e6fb9a028c42ea1be","categories":[{"name":"其他","slug":"其他","permalink":"http://xdd7130.github.io/categories/其他/"}],"tags":[{"name":"前端工作流","slug":"前端工作流","permalink":"http://xdd7130.github.io/tags/前端工作流/"}]},{"title":"tcp","slug":"tcp","date":"2019-02-15T01:40:54.000Z","updated":"2022-11-02T11:15:20.674Z","comments":true,"path":"2019/02/15/tcp/","link":"","permalink":"http://xdd7130.github.io/2019/02/15/tcp/","excerpt":"","text":"参考：https://juejin.im/post/5a7ef7ce5188257a856f38b0 TCP三次握手与四次挥手解释1首先来看看OSI的七层模型：我们需要知道TCP工作在网络OSI的七层模型中的第四层——Transport层，IP在第三层——Network层，ARP在第二层——Data Link层；在第二层上的数据，我们把它叫Frame，在第三层上的数据叫Packet，第四层的数据叫Segment。 同时，我们需要简单的知道，数据从应用层发下来，会在每一层都会加上头部信息，进行封装，然后再发送到数据接收端。这个基本的流程你需要知道，就是每个数据都会经过数据的封装和解封装的过程。 在OSI七层模型中，每一层的作用和对应的协议如下：TCP是一个协议，那这个协议是如何定义的，它的数据格式是什么样子的呢？要进行更深层次的剖析，就需要了解，甚至是熟记TCP协议中每个字段的含义。哦，来吧。 TCP是面向连接的，无论哪一方向另一方发送数据之前，都必须先在双方之间建立一条连接。在TCP/IP协议中，TCP协议提供可靠的连接服务，连接是通过三次握手进行初始化的。三次握手的目的是同步连接双方的序列号和确认号并交换 TCP窗口大小信息。这就是面试中经常会被问到的TCP三次握手。只是了解TCP三次握手的概念，对你获得一份工作是没有任何帮助的，你需要去了解TCP三次握手中的一些细节。先来看图说话。 握手说明 第一次握手：建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入SYN_SEND状态，等待服务器的确认； 第二次握手：服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态； 第三次握手：客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。完成了三次握手，客户端和服务器端就可以开始传送数据。以上就是TCP三次握手的总体介绍。那四次分手呢？ 挥手说明当客户端和服务器通过三次握手建立了TCP连接以后，当数据传送完毕，肯定是要断开TCP连接的啊。那对于TCP的断开连接，这里就有了神秘的“四次分手”。 第一次分手：主机1（可以使客户端，也可以是服务器端），设置Sequence Number和Acknowledgment Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了；-第二次分手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我“同意”你的关闭请求； 第三次分手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态； 第四次分手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。 为什么要三次握手?既然总结了TCP的三次握手，那为什么非要三次呢？怎么觉得两次就可以完成了。那TCP为什么非要进行三次连接呢？在谢希仁的《计算机网络》中是这样说的： 为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。 在书中同时举了一个例子，如下：1“已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。” 这就很明白了，防止了服务器端的一直等待而浪费资源。 为什么要四次挥手?那四次分手又是为何呢？TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP是全双工模式，这就意味着，当主机1发出FIN报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。如果要正确的理解四次分手的原理，就需要了解四次分手过程中的状态变化。 FIN_WAIT_1: 这个状态要好好解释一下，其实FIN_WAIT_1和FIN_WAIT_2状态的真正含义都是表示等待对方的FIN报文。而这两种状态的区别是：FIN_WAIT_1状态实际上是当SOCKET在ESTABLISHED状态时，它想主动关闭连接，向对方发送了FIN报文，此时该SOCKET即进入到FIN_WAIT_1状态。而当对方回应ACK报文后，则进入到FIN_WAIT_2状态，当然在实际的正常情况下，无论对方何种情况下，都应该马上回应ACK报文，所以FIN_WAIT_1状态一般是比较难见到的，而FIN_WAIT_2状态还有时常常可以用netstat看到。（主动方） FIN_WAIT_2：上面已经详细解释了这种状态，实际上FIN_WAIT_2状态下的SOCKET，表示半连接，也即有一方要求close连接，但另外还告诉对方，我暂时还有点数据需要传送给你(ACK信息)，稍后再关闭连接。（主动方） CLOSE_WAIT：这种状态的含义其实是表示在等待关闭。怎么理解呢？当对方close一个SOCKET后发送FIN报文给自己，你系统毫无疑问地会回应一个ACK报文给对方，此时则进入到CLOSE_WAIT状态。接下来呢，实际上你真正需要考虑的事情是察看你是否还有数据发送给对方，如果没有的话，那么你也就可以 close这个SOCKET，发送FIN报文给对方，也即关闭连接。所以你在CLOSE_WAIT状态下，需要完成的事情是等待你去关闭连接。（被动方） LAST_ACK: 这个状态还是比较容易好理解的，它是被动关闭一方在发送FIN报文后，最后等待对方的ACK报文。当收到ACK报文后，也即可以进入到CLOSED可用状态了。（被动方） TIME_WAIT: 表示收到了对方的FIN报文，并发送出了ACK报文，就等2MSL后即可回到CLOSED可用状态了。如果FINWAIT1状态下，收到了对方同时带FIN标志和ACK标志的报文时，可以直接进入到TIME_WAIT状态，而无须经过FIN_WAIT_2状态。（主动方） CLOSED: 表示连接中断。 TCP三次握手与四次挥手解释2TCP三次握手 PS：TCP协议中，主动发起请求的一端称为『客户端』，被动连接的一端称为『服务端』。不管是客户端还是服务端，TCP连接建立完后都能发送和接收数据。 起初，服务器和客户端都为CLOSED状态。在通信开始前，双方都得创建各自的传输控制块（TCB）。服务器创建完TCB后遍进入LISTEN状态，此时准备接收客户端发来的连接请求。 第一次握手客户端向服务端发送连接请求报文段。该报文段的头部中SYN=1，ACK=0，seq=x。请求发送后，客户端便进入SYN-SENT状态。 PS1：SYN=1，ACK=0表示该报文段为连接请求报文。 PS2：x为本次TCP通信的字节流的初始序号。 TCP规定：SYN=1的报文段不能有数据部分，但要消耗掉一个序号。 第二次握手服务端收到连接请求报文段后，如果同意连接，则会发送一个应答：SYN=1，ACK=1，seq=y，ack=x+1。该应答发送完成后便进入SYN-RCVD状态。 PS1：SYN=1，ACK=1表示该报文段为连接同意的应答报文。 PS2：seq=y表示服务端作为发送者时，发送字节流的初始序号。 PS3：ack=x+1表示服务端希望下一个数据报发送序号从x+1开始的字节。 第三次握手当客户端收到连接同意的应答后，还要向服务端发送一个确认报文段，表示：服务端发来的连接同意应答已经成功收到。该报文段的头部为：ACK=1，seq=x+1，ack=y+1。客户端发完这个报文段后便进入ESTABLISHED状态，服务端收到这个应答后也进入ESTABLISHED状态，此时连接的建立完成！为什么连接建立需要三次握手，而不是两次握手？防止失效的连接请求报文段被服务端接收，从而产生错误。PS：失效的连接请求：若客户端向服务端发送的连接请求丢失，客户端等待应答超时后就会再次发送连接请求，此时，上一个连接请求就是『失效的』。若建立连接只需两次握手，客户端并没有太大的变化，仍然需要获得服务端的应答后才进入ESTABLISHED状态，而服务端在收到连接请求后就进入ESTABLISHED状态。此时如果网络拥塞，客户端发送的连接请求迟迟到不了服务端，客户端便超时重发请求，如果服务端正确接收并确认应答，双方便开始通信，通信结束后释放连接。此时，如果那个失效的连接请求抵达了服务端，由于只有两次握手，服务端收到请求就会进入ESTABLISHED状态，等待发送数据或主动发送数据。但此时的客户端早已进入CLOSED状态，服务端将会一直等待下去，这样浪费服务端连接资源。 TCP四次挥手TCP连接的释放一共需要四步，因此称为『四次挥手』。我们知道，TCP连接是双向的，因此在四次挥手中，前两次挥手用于断开一个方向的连接，后两次挥手用于断开另一方向的连接。 第一次挥手若A认为数据发送完成，则它需要向B发送连接释放请求。该请求只有报文头，头中携带的主要参数为：FIN=1，seq=u。此时，A将进入FIN-WAIT-1状态。 PS1：FIN=1表示该报文段是一个连接释放请求。 PS2：seq=u，u-1是A向B发送的最后一个字节的序号。 第二次挥手B收到连接释放请求后，会通知相应的应用程序，告诉它A向B这个方向的连接已经释放。此时B进入CLOSE-WAIT状态，并向A发送连接释放的应答，其报文头包含：ACK=1，seq=v，ack=u+1。 PS1：ACK=1：除TCP连接请求报文段以外，TCP通信过程中所有数据报的ACK都为1，表示应答。 PS2：seq=v，v-1是B向A发送的最后一个字节的序号。 PS3：ack=u+1表示希望收到从第u+1个字节开始的报文段，并且已经成功接收了前u个字节。 A收到该应答，进入FIN-WAIT-2状态，等待B发送连接释放请求。第二次挥手完成后，A到B方向的连接已经释放，B不会再接收数据，A也不会再发送数据。但B到A方向的连接仍然存在，B可以继续向A发送数据。 第三次挥手当B向A发完所有数据后，向A发送连接释放请求，请求头：FIN=1，ACK=1，seq=w，ack=u+1。B便进入LAST-ACK状态。 第四次挥手A收到释放请求后，向B发送确认应答，此时A进入TIME-WAIT状态。该状态会持续2MSL时间，若该时间段内没有B的重发请求的话，就进入CLOSED状态，撤销TCB。当B收到确认应答后，也便进入CLOSED状态，撤销TCB。 为什么A要先进入TIME-WAIT状态，等待2MSL时间后才进入CLOSED状态？ 为了保证B能收到A的确认应答。 若A发完确认应答后直接进入CLOSED状态，那么如果该应答丢失，B等待超时后就会重新发送连接释放请求，但此时A已经关闭了，不会作出任何响应，因此B永远无法正常关闭。","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://xdd7130.github.io/categories/Web前端/"}],"tags":[{"name":"tcp","slug":"tcp","permalink":"http://xdd7130.github.io/tags/tcp/"}]},{"title":"类class","slug":"类class","date":"2019-01-07T07:48:34.000Z","updated":"2022-11-02T11:15:20.745Z","comments":true,"path":"2019/01/07/类class/","link":"","permalink":"http://xdd7130.github.io/2019/01/07/类class/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"垂直居中","slug":"垂直居中","date":"2019-01-05T01:25:40.000Z","updated":"2022-11-02T11:15:20.720Z","comments":true,"path":"2019/01/05/垂直居中/","link":"","permalink":"http://xdd7130.github.io/2019/01/05/垂直居中/","excerpt":"","text":"16种方法实现水平居中垂直居中熟悉水平居中和垂直居中的方法, 不为别的, 就为用的时候能够信手拈来. 下面直接步入正题.原文：16种方法实现水平居中垂直居中 水平居中1) 若是行内元素, 给其父元素设置 text-align:center,即可实现行内元素水平居中. 2) 若是块级元素, 该元素设置 margin:0 auto即可. 3) 若子元素包含 float:left 属性, 为了让子元素水平居中, 则可让父元素宽度设置为fit-content,并且配合margin, 作如下设置:123456.parent&#123; width: -moz-fit-content; width: -webkit-fit-content; width:fit-content; margin:0 auto;&#125; fit-content是CSS3中给width属性新加的一个属性值,它配合margin可以轻松实现水平居中, 目前只支持Chrome 和 Firefox浏览器. 4) 使用flex 2012年版本布局, 可以轻松的实现水平居中, 子元素设置如下: .son{ display: flex; justify-content: center;}复制代码5) 使用flex 2009年版本, 父元素display: box;box-pack: center;如下设置: .parent { display: -webkit-box; -webkit-box-orient: horizontal; -webkit-box-pack: center; display: -moz-box; -moz-box-orient: horizontal; -moz-box-pack: center; display: -o-box; -o-box-orient: horizontal; -o-box-pack: center; display: -ms-box; -ms-box-orient: horizontal; -ms-box-pack: center; display: box; box-orient: horizontal; box-pack: center;}复制代码6) 使用CSS3中新增的transform属性, 子元素设置如下: .son{ position:absolute; left:50%; transform:translate(-50%,0);}复制代码7) 使用绝对定位方式, 以及负值的margin-left, 子元素设置如下: .son{ position:absolute; width:固定; left:50%; margin-left:-0.5宽度;}复制代码8) 使用绝对定位方式, 以及left:0;right:0;margin:0 auto; 子元素设置如下: .son{ position:absolute; width:固定; left:0; right:0; margin:0 auto;}复制代码 垂直居中单行文本1) 若元素是单行文本, 则可设置 line-height 等于父元素高度 行内块级元素2) 若元素是行内块级元素, 基本思想是使用display: inline-block, vertical-align: middle和一个伪元素让内容块处于容器中央. .parent::after, .son{ display:inline-block; vertical-align:middle;}.parent::after{ content:’’; height:100%;}复制代码这是一种很流行的方法, 也适应IE7. 元素高度不定3) 可用 vertical-align 属性, 而vertical-align只有在父层为 td 或者 th 时, 才会生效, 对于其他块级元素, 例如 div、p 等, 默认情况是不支持的. 为了使用vertical-align, 我们需要设置父元素display:table, 子元素 display:table-cell;vertical-align:middle; 优点 元素高度可以动态改变, 不需再CSS中定义, 如果父元素没有足够空间时, 该元素内容也不会被截断. 缺点 IE6~7, 甚至IE8 beta中无效. 4) 可用 Flex 2012版, 这是CSS布局未来的趋势. Flexbox是CSS3新增属性, 设计初衷是为了解决像垂直居中这样的常见布局问题. 相关的文章如《弹性盒模型Flex指南》 父元素做如下设置即可保证子元素垂直居中: .parent { display: flex; align-items: center;}复制代码优点 内容块的宽高任意, 优雅的溢出.可用于更复杂高级的布局技术中.缺点 IE8/IE9不支持需要浏览器厂商前缀渲染上可能会有一些问题5) 使用flex 2009版. .parent { display: box; box-orient: vertical; box-pack: center;}复制代码优点 实现简单, 扩展性强 缺点 兼容性差, 不支持IE 6) 可用 transform , 设置父元素相对定位(position:relative), 子元素如下css样式: .son{ position:absolute; top:50%; -webkit-transform: translate(-50%,-50%); -ms-transform: translate(-50%,-50%); transform: translate(-50%,-50%);}复制代码优点 代码量少 缺点 IE8不支持, 属性需要追加浏览器厂商前缀, 可能干扰其他 transform 效果, 某些情形下会出现文本或元素边界渲染模糊的现象. 元素高度固定7) 设置父元素相对定位(position:relative), 子元素如下css样式: .son{ position:absolute; top:50%; height:固定; margin-top:-0.5高度;}复制代码优点 适用于所有浏览器. 缺点 父元素空间不够时, 子元素可能不可见(当浏览器窗口缩小时,滚动条不出现时).如果子元素设置了overflow:auto, 则高度不够时, 会出现滚动条. 8) 设置父元素相对定位(position:relative), 子元素如下css样式: .son{ position:absolute; height:固定; top:0; bottom:0; margin:auto 0;}复制代码优点 简单 缺点 没有足够空间时, 子元素会被截断, 但不会有滚动条. 总结水平居中较为简单, 共提供了8种方法, 一般情况下 text-align:center,marin:0 auto; 足矣 ① text-align:center;② margin:0 auto;③ width:fit-content;④ flex⑤ 盒模型⑥ transform⑦ ⑧ 两种不同的绝对定位方法垂直居中, 共提供了8种方法. ① 单行文本, line-height② 行内块级元素, 使用 display: inline-block, vertical-align: middle; 加上伪元素辅助实现③ vertical-align④ flex⑤ 盒模型⑥ transform⑦ ⑧ 两种不同的绝对定位方法我们发现, flex, 盒模型, transform, 绝对定位, 这几种方法同时适用于水平居中和垂直居中. 水平垂直居中实现仅居中元素定宽高适用： absolute + 负margin absolute + margin auto absolute + calc 居中元素不定宽高适用： absolute + transform writing-mode lineheight table css-table flex grid absolute + 负margin为了实现上面的效果先来做些准备工作，假设HTML代码如下，总共两个元素，父元素和子元素123&lt;div class=&quot;wp&quot;&gt; &lt;div class=&quot;box size&quot;&gt;123123&lt;/div&gt;&lt;/div&gt; wp是父元素的类名，box是子元素的类名，因为有定宽和不定宽的区别，size用来表示指定宽度，下面是所有效果都要用到的公共代码，主要是设置颜色和宽高注意：后面不在重复这段公共代码，只会给出相应提示12345678910111213141516/* 公共代码 */.wp &#123; border: 1px solid red; width: 300px; height: 300px;&#125;.box &#123; background: green; &#125;.box.size&#123; width: 100px; height: 100px;&#125;/* 公共代码 */ 绝对定位的百分比是相对于父元素的宽高，通过这个特性可以让子元素的居中显示，但绝对定位是基于子元素的左上角，期望的效果是子元素的中心居中显示为了修正这个问题，可以借助外边距的负值，负的外边距可以让元素向相反方向定位，通过指定子元素的外边距为子元素宽度一半的负值，就可以让子元素居中了，css代码如下1234567891011121314/* 此处引用上面的公共代码 *//* 此处引用上面的公共代码 *//* 定位代码 */.wp &#123; position: relative;&#125;.box &#123; position: absolute;; top: 50%; left: 50%; margin-left: -50px; margin-top: -50px;&#125; 这是我比较常用的方式，这种方式比较好理解，兼容性也很好，缺点是需要知道子元素的宽高 absolute + margin auto这种方式也要求居中元素的宽高必须固定，HTML代码如下123&lt;div class=&quot;wp&quot;&gt; &lt;div class=&quot;box size&quot;&gt;123123&lt;/div&gt;&lt;/div&gt; 这种方式通过设置各个方向的距离都是0，此时再讲margin设为auto，就可以在各个方向上居中了123456789101112131415/* 此处引用上面的公共代码 *//* 此处引用上面的公共代码 *//* 定位代码 */.wp &#123; position: relative;&#125;.box &#123; position: absolute;; top: 0; left: 0; right: 0; bottom: 0; margin: auto;&#125; 这种方法兼容性也很好，缺点是需要知道子元素的宽高 absolute + calc这种方式也要求居中元素的宽高必须固定，所以我们为box增加size类，HTML代码如下123&lt;div class=&quot;wp&quot;&gt; &lt;div class=&quot;box size&quot;&gt;123123&lt;/div&gt;&lt;/div&gt; 感谢css3带来了计算属性，既然top的百分比是基于元素的左上角，那么在减去宽度的一半就好了，代码如下123456789101112/* 此处引用上面的公共代码 *//* 此处引用上面的公共代码 *//* 定位代码 */.wp &#123; position: relative;&#125;.box &#123; position: absolute;; top: calc(50% - 50px); left: calc(50% - 50px);&#125; 这种方法兼容性依赖calc的兼容性，缺点是需要知道子元素的宽高 absolute + transform还是绝对定位，但这个方法不需要子元素固定宽高，所以不再需要size类了，HTML代码如下123&lt;div class=&quot;wp&quot;&gt; &lt;div class=&quot;box&quot;&gt;123123&lt;/div&gt;&lt;/div&gt; 修复绝对定位的问题，还可以使用css3新增的transform，transform的translate属性也可以设置百分比，其是相对于自身的宽和高，所以可以讲translate设置为-50%，就可以做到居中了，代码如下12345678910111213/* 此处引用上面的公共代码 *//* 此处引用上面的公共代码 *//* 定位代码 */.wp &#123; position: relative;&#125;.box &#123; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);&#125; 这种方法兼容性依赖translate2d的兼容性 line-height利用行内元素居中属性也可以做到水平垂直居中，HTML代码如下123&lt;div class=&quot;wp&quot;&gt; &lt;div class=&quot;box&quot;&gt;123123&lt;/div&gt;&lt;/div&gt; 把box设置为行内元素，通过text-align就可以做到水平居中，但很多同学可能不知道通过通过vertical-align也可以在垂直方向做到居中，代码如下12345678910111213141516/* 此处引用上面的公共代码 *//* 此处引用上面的公共代码 *//* 定位代码 */.wp &#123; line-height: 300px; text-align: center; font-size: 0px;&#125;.box &#123; font-size: 16px; display: inline-block; vertical-align: middle; line-height: initial; text-align: left; /* 修正文字 */&#125; 这种方法需要在子元素中将文字显示重置为想要的效果 writing-modewriting-mode可以改变文字的显示方向，比如可以通过writing-mode让文字的显示变为垂直方向1234567891011&lt;div class=&quot;div1&quot;&gt;水平方向&lt;/div&gt;&lt;div class=&quot;div2&quot;&gt;垂直方向&lt;/div&gt;.div2 &#123; writing-mode: vertical-lr;&#125;水平方向垂直方向 更神奇的是所有水平方向上的css属性，都会变为垂直方向上的属性，比如text-align，通过writing-mode和text-align就可以做到水平和垂直方向的居中了，只不过要稍微麻烦一点123456789101112131415161718192021222324&lt;div class=&quot;wp&quot;&gt; &lt;div class=&quot;wp-inner&quot;&gt; &lt;div class=&quot;box&quot;&gt;123123&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;复制代码/* 此处引用上面的公共代码 *//* 此处引用上面的公共代码 *//* 定位代码 */.wp &#123; writing-mode: vertical-lr; text-align: center;&#125;.wp-inner &#123; writing-mode: horizontal-tb; display: inline-block; text-align: center; width: 100%;&#125;.box &#123; display: inline-block; margin: auto; text-align: left;&#125; 这种方法实现起来和理解起来都稍微有些复杂 table曾经table被用来做页面布局，现在没人这么做了，但table也能够实现水平垂直居中，但是会增加很多冗余代码123456789&lt;table&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td class=&quot;wp&quot;&gt; &lt;div class=&quot;box&quot;&gt;123123&lt;/div&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; tabel单元格中的内容天然就是垂直居中的，只要添加一个水平居中属性就好了123456.wp &#123; text-align: center;&#125;.box &#123; display: inline-block;&#125; 这种方法就是代码太冗余，而且也不是table的正确用法 css-tablecss新增的table属性，可以让我们把普通元素，变为table元素的现实效果，通过这个特性也可以实现水平垂直居中123&lt;div class=&quot;wp&quot;&gt; &lt;div class=&quot;box&quot;&gt;123123&lt;/div&gt;&lt;/div&gt; 下面通过css属性，可以让div显示的和table一样12345678.wp &#123; display: table-cell; text-align: center; vertical-align: middle;&#125;.box &#123; display: inline-block;&#125; 复制代码这种方法和table一样的原理，但却没有那么多冗余代码，兼容性也还不错 flexflex作为现代的布局方案，颠覆了过去的经验，只需几行代码就可以优雅的做到水平垂直居中12345678&lt;div class=&quot;wp&quot;&gt; &lt;div class=&quot;box&quot;&gt;123123&lt;/div&gt;&lt;/div&gt;.wp &#123; display: flex; justify-content: center; align-items: center;&#125; 目前在移动端已经完全可以使用flex了，PC端需要看自己业务的兼容性情况 gridcss新出的网格布局，由于兼容性不太好，一直没太关注，通过grid也可以实现水平垂直居中12345678910&lt;div class=&quot;wp&quot;&gt; &lt;div class=&quot;box&quot;&gt;123123&lt;/div&gt;&lt;/div&gt;.wp &#123; display: grid;&#125;.box &#123; align-self: center; justify-self: center;&#125; 代码量也很少，但兼容性不如flex，不推荐使用 总结下面对比下各个方式的优缺点，肯定又双叒叕该有同学说回字的写法了，简单总结下 PC端有兼容性要求，宽高固定，推荐absolute + 负margin PC端有兼容要求，宽高不固定，推荐css-table PC端无兼容性要求，推荐flex 移动端推荐使用flex 小贴士：关于flex的兼容性决方案，请看这里《移动端flex布局实战》 方法 居中元素定宽高固定 PC兼容性 移动端兼容性 absolute + 负margin 是 ie6+, chrome4+, firefox2+ 安卓2.3+, iOS6+ absolute + margin auto 是 ie6+, chrome4+, firefox2+ 安卓2.3+, iOS6+ absolute + calc 是 ie9+, chrome19+, firefox4+ 安卓4.4+, iOS6+ absolute + transform 否 ie9+, chrome4+, firefox3.5+ 安卓3+, iOS6+ writing-mode 否 ie6+, chrome4+, firefox3.5+ 安卓2.3+, iOS5.1+ lineheight 否 ie6+, chrome4+, firefox2+ 安卓2.3+, iOS6+ table 否 ie6+, chrome4+, firefox2+ 安卓2.3+, iOS6+ css-table 否 ie8+, chrome4+, firefox2+ 安卓2.3+, iOS6+ flex 否 ie10+, chrome4+, firefox2+ 安卓2.3+, iOS6+ grid 否 ie10+, chrome57+, firefox52+ 安卓6+, iOS10.3+","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://xdd7130.github.io/categories/Web前端/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://xdd7130.github.io/tags/CSS/"},{"name":"居中","slug":"居中","permalink":"http://xdd7130.github.io/tags/居中/"}]},{"title":"盒模型","slug":"盒模型","date":"2019-01-04T08:40:34.000Z","updated":"2022-11-02T11:15:20.733Z","comments":true,"path":"2019/01/04/盒模型/","link":"","permalink":"http://xdd7130.github.io/2019/01/04/盒模型/","excerpt":"","text":"css盒模型简介：就是用来装页面上的元素的矩形区域。CSS中的盒子模型包括IE盒子模型和标准的W3C盒子模型。 box-sizing(有3个值哦)：border-box,padding-box,content-box. 标准盒子模型：IE盒子模型：区别：从图中我们可以看出，这两种盒子模型最主要的区别就是width的包含范围，在标准的盒子模型中，width指content部分的宽度，在IE盒子模型中，width表示content+padding+border这三个部分的宽度，故这使得在计算整个盒子的宽度时存在着差异： 标准盒子模型的盒子宽度：左右border+左右padding+widthIE盒子模型的盒子宽度：width 在CSS3中引入了box-sizing属性，box-sizing:content-box;表示标准的盒子模型，box-sizing:border-box表示的是IE盒子模型 最后，前面我们还提到了，box-sizing:padding-box,这个属性值的宽度包含了左右padding+width","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://xdd7130.github.io/categories/Web前端/"}],"tags":[{"name":"盒模型","slug":"盒模型","permalink":"http://xdd7130.github.io/tags/盒模型/"}]},{"title":"面试JS","slug":"面试JS","date":"2019-01-03T13:42:31.000Z","updated":"2022-11-02T11:15:20.760Z","comments":true,"path":"2019/01/03/面试JS/","link":"","permalink":"http://xdd7130.github.io/2019/01/03/面试JS/","excerpt":"","text":"介绍一下JS的数据类型？ 简单类型：String、Number、Boolean、Null、Undefined复杂类型：ObjectES6新增类型：Symbol扩展：null与undefined有什么区别 答：null 表示一个对象被定义了，值为“空值”，而undefined 表示不存在这个值。 正因为这个原因，所以使用typeof判断时，null返回的是object，而undefined返回的是undefined。(判断两者时需要使用===严格判断)Boolean类型在进行判断的时候设置为 0、-0、null、””、false、undefined 或 NaN，则该对象设置为 false。否则设置为 true（即使 value 参数是字符串 “false”） 如何通过JS判断一个数组？ 1.instanceof方法 instanceof 运算符是用来测试一个对象是否在其原型链原型构造函数的属性。 12var arr = []; arr instanceof Array; // true 2.constructor方法 constructor属性返回对创建此对象的数组函数的引用，就是返回对象相对应的构造函数。12var arr = []; arr.constructor == Array; //true 3.特性判断法 利用判断数组独有的length和splice方法，但是这是不靠谱的，因为对象也能添加方法和属性。那怎么办了，有一个办法，可以利用数组的length属性没法枚举来判断。1234567function isArray(object)&#123; return object &amp;&amp; typeof object===&apos;object&apos; &amp;&amp; typeof object.length===&apos;number&apos; &amp;&amp; typeof object.splice===&apos;function&apos; &amp;&amp; //判断length属性是否是可枚举的 对于数组 将得到false !(object.propertyIsEnumerable(&apos;length&apos;));&#125; 4.最简单的方法 这种写法，是 jQuery 正在使用的，淘宝的 kissy 也是使用这种方式。12345Object.prototype.toString.call(value) == &apos;[object Array]&apos;// 利用这个方法，可以写一个返回数据类型的方法var isType = function (obj) &#123; return Object.prototype.toString.call(obj).slice(8,-1); &#125; 5.ES5新增方法isArray() 1234var a = new Array(123);var b = new Date();console.log(Array.isArray(a)); //trueconsole.log(Array.isArray(b)); //false &amp;扩展：使用instanceof和construcor，被判断的array必须是在当前页面声明的。比如，一个页面（父页面）有一个框架，框架中引用了一个页面（子页面），在子页面中声明了一个array，并将其赋值给父页面的一个变量，这时判断该变量，Array == object.constructor;会返回false。最简单的方法，在IE6下判断null和undefined，有一些bug，判断undefined和null均为Object，(并不是bug，是在ES3的标准下返回的就为Object) 谈一谈let、const与var的区别？let命令基本用法在ES6中，新增了let命令，用于声明变量，用来取代ES5中var命令，消除var声明的变量的不合理，不严谨之处。const用于声明常量。让我们来看看let和var的区别 1.let不存在变量提升 使用let声明的变量，不会像使用var那样存在“变量提升“”的现象。所以使用let声明变量，必须遵循“先声明，后使用”的原则。否则会报错12console.log(a); //ReferenceErrorlet a = 10; 如果是var声明的变量，则不会报错。12console.log(b); //undefinedvar b = 10; 2.let声明的变量，存在块级作用域 let声明的变量只在所声明的代码块内有效。块级作用域由 { } 包括，if语句和for语句里面的{ }也属于块作用域。123456&#123; var a = 10; let b = 20; &#125; console.log(a); //10 console.log(b); // ReferenceError: b is not defined 12345678910var a =[];for( var i=0; i&lt;10; i++ )&#123; a[i] = function()&#123; console.log(i); &#125;&#125; for( var j = 0; j&lt;a.length; j++ )&#123; a[j](); //输出10个10。 因为i是var声明的，在全局范围内都用，每次新的i都会覆盖原来的。 &#125; 12345678910var a =[]; for( let i=0; i&lt;10; i++ )&#123; a[i] = function()&#123; console.log(i); &#125; &#125; for( let j = 0; j&lt;a.length; j++ )&#123; a[j](); //输出 0，1，2，...，9 &#125; 3.let不允许在同一作用域内重复声明同一个变量在同一作用域内，如果使用var声明同一个变量，则后面的覆盖前面的 12345678910111213var a = 10;let a = 10;console.log(a);//Uncaught SyntaxError: Identifier &apos;a&apos; has already been declared或let a = 10;let a = 15;console.log(a);//Uncaught SyntaxError: Identifier &apos;a&apos; has already been declared 4.暂时性死区：在代码块内，使用let声明变量之前，该变量都是不可以使用用只要在同一作用域内存在let命令，他所声明的变量就“绑定”在这个作用域内，不管外部有没有声明 例如123456let a =10;function fn1()&#123; console.log(a); let a = 5;&#125;fn1();//Uncaught ReferenceError: a is not defined ES6规定，如果在区块中存在let和const声明的变量，则这个区块对这些声明的变量从一开始就形成一个封闭的作用域。不管在外部有没有声明这个变量。必须遵守“先声明，后使用”的原则，否则报错 ES6规定暂时性死区和不存在变量提升，主要是为了减少运行程序的错误，防止出现“先使用（变量），后声明（变量）”的情况，从而导致意料之外的行为。这种错误在ES5中很常见，现在有了这种规定，就可以避免出现此类错误了 总之，暂时性死区的本质就是，只要一进入当前作用域，所使用的变量就已存在，但是不可获取，只有等到声明变量的哪一行代码的出现，在可以获取和使用该变量 const命令的基本使用const用来声明常量，一旦声明，其值就不能更改1234const a = 10; a = 20; console.log(a);//Uncaught TypeError: Assignment to constant variable. 1.const声明的常量不能改变，意味着const一旦声明常量，就必须同时初始化。不能先声明，后初始化，这样会报错 2.与let一样。const声明的常量也只在块级作用域内有效 3.与let一样，必须先声明，后使用 4.与let一样，在同一作用域，const不能重复声明同一常量 那么如果使用const声明对象呢？1234567const b = &#123; name:&apos;zs&apos;, age:22 &#125;b.name = &quot;lzx&quot;;console.log(b.name+&quot;---&quot;+b.age);//输出lzx---22 我们可以看到，使用const声明的对象的属性是可以修改。 因为Object类型是引用类型。用const声明常量保存的是对象的地址，不可变的是地址，在上面的代码中就是，不能把 b 指向另一个对象。而修改对象的属性，并不会改变对象的地址，因此用const声明对象的属性是可以修改的 map与forEach的区别？1、forEach方法，是最基本的方法，就是遍历与循环，默认有3个传参：分别是遍历的数组内容item、数组索引index、和当前遍历数组Array。另外，除去第一个必须的回调函数参数，还可以接受一个上下文参数(改变回调函数的this指向)；并且forEach不会遍历空元素。2、map方法，基本用法与forEach一致，但是不同的，它会返回一个新的数组，所以在callback需要有return值，如果没有，会返回undefined。(从字面理解，map就是映射的意思)3、filter方法，用法和map很相似，从字面理解，就是过滤、筛选的意思。但是函数的callback需要返回布尔值true或false，并且返回值只需要为弱等==即可。4、some 方法，对数组中每一项运行指定函数，如果该函数对任一项返回true，则返回true。(一旦遇到true，就会中断循环，返回true，类似于||判断)5、every方法，对数组中的每一项运行给定函数，如果该函数对每一项返回true，则返回true。(一旦遇到false，就会中断循环，返回false，类似于&amp;&amp;判断)6、indexOf方法，与字符串中的indexOf类似，返回数组索引值，如果没有匹配，则会返回-1，第二个参数为可选，表示从当前位置开始搜索。7、lastIndexOf方法，与indexOf相似，只是是从数组的末尾开始查找，而第二个参数的默认值是array.length - 1。8、reduce方法，字面意思应该是‘减少’，但是实际是‘递归’的意思。实际就是应用一个函数针对数组的两个值(从左到右)，以减至一个值。它的callback接收4个参数：之前值(上一次循环返回的值)、当前值、索引值以及数组本身。initialValue参数可选，表示初始值。9、reduceRight方法，与reduce方法类似，只是从数组的末尾开始实现。 谈一谈你理解的函数式编程？谈一谈箭头函数与普通函数的区别？ 箭头函数使得表达更加简洁。(这个是废话) 函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。 不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。 不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用Rest参数代替。 不可以使用yield命令，因此箭头函数不能用作Generator函数。 谈一谈函数中this的指向吧？全局环境 无论是否在严格模式下，在全局执行环境中（在任何函数体外部）this 都指代全局对象。 123456789// 在浏览器中, window 对象同时也是全局对象：console.log(this === window); // truea = 37;console.log(window.a); // 37this.b = \"MDN\";console.log(window.b) // \"MDN\"console.log(b) // \"MDN\" 函数（运行内）环境在函数内部，this的值取决于函数被调用的方式。 简单调用因为下面的代码不在严格模式下，且 this 的值不是由该调用设置的，所以 this 的值默认指向全局对象12345678function f1()&#123; return this;&#125;//在浏览器中：f1() === window; //在浏览器中，全局对象是window//在Node中：f1() === global; 然而，在严格模式下，this将保持他进入执行环境时的值，所以下面的this将会默认为undefined。123456function f2()&#123; \"use strict\"; // 这里是严格模式 return this;&#125;f2() === undefined; // true 所以，在严格模式下，如果 this 没有被执行环境（execution context）定义，那它将保持为 undefined。 在第二个例子中，this的确应该是undefined，因为f2是被直接调用的，而不是作为对象的属性或方法调用的（如 window.f2()）。有一些浏览器最初在支持严格模式时没有正确实现这个功能，于是它们错误地返回了window对象。 如果要想把 this 的值从一个环境传到另一个，就要用 call 或者apply 方法// 将一个对象作为call和apply的第一个参数，this会被绑定到这个对象。123456789101112var obj = &#123;a: 'Custom'&#125;;// 这个属性是在global对象定义的。var a = 'Global';function whatsThis(arg) &#123; return this.a; // this的值取决于函数的调用方式&#125;whatsThis(); // 'Global'whatsThis.call(obj); // 'Custom'whatsThis.apply(obj); // 'Custom' 当一个函数在其主体中使用 this 关键字时，可以通过使用函数继承自Function.prototype 的 call 或 apply 方法将 this 值绑定到调用中的特定对象。12345678910111213function add(c, d) &#123; return this.a + this.b + c + d;&#125;var o = &#123;a: 1, b: 3&#125;;// 第一个参数是作为‘this’使用的对象// 后续参数作为参数传递给函数调用add.call(o, 5, 7); // 1 + 3 + 5 + 7 = 16// 第一个参数也是作为‘this’使用的对象// 第二个参数是一个数组，数组里的元素用作函数调用中的参数add.apply(o, [10, 20]); // 1 + 3 + 10 + 20 = 34 使用 call 和 apply 函数的时候要注意，如果传递给 this 的值不是一个对象，JavaScript 会尝试使用内部 ToObject 操作将其转换为对象。因此，如果传递的值是一个原始值比如 7 或 ‘foo’，那么就会使用相关构造函数将它转换为对象，所以原始值 7 会被转换为对象，像 new Number(7) 这样，而字符串 ‘foo’ 转化成 new String(‘foo’) 这样，例如：123456function bar() &#123; console.log(Object.prototype.toString.call(this));&#125;//原始值 7 被隐式转换为对象bar.call(7); // [object Number] bind方法ECMAScript 5 引入了 Function.prototype.bind。调用f.bind(someObject)会创建一个与f具有相同函数体和作用域的函数，但是在这个新函数中，this将永久地被绑定到了bind的第一个参数，无论这个函数是如何被调用的。123456789101112function f()&#123; return this.a;&#125;var g = f.bind(&#123;a:\"azerty\"&#125;);console.log(g()); // azertyvar h = g.bind(&#123;a:'yoo'&#125;); // bind只生效一次！console.log(h()); // azertyvar o = &#123;a:37, f:f, g:g, h:h&#125;;console.log(o.f(), o.g(), o.h()); // 37, azerty, azerty 箭头函数 箭头函数详解1 箭头函数详解2 在箭头函数中，this与封闭词法环境的this保持一致。在全局代码中，它将被设置为全局对象123var globalObject = this;var foo = (() =&gt; this);console.log(foo() === globalObject); // true 注意：如果将this传递给call、bind、或者apply，它将被忽略。不过你仍然可以为调用添加参数，不过第一个参数（thisArg）应该设置为null。 1234567891011// 接着上面的代码// 作为对象的一个方法调用var obj = &#123;foo: foo&#125;;console.log(obj.foo() === globalObject); // true// 尝试使用call来设定thisconsole.log(foo.call(obj) === globalObject); // true// 尝试使用bind来设定thisfoo = foo.bind(obj);console.log(foo() === globalObject); // true 无论如何，foo 的 this 被设置为他被创建时的环境（在上面的例子中，就是全局对象）。这同样适用于在其他函数内创建的箭头函数：这些箭头函数的this被设置为封闭的词法环境的。123456789101112131415161718192021222324252627// 创建一个含有bar方法的obj对象，// bar返回一个函数，// 这个函数返回this，// 这个返回的函数是以箭头函数创建的，// 所以它的this被永久绑定到了它外层函数的this。// bar的值可以在调用中设置，这反过来又设置了返回函数的值。var obj = &#123; bar: function() &#123; var x = (() =&gt; this); return x; &#125;&#125;;// 作为obj对象的一个方法来调用bar，把它的this绑定到obj。// 将返回的函数的引用赋值给fn。var fn = obj.bar();// 直接调用fn而不设置this，// 通常(即不使用箭头函数的情况)默认为全局对象// 若在严格模式则为undefinedconsole.log(fn() === obj); // true// 但是注意，如果你只是引用obj的方法，// 而没有调用它var fn2 = obj.bar;// 那么调用箭头函数后，this指向window，因为它从 bar 继承了this。console.log(fn2()() == window); // true 在上面的例子中，一个赋值给了 obj.bar的函数（称为匿名函数 A），返回了另一个箭头函数（称为匿名函数 B）。因此，在 A 调用时，函数B的this被永久设置为obj.bar（函数A）的this。当返回的函数（函数B）被调用时，它this始终是最初设置的。在上面的代码示例中，函数B的this被设置为函数A的this，即obj，所以即使被调用的方式通常将其设置为 undefined 或全局对象（或者如前面示例中的其他全局执行环境中的方法），它的 this 也仍然是 obj . 作为对象的方法当函数作为对象里的方法被调用时，它们的 this 是调用该函数的对象。下面的例子中，当 o.f()被调用时，函数内的this将绑定到o对象。12345678var o = &#123; prop: 37, f: function() &#123; return this.prop; &#125;&#125;;console.log(o.f()); // logs 37 请注意，这样的行为，根本不受函数定义方式或位置的影响。在前面的例子中，我们在定义对象o的同时，将函数内联定义为成员f。但是，我们也可以先定义函数，然后再将其附属到o.f。这样做会导致相同的行为：123456789var o = &#123;prop: 37&#125;;function independent() &#123; return this.prop;&#125;o.f = independent;console.log(o.f()); // logs 37 这表明函数是从o的f成员调用的才是重点。 同样，this 的绑定只受最靠近的成员引用的影响。在下面的这个例子中，我们把一个方法g当作对象o.b的函数调用。在这次执行期间，函数中的this将指向o.b。事实证明，这与他是对象 o 的成员没有多大关系，最靠近的引用才是最重要的。12o.b = &#123;g: independent, prop: 42&#125;;console.log(o.b.g()); // 42 原型链中的 this对于在对象原型链上某处定义的方法，同样的概念也适用。如果该方法存在于一个对象的原型链上，那么this指向的是调用这个方法的对象，就像该方法在对象上一样。12345678910var o = &#123; f: function() &#123; return this.a + this.b; &#125;&#125;;var p = Object.create(o);p.a = 1;p.b = 4;console.log(p.f()); // 5 在这个例子中，对象p没有属于它自己的f属性，它的f属性继承自它的原型。虽然在对 f 的查找过程中，最终是在 o 中找到 f 属性的，这并没有关系；查找过程首先从 p.f 的引用开始，所以函数中的 this 指向p。也就是说，因为f是作为p的方法调用的，所以它的this指向了p。这是 JavaScript 的原型继承中的一个有趣的特性。 getter 与 setter 中的 this再次，相同的概念也适用于当函数在一个 getter 或者 setter 中被调用。用作 getter 或 setter 的函数都会把 this 绑定到设置或获取属性的对象。1234567891011121314151617function sum() &#123; return this.a + this.b + this.c;&#125;var o = &#123; a: 1, b: 2, c: 3, get average() &#123; return (this.a + this.b + this.c) / 3; &#125;&#125;;Object.defineProperty(o, 'sum', &#123; get: sum, enumerable: true, configurable: true&#125;);console.log(o.average, o.sum); // logs 2, 6 作为构造函数当一个函数用作构造函数时（使用new关键字），它的this被绑定到正在构造的新对象 虽然构造器返回的默认值是this所指的那个对象，但它仍可以手动返回其他的对象（如果返回值不是一个对象，则返回this对象）。 12345678910111213141516171819202122232425262728293031/* * 构造函数这样工作: * * function MyConstructor()&#123; * // 函数实体写在这里 * // 根据需要在this上创建属性，然后赋值给它们，比如： * this.fum = \"nom\"; * // 等等... * * // 如果函数具有返回对象的return语句， * // 则该对象将是 new 表达式的结果。 * // 否则，表达式的结果是当前绑定到 this 的对象。 * //（即通常看到的常见情况）。 * &#125; */function C()&#123; this.a = 37;&#125;var o = new C();console.log(o.a); // logs 37function C2()&#123; this.a = 37; return &#123;a:38&#125;;&#125;o = new C2();console.log(o.a); // logs 38 作为一个DOM事件处理函数节当函数被用作事件处理函数时，它的this指向触发事件的元素（一些浏览器在使用非addEventListener的函数动态添加监听函数时不遵守这个约定）。12345678910111213141516// 被调用时，将关联的元素变成蓝色function bluify(e)&#123; console.log(this === e.currentTarget); // 总是 true // 当 currentTarget 和 target 是同一个对象时为 true console.log(this === e.target); this.style.backgroundColor = '#A5D9F3';&#125;// 获取文档中的所有元素的列表var elements = document.getElementsByTagName('*');// 将bluify作为元素的点击监听函数，当元素被点击时，就会变成蓝色for(var i=0 ; i&lt;elements.length ; i++)&#123; elements[i].addEventListener('click', bluify, false);&#125; 作为一个内联事件处理函数当代码被内联on-event 处理函数调用时，它的this指向监听器所在的DOM元素：123&lt;button onclick=\"alert(this.tagName.toLowerCase());\"&gt; Show this&lt;/button&gt; 上面的 alert 会显示button。注意只有外层代码中的this是这样设置的：123&lt;button onclick=\"alert((function()&#123;return this&#125;)());\"&gt; Show inner this&lt;/button&gt; 在这种情况下，没有设置内部函数的this，所以它指向 global/window 对象（即非严格模式下调用的函数未设置this时指向的默认对象） 异步编程的实现方式？回调函数：优点：简单、容易理解缺点：不利于维护，代码耦合高 1.事件监听(采用时间驱动模式，取决于某个事件是否发生)： 优点：容易理解，可以绑定多个事件，每个事件可以指定多个回调函数缺点：事件驱动型，流程不够清晰 2.发布/订阅(观察者模式)： 类似于事件监听，但是可以通过‘消息中心’，了解现在有多少发布者，多少订阅者。 3.Promise对象 优点：可以利用then方法，进行链式写法；可以书写错误时的回调函数；缺点：编写和理解，相对比较难 4.Generator函数 优点：函数体内外的数据交换、错误处理机制缺点：流程管理不方便 5.async函数 优点：内置执行器、更好的语义、更广的适用性、返回的是Promise、结构清晰。缺点：错误处理机制 ……js基础 类和继承（es5实现方法 + es6实现方法）； promise； 写一个方法遍历所有文档树所有节点(考察递归)； jsonp和跨域； sort排序相关(注意ascll这个坑) 数组和对象的深浅拷贝； String + Array的一些基本操作；写一个数组去重的方法；冒泡和捕获；事件代理； call、apply、bind；变量提升；高阶函数；动画；setTimeout、setInterval和requestAnimationFrame；模块化开发；引起内存泄漏的原因；ajax；map、filter、reduce相关；Map和Set；移动端开发相关； ……技术拓展 设计模式相关(单例、发布订阅等)；浏览器渲染过程；性能优化相关(这个点很大，设计很多方面，不要自以为优化就是网上经常看到的那一套)；设计一个模版引擎；设计一个打包工具；设计一个mvvm框架需要注意的case；源码阅读相关； 作者：玩弄心里的鬼链接：https://juejin.im/post/59ec3d50f265da431c6f7339来源：掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 json的JSON.parse()和JSON.stringfy()JSON.parse() 从字符串解析出对象 123456//定义一个字符串var data=&apos;&#123;&quot;name&quot;:&quot;goatling&quot;&#125;&apos;//解析对象​​JSON.parse(data)结果是：​name:&quot;goatling&quot; JSON.stringfy() 从一个对象解析出字符串 var data={name:&apos;goatling&apos;} JSON.stringify(data) 结果是： &apos;{&quot;name&quot;:&quot;goatling&quot;}&apos;","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://xdd7130.github.io/categories/Web前端/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://xdd7130.github.io/tags/JS/"}]},{"title":"闭包","slug":"闭包","date":"2019-01-02T02:54:13.000Z","updated":"2022-11-02T11:15:20.755Z","comments":true,"path":"2019/01/02/闭包/","link":"","permalink":"http://xdd7130.github.io/2019/01/02/闭包/","excerpt":"","text":"闭包闭包理解** 特性：函数嵌套函数；函数内部可以引用函数外部的参数和变量；函数变量和参数不会被垃圾回收机制回收； **优缺点：优点 希望一个变量长期驻扎在内存中 避免全局变量的污染 私有成员的存在缺点 常驻内存，增大内存使用量，使用不当回造成内存泄漏； ** 自执行函数的好处隔离作用域，避免全局作用域污染模拟块级作用域 应用的两种情况：函数作为返回值、函数作为参数传递。 第一，函数作为返回值：12345678910function fn()&#123; var max = 10; return function bar(x)&#123; if (x&gt;max)&#123; console.log(x) &#125; &#125;&#125;var f1 = fn();f1(15); 如上代码，bar函数作为返回值，赋值给f1变量。执行f1(15)时，用到了fn作用域下的max变量的值 第二，函数作为参数被传递12345678910var max = 10,fn = function(x)&#123; if(x&gt;max)&#123; console.log(x) &#125;&#125;;(function(f)&#123; var max = 100; f(15);&#125;)(fn) 如上代码中，fn函数作为一个参数被传递进入另一个函数，赋值给f参数。执行f(15)时，max变量的取值是10，而不是100。 闭包与作用域变量的作用域,是指变量的有效范围当在函数中声明一个变量的时候,如果该变量前面没有带上关键字 var,这个变量就会成为全局变量 ,这当然是一种很容易造成命名冲突的做法。另外一种情况是用 var 关键字在函数中声明变量,这时候的变量即是局部变量,只有在该函数内部才能访问到这个变量,在函数外面是访问不到的。 例一123456var func=function()&#123; var a=1; console.log(a); //输出:1 &#125;;func();console.log ( a ); // Uncaught ReferenceError: a is not defined 例二，变量的搜索是从内到外而非从外到 内的。123456789101112var a=1;var func1 = function()&#123; var b=2; var func2 = function()&#123; var c=3; console.log ( b ); // 输出:2 console.log ( a );// 输出:1 &#125; func2(); console.log(c);//输出:Uncaught ReferenceError: c is not defined&#125;; func1(); 变量的生存周期。对于全局变量来说,全局变量的生存周期当然是的永久,除非我们主动销毁这个全局变量。 而对于在函数内用 var 关键字声明的局部变量来说,当退出函数时,这些局部变量即失去了 它们的价值,它们都会随着函数的调用的结束而销毁 例一123456789101112var func = function()&#123; var a=1; return function()&#123; a++; console.log(a); &#125; &#125;;var f=func();f();// 输出:2 f();// 输出:3f();// 输出:4f();// 输出:5 跟我们之前的结论相反,上面的例子在当退出函数后,局部变量 a 并没有消失,而是似乎一直在某个地方 存活着。 这是因为当执行 var f = func();时,f 返回了一个名函数的引用,它可以问到 func() 被调用时产生的环境,而局部变量 a 一直处在这个环境里。 既然外局部变量所在的环境还能被外 界访问,这个局部变量就有了不被销毁的理由。在这里生了一个闭包结构,局部变量的声明看起来被延续了。 例二，假设页面上有 5 个 div 节点,我们通过循环来给每个 div绑定 onclick 事件,按照索引顺序,点击第 1 个 div 时弹出 0,点击第 2 个 div 时出 1,以此类。123456var nodes = document.getElementsByTagName( 'div' );for(var i=0,len=nodes.length;i&amp;lt;len;i++)&#123; nodes[ i ].onclick = function()&#123; alert(i); &#125;&#125;; 测试这段代码会发现,无论点击哪个 div,最后弹出的结果都是 5。 这是因为 div 节点的 onclick事件是被异步触发的,当事件被触发的时候,for循环早已结束,此时 i 的值已经是 5, 所以在 div 的 onclick 事件函数中顺着作用域链从内到外查找变量 i 时,查找到的值总是 5。 解决方法是在闭包的帮助下,每次循环的 i 值都封闭起来。当在事件函数中顺着作用域链从内到外查找变量 i 时,会先找到被封闭在闭包环境中的 i,如果有 5 个 div,这里的 i 分别 是 0,1,2,3,4&gt;1234567for(var i=0,len=nodes.length;i&amp;lt;len;i++)&#123; (function( i )&#123; nodes[ i ].onclick = function()&#123; console.log(i); &#125; &#125;)(i)&#125;; 例三123456789101112var Type = &#123;&#125;;for ( var i = 0, type; type = [ 'String', 'Array', 'Number' ][ i++ ]; )&#123; (function( type )&#123; Type[ 'is' + type ] = function( obj )&#123; return Object.prototype.toString.call( obj ) === '[object '+ type +']'; &#125; &#125;)( type )&#125;;console.log( Type.isArray( [] ) );// 输出:trueconsole.log( Type.isString( \"str\" ) );// 输出:trueconsole.log( Type.isNumber( 5 ) );// 输出:trueconsole.log( Type.isString( [] ) );// 输出:false 图解","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://xdd7130.github.io/categories/Web前端/"}],"tags":[{"name":"闭包","slug":"闭包","permalink":"http://xdd7130.github.io/tags/闭包/"}]},{"title":"遍历数组的常用方法","slug":"遍历数组的常用方法","date":"2019-01-02T02:18:07.000Z","updated":"2022-11-02T11:15:20.748Z","comments":true,"path":"2019/01/02/遍历数组的常用方法/","link":"","permalink":"http://xdd7130.github.io/2019/01/02/遍历数组的常用方法/","excerpt":"","text":"遍历数组的常用方法最传统方法 for循环123456789101112var arr = [&quot;first&quot;,&quot;second&quot;,&quot;third&quot;,&quot;fourth&quot;,3,5,8];for(var i = 0; i &lt; arr.length;i++)&#123; console.log(arr[i]);&#125; //输出： first second third fourth 3 5 8 for… in123456789101112var arr = [&quot;first&quot;,&quot;second&quot;,&apos;third&apos; ,&quot;fourth&quot;,3,5,8];for(var i in arr)&#123; console.log(arr[i] +&apos;/&apos; + i); &#125; //输出结果为： first/0 second/1 third/2 fourth/3 3/4 5/5 8/6 for…of123456789101112var arr = [&quot;first&quot;,&quot;second&quot;,&apos;third&apos; ,&quot;fourth&quot;,3,5,8];for(var item of arr)&#123; console.log(item);&#125;//输出结果： first second third fourth 3 5 8 虽然for… in 、for…of都能够变历数组，但是两者还是有很大区别的，先说结论： 两者的主要区别在于： 他们的迭代方式推荐在循环对象属性的时候，使用for in，在遍历数组的时候推荐使用for of for…in 循环出来的是key, for…of循环出来的是value for…in 是ES5 标准，for …of 是ES6标准，兼容性可能存在些问题，请注意使用 for…of 不能遍历普通的对象，需要和Object.keys()搭配使用。 123456789101112131415161718192021222324252627var arr = [&quot;first&quot;,&quot;second&quot;,&apos;third&apos; ,&quot;fourth&quot;,3,5,8]; //给数组添加新属性 arr.name = &apos;zhangsan&apos;; for(var item of arr)&#123; console.log(item); &#125; //输出： first second third fourth 3 5 8 console.log(&apos;--------------分隔符----------------&apos;); for(var item in arr)&#123; console.log(arr[item] + &apos;/&apos; + item); &#125; //输出： first/0 second/1 third/2 fourth/3 3/4 5/5 8/6 zhangsan/name 循环除了遍历数组元素外，还会遍历自定义属性，for…of只可以循环可迭代的可迭代属性，不可迭代属性在循环中被忽略了 foreach方法被传递给foreach的函数会在数组的每个元素上执行一次，元素作为参数传递给该函数12345678910111213var arr = [&quot;first&quot;,&quot;second&quot;,&quot;third&quot;,&quot;fourth&quot;,3,5,8];//element 表示arr的单元项，index 表示arr单元项对应的索引值arr.forEach(function(element,index)&#123; console.log(element + &apos;/&apos; + index);&#125;)//输出结果： first/0 second/1 third/2 fourth/3 3/4 5/5 8/6 注意：未赋值的值是不会在foreach循环迭代的，但是手动赋值为undefined的元素是会被列出的 1234567891011var arr1 = [&quot;first&quot;,&quot;second&quot;, ,&quot;fourth&quot;,3,5,8];arr1.forEach(function(element,index)&#123; console.log(element + &apos;/&apos; + index);&#125;) //输出结果 first/0 second/1 fourth/3 3/4 5/5 8/6 map遍历数组并通过callback对数组元素进行操作，并将所有操作结果放入数组中并返回该数组1234567var arr = [&quot;first&quot;,&quot;second&quot;,&apos;third&apos; ,&quot;fourth&quot;];var arr2 = arr.map(function(item,index,arr)&#123; return item.toUpperCase();&#125;)console.log(arr2);//输出：[FIRST,SECOND,THIRD, FOURTH] filter( )返回一个包含所有在回调函数上返回为true的元素新数组，回调函数在此担任的是过滤器的角色,当元素符和条件，过滤器就返回true,而filter则会返回所有符合过滤条件的元素123456789var arr = [&quot;first&quot;,&quot;second&quot;,&apos;third&apos; ,&quot;fourth&quot;,3,5,8]; var arr3 = arr.filter(function(item,index,arr)&#123; if(typeof item == &apos;number&apos;)&#123; return item; &#125; &#125;) console.log(arr3); //输出结果： [3,5,8] every()当数组中的每一个元素在callback上被返回true时就返回true注意：要求每一个单元项都返回true时才为true)every()与filter()的区别是：后者会返回所有符合过滤条件的元素；前者会判断是不是数组中的所有元素都符合条件，并且返回的是布尔值1234567var arr = [&quot;first&quot;,&quot;second&quot;,&apos;third&apos; ,&quot;fourth&quot;,3,5,8];var bol = arr.every(function(item, index, array)&#123; if(typeof item == &apos;string&apos;)&#123; return item; &#125; &#125;) console.log(bol); //false some()只要数组中有一项在callback上就返回trueevery()与some()的区别是：前者要求所有元素都符合条件才返回true,后者要求只要有符合条件的就返回true1234567var arr = [&quot;first&quot;,&quot;second&quot;,&apos;third&apos; ,&quot;fourth&quot;,3,5,8]; var bol = arr.some(function(item, index, array)&#123; if(typeof item == &apos;string&apos;)&#123; return item; &#125; &#125;) console.log(bol); //true reduce()reduce() 方法接收一个函数作为累加器（accumulator），数组中的每个值（从左到右）开始缩减，最终为一个值。123[0, 1, 2, 3, 4].reduce(function(previousValue, currentValue, index, array)&#123; return previousValue + currentValue;&#125;); reduce还有第二个参数，我们可以把这个参数作为第一次调用callback时的第一个参数，上面这个例子因为没有第二个参数，所以直接从数组的第二项开始，如果我们给了第二个参数为5123[0, 1, 2, 3, 4].reduce(function(previousValue, currentValue, index, array)&#123; return previousValue + currentValue;&#125;,5); 第一次调用的previousValue的值就用传入的第二个参数代替 reduceRight()reduceRight()方法的功能和reduce()功能是一样的，不同的是reduceRight()从数组的末尾向前将数组中的数组项做累加。 数组方法总结对于数组，最关心的的两个问题：返回值是什么，会不会对原始数组造成影响，典型的例子就是 splice 和 slice 方法。对于那些返回原数组的函数，我们可以直接调用数组的链式调用，array.filter().sort().reverse()。下面用表格列出来所有方法的功能：具体可参考：https://segmentfault.com/a/1190000008147878","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://xdd7130.github.io/categories/Web前端/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://xdd7130.github.io/tags/数组/"}]},{"title":"理解cookie、session、localStorage、sessionStorage之不同","slug":"理解cookie、session、localStorage、sessionStorage之不同","date":"2019-01-02T02:03:31.000Z","updated":"2022-11-02T11:15:20.732Z","comments":true,"path":"2019/01/02/理解cookie、session、localStorage、sessionStorage之不同/","link":"","permalink":"http://xdd7130.github.io/2019/01/02/理解cookie、session、localStorage、sessionStorage之不同/","excerpt":"","text":"理解cookie、session、localStorage、sessionStorage之不同 1、相同点：数据都保存在浏览器，同源共享。即相同的域下可以修改读取。 2、不同点： 大小数量： IE6或更低版本最多20个cookie，IE7+可以有50个。 cookie大小4KB左右，超过部分会被截掉。sessionStoage，localStoage大小可达5M。 传输： 每次请求cookie都会发送到服务器，然后回传给浏览器，sessionStoage,localStoage不会自动发送到服务器端。 有效性：cookie可以设置path路径，限制只属于某个路径。在过期时间之前都有效，即使窗口和浏览器关闭。sesesionStorage当前窗口有效，关闭窗口自动失效。localStorage始终有效，即使窗口和浏览器关闭。 作用域：cookie在同源页面中共享，sessionStorage只能在当前页有效，localStorage在所有同源页面中共享。 操作方法：Cookie的修改读取方法需自己实现，sessionStorage，localStorage提供了get，set方法。 注：cookie是不可以或缺的，cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生。 web Storage支持的属性与方法localStorage和sessionStorage都具有相同的操作方法，例如setItem、getItem和removeItem等 getItem(key):获取指定key所存储的value值key(index)方法：返回列表中对应索引的key值length属性：返回key/value队列的长度removeItem(key)方法：从Storage中删除一个对应的键值对。setItem(key,value)方法：将value存储到key指定的字段。clear()方法：移除所有的内容","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://xdd7130.github.io/categories/Web前端/"}],"tags":[{"name":"cookie","slug":"cookie","permalink":"http://xdd7130.github.io/tags/cookie/"}]},{"title":"跨域","slug":"跨域","date":"2019-01-01T14:00:08.000Z","updated":"2022-11-02T11:15:20.745Z","comments":true,"path":"2019/01/01/跨域/","link":"","permalink":"http://xdd7130.github.io/2019/01/01/跨域/","excerpt":"","text":"jsonp跨域是通过动态添加script标签实现跨域的由于script标签只能发送get请求所以jsonp不支持post方式的跨域JSONP的最基本的原理是：动态添加一个标签而script标签的src属性是没有跨域的限制的。这样说来，这种跨域方式其实与ajaxXmlHttpRequest协议无关了。可以说jsonp的方式原理上和&lt;scriptsrc=”http://跨域/…xx.js”&gt;是一致的，因为他的原理实际上就是 使用js的script标签 进行传参，那么必然是get方式的了，和浏览器中敲入一个url一样","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://xdd7130.github.io/categories/Web前端/"}],"tags":[{"name":"跨域","slug":"跨域","permalink":"http://xdd7130.github.io/tags/跨域/"}]},{"title":"http","slug":"http","date":"2018-12-27T13:35:13.000Z","updated":"2022-11-02T11:15:20.552Z","comments":true,"path":"2018/12/27/http/","link":"","permalink":"http://xdd7130.github.io/2018/12/27/http/","excerpt":"","text":"http状态码 100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息 200 OK 正常返回信息 201 Created 请求成功并且服务器创建了新的资源 202 Accepted 服务器已接受请求，但尚未处理 301 Moved Permanently 请求的网页已永久移动到新位置。 302 Found 临时性重定向。 303 See Other 临时性重定向，且总是使用 GET 请求新的 URI。 304 Not Modified 自从上次请求后，请求的网页未修改过。 Bad Request 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。 401 Unauthorized 请求未授权。 403 Forbidden 禁止访问。 404 Not Found 找不到如何与 URI 相匹配的资源。 500 Internal Server Error 最常见的服务器端错误。 503 Service Unavailable 服务器端暂时无法处理请求(可能是过载或维护)。","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://xdd7130.github.io/categories/Web前端/"}],"tags":[{"name":"http","slug":"http","permalink":"http://xdd7130.github.io/tags/http/"}]},{"title":"浏览器缓存","slug":"浏览器缓存","date":"2018-12-27T13:35:13.000Z","updated":"2022-11-02T11:15:20.725Z","comments":true,"path":"2018/12/27/浏览器缓存/","link":"","permalink":"http://xdd7130.github.io/2018/12/27/浏览器缓存/","excerpt":"","text":"HTTP强缓存和协商缓存 浏览器缓存有下面的优点： 减少冗余的数据传输 减少服务器负担 加快客户端加载网页的速度 在浏览器第一次发起请求时，本地无缓存，向web服务器发送请求，服务器起端响应请求，浏览器端缓存。过程如下： 在第一次请求时，服务器会将页面最后修改时间通过Last-Modified标识由服务器发送给客户端，客户端记录修改时间；服务器还会生成一个Etag，并发送给客户端。浏览器后续再次进行请求时： 浏览器缓存主要分为强强缓存（也称本地缓存）和协商缓存（也称弱缓存）。根据上图，浏览器在第一次请求发生后，再次发送请求时： 浏览器请求某一资源时，会先获取该资源缓存的header信息，然后根据header中的Cache-Control和Expires来判断是否过期。若没过期则直接从缓存中获取资源信息，包括缓存的header的信息，所以此次请求不会与服务器进行通信。这里判断是否过期，则是强缓存相关。后面会讲Cache-Control和Expires相关。 如果显示已过期，浏览器会向服务器端发送请求，这个请求会携带第一次请求返回的有关缓存的header字段信息，比如客户端会通过If-None-Match头将先前服务器端发送过来的Etag发送给服务器，服务会对比这个客户端发过来的Etag是否与服务器的相同，若相同，就将If-None-Match的值设为false，返回状态304，客户端继续使用本地缓存，不解析服务器端发回来的数据，若不相同就将If-None-Match的值设为true，返回状态为200，客户端重新机械服务器端返回的数据；客户端还会通过If-Modified-Since头将先前服务器端发过来的最后修改时间戳发送给服务器，服务器端通过这个时间戳判断客户端的页面是否是最新的，如果不是最新的，则返回最新的内容，如果是最新的，则返回304，客户端继续使用本地缓存。 强缓存强缓存是利用http头中的Expires和Cache-Control两个字段来控制的，用来表示资源的缓存时间。强缓存中，普通刷新会忽略它，但不会清除它，需要强制刷新。浏览器强制刷新，请求会带上Cache-Control:no-cache和Pragma:no-cache ExpiresExpires是http1.0的规范，它的值是一个绝对时间的GMT格式的时间字符串。如我现在这个网页的Expires值是：expires:Fri, 14 Apr 2017 10:47:02 GMT。这个时间代表这这个资源的失效时间，只要发送请求时间是在Expires之前，那么本地缓存始终有效，则在缓存中读取数据。所以这种方式有一个明显的缺点，由于失效的时间是一个绝对时间，所以当服务器与客户端时间偏差较大时，就会导致缓存混乱。如果同时出现Cache-Control:max-age和Expires，那么max-age优先级更高。如我主页的response headers部分如下： cache-control:max-age=691200expires:Fri, 14 Apr 2017 10:47:02 GMT那么表示资源可以被缓存的最长时间为691200秒，会优先考虑max-age。 Cache-ControlCache-Control是在http1.1中出现的，主要是利用该字段的max-age值来进行判断，它是一个相对时间，例如Cache-Control:max-age=3600，代表着资源的有效期是3600秒。cache-control除了该字段外，还有下面几个比较常用的设置值： no-cache：不使用本地缓存。需要使用缓存协商，先与服务器确认返回的响应是否被更改，如果之前的响应中存在ETag，那么请求的时候会与服务端验证，如果资源未被更改，则可以避免重新下载。 no-store：直接禁止游览器缓存数据，每次用户请求该资源，都会向服务器发送一个请求，每次都会下载完整的资源。 public：可以被所有的用户缓存，包括终端用户和CDN等中间代理服务器。 private：只能被终端用户的浏览器缓存，不允许CDN等中继缓存服务器对其缓存。Cache-Control与Expires可以在服务端配置同时启用，同时启用的时候Cache-Control优先级高。 协商缓存协商缓存就是由服务器来确定缓存资源是否可用，所以客户端与服务器端要通过某种标识来进行通信，从而让服务器判断请求资源是否可以缓存访问。 普通刷新会启用弱缓存，忽略强缓存。只有在地址栏或收藏夹输入网址、通过链接引用资源等情况下，浏览器才会启用强缓存，这也是为什么有时候我们更新一张图片、一个js文件，页面内容依然是旧的，但是直接浏览器访问那个图片或文件，看到的内容却是新的。 这个主要涉及到两组header字段：Etag和If-None-Match、Last-Modified和If-Modified-Since。上面以及说得很清楚这两组怎么使用啦~复习一下： Etag和If-None-MatchEtag/If-None-Match返回的是一个校验码。ETag可以保证每一个资源是唯一的，资源变化都会导致ETag变化。服务器根据浏览器上送的If-None-Match值来判断是否命中缓存。 与Last-Modified不一样的是，当服务器返回304 Not Modified的响应时，由于ETag重新生成过，response header中还会把这个ETag返回，即使这个ETag跟之前的没有变化。 Last-Modify/If-Modify-Since浏览器第一次请求一个资源的时候，服务器返回的header中会加上Last-Modify，Last-modify是一个时间标识该资源的最后修改时间，例如Last-Modify: Thu,31 Dec 2037 23:59:59 GMT。 当浏览器再次请求该资源时，request的请求头中会包含If-Modify-Since，该值为缓存之前返回的Last-Modify。服务器收到If-Modify-Since后，根据资源的最后修改时间判断是否命中缓存。 如果命中缓存，则返回304，并且不会返回资源内容，并且不会返回Last-Modify。 为什么要有Etag你可能会觉得使用Last-Modified已经足以让浏览器知道本地的缓存副本是否足够新，为什么还需要Etag呢？HTTP1.1中Etag的出现主要是为了解决几个Last-Modified比较难解决的问题： 一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新GET； 某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说1s内修改了N次)，If-Modified-Since能检查到的粒度是s级的，这种修改无法判断(或者说UNIX记录MTIME只能精确到秒)； 某些服务器不能精确的得到文件的最后修改时间。 Last-Modified与ETag是可以一起使用的，服务器会优先验证ETag，一致的情况下，才会继续比对Last-Modified，最后才决定是否返回304。 HTTP基于缓存策略三要素分解法两道题以下为 page.html 内容：12345&lt;!DOCTYPE html&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;title&gt;page页&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;img src=&quot;images/head.png&quot; /&gt;&lt;a href=&quot;page.html&quot;&gt;重新访问page页&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 首次访问该页面，页面中 head.png 响应头信息如下：1234567HTTP/1.1 200 OKCache-Control: no-cacheContent-Type: image/pngLast-Modified: Tue, 08 Nov 2016 06:59:00 GMTAccept-Ranges: bytesDate: Thu, 10 Nov 2016 02:48:50 GMTContent-Length: 3534 问题1：请问当点击“重新访问 page 页”链接重新加载该页面后， head.png 如何二次加载？问题2：如果将上述信息中的 Cache-Control 设置为 private，那么结果又会如何呢？ HTTP缓存体系首先我将 Http 缓存体系分为以下三个部分： 缓存存储策略 用来确定 Http响应内容是否可以被客户端缓存，以及可以被哪些客户端缓存这个策略的作用只有一个，用于决定 Http 响应内容是否可缓存到客户端 对于 Cache-Control 头里的 Public、Private、no-cache、max-age 、no-store 他们都是用来指明响应内容是否可以被客户端存储的，其中前4个都会缓存文件数据（关于 no-cache 应理解为“不建议使用本地缓存”，其仍然会缓存数据到本地），后者 no-store 则不会在客户端缓存任何响应数据。另关于 no-cache 和 max-age 有点特别，我认为它是一种混合体，下面我会讲到。 通过 Cache-Control：Public 设置我们可以将 Http 响应数据存储到本地，但此时并不意味着后续浏览器会直接从缓存中读取数据并使用，为啥？因为它无法确定本地缓存的数据是否可用（可能已经失效），还必须借助一套鉴别机制来确认才行， 这就是我们下面要讲到的“缓存过期策略”。 缓存过期策略 客户端用来确认存储在本地的缓存数据是否已过期，进而决定是否要发请求到服务端获取数据刚上面我们已经阐述了数据缓存到了本地后还需要经过判断才能使用，那么浏览器通过什么条件来判断呢？ 答案是：Expires，Expires 指名了缓存数据有效的绝对时间，告诉客户端到了这个时间点（比照客户端时间点）后本地缓存就作废了，在这个时间点内客户端可以认为缓存数据有效，可直接从缓存中加载展示。 不过 Http 缓存头设计并没有想象的那么规矩，像上面提到的 Cache-Control（这个头是在Http1.1里加进来的）头里的 no-cache 和 max-age 就是特例，它们既包含缓存存储策略也包含缓存过期策略，以 max-age 为例，他实际上相当于： Cache-Control：public/private（这里不太确定具体哪个）Expires：当前客户端时间 + maxAge 。而 Cache-Control：no-cache 和 Cache-Control：max-age=0 （单位是秒）相当 这里需要注意的是： Cache-Control 中指定的缓存过期策略优先级高于Expires，当它们同时存在的时候，后者会被覆盖掉。 缓存数据标记为已过期只是告诉客户端不能再直接从本地读取缓存了，需要再发一次请求到服务器去确认，并不等同于本地缓存数据从此就没用了，有些情况下即使过期了还是会被再次用到，具体下面会讲到。 缓存对比策略将缓存在客户端的数据标识发往服务端，服务端通过标识来判断客户端 缓存数据是否仍有效，进而决定是否要重发数据。 客户端检测到数据过期或浏览器刷新后，往往会重新发起一个 http 请求到服务器，服务器此时并不急于返回数据，而是看请求头有没有带标识（ If-Modified-Since、If-None-Match）过来，如果判断标识仍然有效，则返回304告诉客户端取本地缓存数据来用即可（这里要注意的是你必须要在首次响应时输出相应的头信息（Last-Modified、ETags）到客户端）。至此我们就明白了上面所说的本地缓存数据即使被认为过期，并不等于数据从此就没用了的道理了。 关于 Last-Modified，这个响应头使用要注意，可能会影响到缓存过期策略，具体原因，后面我会通过解答开篇提到的2道题来作说明。 以上就是我所认识的缓存策略，下面我将缓存策略三要素和常用的几个缓存头（项）结合一起，让大家更清晰的认识到它们之间的关系：通过上图我可以清晰的看到各缓存项分别属于哪个缓存策略范畴，这其中有部分重叠，它表明这些缓存项具有多重缓存策略，所以实际在分析缓存头的时候，除了常规的头外，我们还需要将这些具有双重缓存策略的项分解开来。 最后我们回到最开始提到的2道题目，我们来一起分解下： 第一道题：1234567HTTP/1.1 200 OKCache-Control: no-cacheContent-Type: image/pngLast-Modified: Tue, 08 Nov 2016 06:59:00 GMTAccept-Ranges: bytesDate: Thu, 10 Nov 2016 02:48:50 GMTContent-Length: 3534 分析上述 Http 响应头发现有以下两项与缓存相关：12Cache-Control: no-cache Last-Modified: Tue, 08 Nov 2016 06:59:00 GMT 我们上面讲到了 Cache-Control: no-cache 相当于 Cache-Control: max-age=0，且他们都是多重策略头，我们需将其分解： Cache-Control: no-cache 等于 Cache-Control: max-age=0，接着 Cache-Control: max-age=0 又可分解成： Cache-Control: public/private （不确定是二者中的哪一个）Expires: 当前时间最终我们得到了以下完整的缓存策略三要素：所以最终结果是：浏览器会再次请求服务端，并携带上 Last-Modified 指定的时间去服务器对比： a）对比失败：服务器返回200并重发数据，客户端接收到数据后展示，并刷新本地缓存。 b）对比成功：服务器返回304且不重发数据，客户端收到304状态码后从本地读取缓存数据。以下为模拟此种情况下请求后的抓包情况：这道题本身不难，但若认为 no-cache 不会缓存数据到本地，那么你理解起来就会很矛盾，因为如果文件数据没有被本地缓存，服务器返回304后将会无法展示出图片内容，但实际上它是能正常展示的。这道题很好的证明了 no-cache 也会缓存数据到本地这一说法。第二道题：1234567HTTP/1.1 200 OKCache-Control: privateContent-Type: image/pngLast-Modified: Tue, 08 Nov 2016 06:59:00 GMTAccept-Ranges: bytesDate: Thu, 10 Nov 2016 02:48:50 GMTContent-Length: 3534 解题思路和上题一样，首先先找到缓存相关项：123Cache-Control: private Last-Modified: Tue, 08 Nov 2016 06:59:00 GMT这时我们会发现根本找不到缓存过期策略项，那答案会不会和上面一样？ 一时半会也分析不出答案，那只能实际测试下了： 再看看 Chrome 浏览器下抓包：可以看到，浏览器后续请求都直接取的本地缓存，看来的确存在某种缓存过期策略（根据我上面的缓存过期策略理论，浏览器如果直接从本地加载缓存数据，说明它相信本地缓存数据有效，那一定存在某种缓存过期判断条件）。这个问题百思不得其解，困扰了我好久，直到一次偶然的机会我在 Fiddler 响应信息面板里的 Caching 选项卡中找到了答案：原来，在没有提供任何浏览器缓存过期策略的情况下，浏览器遵循一个启发式缓存过期策略： 根据响应头中2个时间字段 Date 和 Last-Modified 之间的时间差值，取其值的10%作为缓存时间周期。 贴一下Caching面板里的描述，英语好的同学可以精准翻译下：最终我们得到了以下完整的缓存策略三要素：最终结果浏览器会根据 Date 和 Last-Modified 之间的时间差值缓存一段时间，这段时间内会直接使用本地缓存数据而不会再去请求服务器（强制请求除外），缓存过期后，会再次请求服务端，并携带上 Last-Modified 指定的时间去服务器对比并根据服务端的响应状态决定是否要从本地加载缓存数据。 总结Http 缓存设置起来并不复杂，但却容易被轻视， 今天这篇文章结合2道题目，通过分析、解剖相关缓存头，从系统化角度对 Http 缓存机制做了一个较完整的剖析：Http 缓存机制实际上是 Http 缓存策略三个要素（纬度）相互作用的集合，所以在分析和设置 Http 报文缓存头时，只要能从中精准的分解出缓存三要素，我们就能非常准确的预判到缓存设置最终能达到的效果。 浏览器缓存详解:expires,cache-control,last-modified,etag详细说明 Last-Modified在浏览器第一次请求某一个URL时，服务器端的返回状态会是200，内容是你请求的资源，同时有一个Last-Modified的属性标记(HttpReponse Header)此文件在服务期端最后被修改的时间，格式类似这样： Last-Modified:Tue, 24 Feb 2009 08:01:04 GMT 客户端第二次请求此URL时，根据HTTP协议的规定，浏览器会向服务器传送If-Modified-Since报头(HttpRequest Header)，询问该时间之后文件是否有被修改过： If-Modified-Since:Tue, 24 Feb 2009 08:01:04 GMT 如果服务器端的资源没有变化，则自动返回HTTP304（NotChanged.）状态码，内容为空，这样就节省了传输数据量。当服务器端代码发生改变或者重启服务器时，则重新发出资源，返回和第一次请求时类似。从而保证不向客户端重复发出资源，也保证当服务器有变化时，客户端能够得到最新的资源。 注：如果If-Modified-Since的时间比服务器当前时间(当前的请求时间request_time)还晚，会认为是个非法请求 Etag工作原理HTTP协议规格说明定义ETag为“被请求变量的实体标记”（参见14.19）。简单点即服务器响应时给请求URL标记，并在HTTP响应头中将其传送到客户端，类似服务器端返回的格式： Etag:“5d8c72a5edda8d6a:3239″ 客户端的查询更新格式是这样的： If-None-Match:“5d8c72a5edda8d6a:3239″ 如果ETag没改变，则返回状态304。 即:在客户端发出请求后，HttpReponse Header中包含Etag:“5d8c72a5edda8d6a:3239″ 标识，等于告诉Client端，你拿到的这个的资源有表示ID：5d8c72a5edda8d6a:3239。当下次需要发Request索要同一个URI的时候，浏览器同时发出一个If-None-Match报头(Http RequestHeader)此时包头中信息包含上次访问得到的Etag:“5d8c72a5edda8d6a:3239″标识。 If-None-Match:“5d8c72a5edda8d6a:3239“ ,这样，Client端等于Cache了两份，服务器端就会比对2者的etag。如果If-None-Match为False，不返回200，返回304(Not Modified) Response。 Expires给出的日期/时间后，被响应认为是过时。如Expires:Thu, 02 Apr 2009 05:14:08 GMT 需和Last-Modified结合使用。用于控制请求文件的有效时间，当请求数据在有效期内时客户端浏览器从缓存请求数据而不是服务器端.当缓存中数据失效或过期，才决定从服务器更新数据。 Last-Modified和ExpiresLast-Modified标识能够节省一点带宽，但是还是逃不掉发一个HTTP请求出去，而且要和Expires一起用。而Expires标识却使得浏览器干脆连HTTP请求都不用发，比如当用户F5或者点击Refresh按钮的时候就算对于有Expires的URI，一样也会发一个HTTP请求出去，所以，Last-Modified还是要用的，而且要和Expires一起用。 Etag和Expires如果服务器端同时设置了Etag和Expires时，Etag原理同样，即与Last-Modified/Etag对应的HttpRequestHeader:If-Modified-Since和If-None-Match。我们可以看到这两个Header的值和WebServer发出的Last-Modified,Etag值完全一样；在完全匹配If-Modified-Since和If-None-Match即检查完修改时间和Etag之后，服务器才能返回304. Last-Modified和Etag分布式系统里多台机器间文件的last-modified必须保持一致，以免负载均衡到不同机器导致比对失败 分布式系统尽量关闭掉Etag(每台机器生成的etag都会不一样) Last-Modified和ETags请求的http报头一起使用，服务器首先产生Last-Modified/Etag标记，服务器可在稍后使用它来判断页面是否已经被修改，来决定文件是否继续缓存 过程如下: 1.客户端请求一个页面（A）。 2.服务器返回页面A，并在给A加上一个Last-Modified/ETag。 3.客户端展现该页面，并将页面连同Last-Modified/ETag一起缓存。 4.客户再次请求页面A，并将上次请求时服务器返回的Last-Modified/ETag一起传递给服务器。 5.服务器检查该Last-Modified或ETag，并判断出该页面自上次客户端请求之后还未被修改，直接返回响应304和一个空的响应体。 注： 1、Last-Modified和Etag头都是由WebServer发出的HttpReponse Header，WebServer应该同时支持这两种头。 2、WebServer发送完Last-Modified/Etag头给客户端后，客户端会缓存这些头； 3、客户端再次发起相同页面的请求时，将分别发送与Last-Modified/Etag对应的HttpRequestHeader:If-Modified-Since和If-None-Match。我们可以看到这两个Header的值和WebServer发出的Last-Modified,Etag值完全一样； 4、通过上述值到服务器端检查，判断文件是否继续缓存； 7、关于 Cache-Control: max-age=秒 和 Expires Expires = 时间，HTTP 1.0 版本，缓存的载止时间，允许客户端在这个时间之前不去检查（发请求）max-age = 秒，HTTP 1.1版本，资源在本地缓存多少秒。如果max-age和Expires同时存在，则被Cache-Control的max-age覆盖。 Expires 的一个缺点就是，返回的到期时间是服务器端的时间，这样存在一个问题，如果客户端的时间与服务器的时间相差很大，那么误差就很大，所以在HTTP 1.1版开始，使用Cache-Control: max-age=秒替代。 Expires =max-age + “每次下载时的当前的request时间” 所以一旦重新下载的页面后，expires就重新计算一次，但last-modified不会变化 浏览器缓存总结浏览器缓存分为强缓存和协商缓存。当客户端请求某个资源时，获取缓存的流程如下： 先根据这个资源的一些 http header 判断它是否命中强缓存，如果命中，则直接从本地获取缓存资源，不会发请求到服务器； 当强缓存没有命中时，客户端会发送请求到服务器，服务器通过另一些request header验证这个资源是否命中协商缓存，称为http再验证，如果命中，服务器将请求返回，但不返回资源，而是告诉客户端直接从缓存中获取，客户端收到返回后就会从缓存中获取资源； 强缓存和协商缓存共同之处在于，如果命中缓存，服务器都不会返回资源； 区别是，强缓存不对发送请求到服务器，但协商缓存会。 当协商缓存也没命中时，服务器就会将资源发送回客户端。 当 ctrl+f5 强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存； 当 f5 刷新网页时，跳过强缓存，但是会检查协商缓存； 强缓存 Expires（该字段是 http1.0 时的规范，值为一个绝对时间的 GMT 格式的时间字符串，代表缓存资源的过期时间） Cache-Control:max-age（该字段是 http1.1 的规范，强缓存利用其 max-age 值来判断缓存资源的最大生命周期，它的值单位为秒） 协商缓存 Last-Modified（值为资源最后更新时间，随服务器response返回） If-Modified-Since（通过比较两个时间来判断资源在两次请求期间是否有过修改，如果没有修改，则命中协商缓存） ETag（表示资源内容的唯一标识，随服务器response返回） If-None-Match（服务器通过比较请求头部的If-None-Match与当前资源的ETag是否一致来判断资源是否在两次请求之间有过修改，如果没有修改，则命中协商缓存）","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://xdd7130.github.io/categories/Web前端/"}],"tags":[{"name":"http","slug":"http","permalink":"http://xdd7130.github.io/tags/http/"},{"name":"缓存","slug":"缓存","permalink":"http://xdd7130.github.io/tags/缓存/"}]},{"title":"CSS","slug":"css.","date":"2018-12-26T09:28:15.000Z","updated":"2022-11-02T11:15:20.548Z","comments":true,"path":"2018/12/26/css./","link":"","permalink":"http://xdd7130.github.io/2018/12/26/css./","excerpt":"","text":"css中font-size为0的妙用(消除内联元素间的间隔)","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://xdd7130.github.io/categories/Web前端/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://xdd7130.github.io/tags/CSS/"}]},{"title":"原型与继承","slug":"原型","date":"2018-12-26T09:28:15.000Z","updated":"2022-11-02T11:15:20.714Z","comments":true,"path":"2018/12/26/原型/","link":"","permalink":"http://xdd7130.github.io/2018/12/26/原型/","excerpt":"","text":"prototype、proto和constructor的三者关系javascript里的关系又多又乱。作用域链是一种单向的链式关系，还算简单清晰；this机制的调用关系，稍微有些复杂；而关于原型，则是prototype、proto和constructor的三角关系。本文先用一张图开宗明义，然后详细解释原型的三角关系 概念上图中的复杂关系，实际上来源就两行代码:12function Foo()&#123;&#125;;var f1 = new Foo; 【构造函数】 用来初始化新创建的对象的函数是构造函数。在例子中，Foo()函数是构造函数 【实例对象】 通过构造函数的new操作创建的对象是实例对象。可以用一个构造函数，构造多个实例对象1234function Foo()&#123;&#125;;var f1 = new Foo;var f2 = new Foo;console.log(f1 === f2);//false 【原型对象及prototype】 构造函数有一个prototype属性，指向实例对象的原型对象。通过同一个构造函数实例化的多个对象具有相同的原型对象。经常使用原型对象来实现继承12345678function Foo()&#123;&#125;;Foo.prototype.a = 1;var f1 = new Foo;var f2 = new Foo;console.log(Foo.prototype.a);//1console.log(f1.a);//1console.log(f2.a);//1 【constructor】 原型对象有一个constructor属性，指向该原型对象对应的构造函数12function Foo()&#123;&#125;;console.log(Foo.prototype.constructor === Foo);//true 由于实例对象可以继承原型对象的属性，所以实例对象也拥有constructor属性，同样指向原型对象对应的构造函数123function Foo()&#123;&#125;;var f1 = new Foo;console.log(f1.constructor === Foo);//true 【proto】 实例对象有一个proto属性，指向该实例对象对应的原型对象123function Foo()&#123;&#125;;var f1 = new Foo;console.log(f1.__proto__ === Foo.prototype);//true 说明 概念介绍完了，现在对图示的关系进行详细说明12function Foo()&#123;&#125;;var f1 = new Foo; 【第一部分： Foo】 实例对象f1是通过构造函数Foo()的new操作创建的。构造函数Foo()的原型对象是Foo.prototype；实例对象f1通过proto属性也指向原型对象Foo.prototype123function Foo()&#123;&#125;;var f1 = new Foo;console.log(f1.__proto === Foo.prototype);//true 实例对象f1本身并没有constructor属性，但它可以继承原型对象Foo.prototype的constructor属性12345function Foo()&#123;&#125;;var f1 = new Foo;console.log(Foo.prototype.constructor === Foo);//trueconsole.log(f1.constructor === Foo);//trueconsole.log(f1.hasOwnProperty(&apos;constructor&apos;));//false 下图是实例对象f1的控制台效果 【第二部分： Object】 Foo.prototype是f1的原型对象，同时它也是实例对象。实际上，任何对象都可以看做是通过Object()构造函数的new操作实例化的对象 所以，Foo.prototype作为实例对象，它的构造函数是Object()，原型对象是Object.prototype。相应地，构造函数Object()的prototype属性指向原型对象Object.prototype；实例对象Foo.prototype的proto属性同样指向原型对象Object.prototype123function Foo()&#123;&#125;;var f1 = new Foo;console.log(Foo.prototype.__proto__ === Object.prototype);//true 实例对象Foo.prototype本身具有constructor属性，所以它会覆盖继承自原型对象Object.prototype的constructor属性12345function Foo()&#123;&#125;;var f1 = new Foo;console.log(Foo.prototype.constructor === Foo);//trueconsole.log(Object.prototype.constructor === Object);//trueconsole.log(Foo.prototype.hasOwnProperty(&apos;constructor&apos;));//true 下图是实例对象Foo.prototype的控制台效果:如果Object.prototype作为实例对象的话，其原型对象是什么，结果是null。私以为，这可能也是typeof null的结果是’object’的原因之一吧1console.log(Object.prototype.__proto__ === null);//true 【第三部分： Function】 前面已经介绍过，函数也是对象，只不过是具有特殊功能的对象而已。任何函数都可以看做是通过Function()构造函数的new操作实例化的结果 如果把函数Foo当成实例对象的话，其构造函数是Function()，其原型对象是Function.prototype；类似地，函数Object的构造函数也是Function()，其原型对象是Function.prototype1234function Foo()&#123;&#125;;var f1 = new Foo;console.log(Foo.__proto__ === Function.prototype);//trueconsole.log(Object.__proto__ === Function.prototype);//true 原型对象Function.prototype的constructor属性指向构造函数Function()；实例对象Object和Foo本身没有constructor属性，需要继承原型对象Function.prototype的constructor属性 1234567function Foo()&#123;&#125;;var f1 = new Foo;console.log(Function.prototype.constructor === Function);//trueconsole.log(Foo.constructor === Function);//trueconsole.log(Foo.hasOwnProperty(&apos;constructor&apos;));//falseconsole.log(Object.constructor === Function);//trueconsole.log(Object.hasOwnProperty(&apos;constructor&apos;));//false 所有的函数都可以看成是构造函数Function()的new操作的实例化对象。那么，Function可以看成是调用其自身的new操作的实例化的结果 所以，如果Function作为实例对象，其构造函数是Function，其原型对象是Function.prototype123console.log(Function.__proto__ === Function.prototype);//trueconsole.log(Function.prototype.constructor === Function);//trueconsole.log(Function.prototype === Function.prototype);//true 如果Function.prototype作为实例对象的话，其原型对象是什么呢？和前面一样，所有的对象都可以看成是Object()构造函数的new操作的实例化结果。所以，Function.prototype的原型对象是Object.prototype，其原型函数是Object()1console.log(Function.prototype.__proto__ === Object.prototype);//true 第二部分介绍过，Object.prototype的原型对象是null1console.log(Object.prototype.__proto__ === null);//true 总结 【1】函数(Function也是函数)是new Function的结果，所以函数可以作为实例对象，其构造函数是Function()，原型对象是Function.prototype 【2】对象(函数也是对象)是new Object的结果，所以对象可以作为实例对象，其构造函数是Object()，原型对象是Object.prototype 【3】Object.prototype的原型对象是null JS继承的6种方式 [原型] 123// B是A的原型，A是B的构造函数A.prototype = BB.constructor = A [约定] 1234567// 父类function Super()&#123; this.property = &apos;Super Property&apos;&#125;Super.prototype.getProperty = function()&#123; return this.property&#125; 构造函数继承1.基本思想通过使用call、apply方法可以在新创建的对象上执行构造函数,用父类的构造函数来增加子类的实例 2.具体实现12345// 子类function Sub()&#123; Super.call(this) this.property = &apos;Sub Property&apos;&#125; 3.优缺点1）优点简单明了，直接继承超类构造函数的属性和方法2）缺点无法继承原型链上的属性和方法 原型链继承1.基本思想利用原型链来实现继承，超类的一个实例作为子类的原型 2.具体实现1234567// 子类function Sub()&#123; this.property = &apos;Sub Property&apos;&#125;Sub.prototype = new Super()// 注意这里new Super()生成的超类对象并没有constructor属性,故需添加上Sub.prototype.constructor = Sub 3.优缺点1）优点简单明了，容易实现实例是子类的实例，实际上也是父类的一个实例父类新增原型方法/原型属性，子类都能访问到2）缺点所有子类的实例的原型都共享同一个超类实例的属性和方法无法实现多继承 组合继承1.基本思想利用构造继承和原型链组合 2.具体实现12345678// 子类function Sub()&#123; Super.call(this) this.property = &apos;Sub Property&apos;&#125;Sub.prototype = new Super()// 注意这里new Super()生成的超类对象并没有constructor属性,故需添加上Sub.prototype.constructor = Sub 3.优缺点1）优点解决了构造继承和原型链继承的两个问题2）缺点实际上子类上会拥有超类的两份属性，只是子类的属性覆盖了超类的属性 原型式继承1.基本思想采用原型式继承并不需要定义一个类，传入参数obj,生成一个继承obj对象的对象 2.具体实现12345function objectCreate(obj)&#123; function F()&#123;&#125; F.prototype = obj return new F()&#125; 3.优缺点1）优点：直接通过对象生成一个继承该对象的对象2）缺点： 寄生式继承1.基本思想创建一个仅仅用于封装继承过程的函数，然后在内部以某种方式增强对象，最后返回对象 2.具体实现12345678910function objectCreate(obj)&#123; function F()&#123;&#125; F.prototype = obj return new F()&#125;function createSubObj(superInstance)&#123; var clone = objectCreate(superInstance) clone.property = &apos;Sub Property&apos; return clone&#125; 3.优缺点1）优点：原型式继承的一种拓展2）缺点：依旧没有类的概念 六.寄生组合式继承1.基本思想结合寄生式继承和组合式继承，完美实现不带两份超类属性的继承方式 2.具体实现12345678910function inheritPrototype(Super,Sub)&#123; var superProtoClone = Object.Create(Super.prototype) superProtoClone.constructor = Sub Sub.prototype = Super&#125;function Sub()&#123; Super.call() Sub.property = &apos;Sub Property&apos;&#125;inheritPrototype(Super,Sub) 3.优缺点1）优点：完美实现继承，解决了组合式继承带两份属性的问题2）缺点：过于繁琐，故不如组合继承","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://xdd7130.github.io/categories/Web前端/"}],"tags":[{"name":"原型，继承","slug":"原型，继承","permalink":"http://xdd7130.github.io/tags/原型，继承/"}]},{"title":"CSS","slug":"面试CSS","date":"2018-12-26T09:28:15.000Z","updated":"2022-11-02T11:15:20.759Z","comments":true,"path":"2018/12/26/面试CSS/","link":"","permalink":"http://xdd7130.github.io/2018/12/26/面试CSS/","excerpt":"","text":"响应式布局的常用解决方案对比(媒体查询、百分比、rem和vw/vh）简要介绍：前端开发中，静态网页通常需要适应不同分辨率的设备，常用的自适应解决方案包括媒体查询、百分比、rem和vw/vh等。本文从px单位出发，分析了px在移动端布局中的不足，接着介绍了几种不同的自适应解决方案。 px和视口 媒体查询 百分比 自适应场景下的rem解决方案 通过vw/vh来实现自适应 px和视口在静态网页中，我们经常用像素（px）作为单位，来描述一个元素的宽高以及定位信息。在pc端，通常认为css中,1px所表示的真实长度是固定的。那么，px真的是一个设备无关，跟长度单位米和分米一样是固定大小的吗？ 答案是否定的，下面图1.1和图1.2分别表示pc端下和移动端下的显示结果，在网页中我们设置的font-size统一为16px。从上面两幅图的对比可以看出，字体都是16px，显然在pc端中文字正常显示，而在移动端文字很小，几乎看不到，说明在css中1px并不是固定大小，直观从我们发现在移动端1px所表示的长度较小，所以导致文字显示不清楚。 那么css中的1px的真实长度到底由什么决定呢？ 为了理清楚这个概念我们首先介绍像素和视口的概念 像素像素是网页布局的基础，一个像素表示了计算机屏幕所能显示的最小区域，像素分为两种类型：css像素和物理像素。 我们在js或者css代码中使用的px单位就是指的是css像素，物理像素也称设备像素，只与设备或者说硬件有关，同样尺寸的屏幕，设备的密度越高，物理像素也就越多。下表表示css像素和物理像素的具体区别： css像素: 为web开发者提供，在css中使用的一个抽象单位物理像素 : 只与设备的硬件密度有关，任何设备的物理像素都是固定的那么css像素与物理像素的转换关系是怎么样的呢？为了明确css像素和物理像素的转换关系，必须先了解视口是什么。 视口广义的视口，是指浏览器显示内容的屏幕区域，狭义的视口包括了布局视口、视觉视口和理想视口 (1) 布局视口（layout viewport）布局视口定义了pc网页在移动端的默认布局行为，因为通常pc的分辨率较大，布局视口默认为980px。也就是说在不设置网页的viewport的情况下，pc端的网页默认会以布局视口为基准，在移动端进行展示。因此我们可以明显看出来，默认为布局视口时，根植于pc端的网页在移动端展示很模糊。 (2) 视觉视口（visual viewport）视觉视口表示浏览器内看到的网站的显示区域，用户可以通过缩放来查看网页的显示内容，从而改变视觉视口。视觉视口的定义，就像拿着一个放大镜分别从不同距离观察同一个物体，视觉视口仅仅类似于放大镜中显示的内容，因此视觉视口不会影响布局视口的宽度和高度。 (3) 理想视口（ideal viewport）理想视口或者应该全称为“理想的布局视口”，在移动设备中就是指设备的分辨率。换句话说，理想视口或者说分辨率就是给定设备物理像素的情况下，最佳的“布局视口”。 上述视口中，最重要的是要明确理想视口的概念，在移动端中，理想视口或者说分辨率跟物理像素之间有什么关系呢？ 为了理清分辨率和物理像素之间的联系，我们介绍一个用DPR（Device pixel ratio）设备像素比来表示，则可以写成： 1 DPR = 物理像素／分辨率在不缩放的情况下，一个css像素就对应一个dpr，也就是说，在不缩放 1 CSS像素 = 物理像素／分辨率此外，在移动端的布局中，我们可以通过viewport元标签来控制布局，比如一般情况下，我们可以通过下述标签使得移动端在理想视口下布局：1&lt;meta id=&quot;viewport&quot; name=&quot;viewport&quot; content=&quot;width=device-width; initial-scale=1.0; maximum-scale=1; user-scalable=no;&quot;&gt; 属性名 取值 描述 width 正整数 定义布局视口的宽度，单位为像素 height 正整数 定义布局视口的高度，单位为像素，很少使用 initial-scale [0,10] 初始缩放比例，1表示不缩放 minimum-scale [0,10] 最小缩放比例 maximum-scale [0,10] 最大缩放比例 user-scalable yes／no 是否允许手动缩放页面，默认值为yes 其中我们来看width属性，在移动端布局时，在meta标签中我们会将width设置称为device-width，device-width一般是表示分辨率的宽，通过width=device-width的设置我们就将布局视口设置成了理想的视口。 px与自适应上述我们了解到了当通过viewport元标签，设置布局视口为理想视口时，1个css像素可以表示成： 1 CSS像素 = 物理像素／分辨率我们直到，在pc端的布局视口通常情况下为980px，移动端以iphone6为例，分辨率为375 667，也就是说布局视口在理想的情况下为375px。比如现在我们有一个750px 1134px的视觉稿，那么在pc端，一个css像素可以如下计算： PC端： 1 CSS像素 = 物理像素／分辨率 = 750 ／ 980 =0.76 px而在iphone6下： iphone6：1 CSS像素 = 物理像素 ／分辨率 = 750 ／ 375 = 2 px也就是说在PC端，一个CSS像素可以用0.76个物理像素来表示，而iphone6中 一个CSS像素表示了2个物理像素。此外不同的移动设备分辨率不同，也就是1个CSS像素可以表示的物理像素是不同的，因此如果在css中仅仅通过px作为长度和宽度的单位，造成的结果就是无法通过一套样式，实现各端的自适应。 媒体查询在前面我们说到，不同端的设备下，在css文件中，1px所表示的物理像素的大小是不同的，因此通过一套样式，是无法实现各端的自适应。由此我们联想： 如果一套样式不行，那么能否给每一种设备各一套不同的样式来实现自适应的效果？ 答案是肯定的。 使用@media媒体查询可以针对不同的媒体类型定义不同的样式，特别是响应式页面，可以针对不同屏幕的大小，编写多套样式，从而达到自适应的效果。举例来说：1234567891011121314151617181920212223@media screen and (max-width: 960px)&#123; body&#123; background-color:#FF6699 &#125;&#125;@media screen and (max-width: 768px)&#123; body&#123; background-color:#00FF66; &#125;&#125;@media screen and (max-width: 550px)&#123; body&#123; background-color:#6633FF; &#125;&#125;@media screen and (max-width: 320px)&#123; body&#123; background-color:#FFFF00; &#125;&#125; 上述的代码通过媒体查询定义了几套样式，通过max-width设置样式生效时的最大分辨率，上述的代码分别对分辨率在0～320px，320px～550px，550px～768px以及768px～960px的屏幕设置了不同的背景颜色。 通过媒体查询，可以通过给不同分辨率的设备编写不同的样式来实现响应式的布局，比如我们为不同分辨率的屏幕，设置不同的背景图片。比如给小屏幕手机设置@2x图，为大屏幕手机设置@3X图，通过媒体查询就能很方便的实现。 但是媒体查询的缺点也很明显，如果在浏览器大小改变时，需要改变的样式太多，那么多套样式代码会很繁琐。 百分比除了用px结合媒体查询实现响应式布局外，我们也可以通过百分比单位 “ % “ 来实现响应式的效果。 比如当浏览器的宽度或者高度发生变化时，通过百分比单位，通过百分比单位可以使得浏览器中的组件的宽和高随着浏览器的变化而变化，从而实现响应式的效果。 为了了解百分比布局，首先要了解的问题是： css中的子元素中的百分比（%）到底是谁的百分比？ 直观的理解，我们可能会认为子元素的百分比完全相对于直接父元素，height百分比相对于height，width百分比相对于width。当然这种理解是正确的，但是根据css的盒式模型，除了height、width属性外，还具有padding、border、margin等等属性。那么这些属性设置成百分比，是根据父元素的那些属性呢？此外还有border-radius和translate等属性中的百分比，又是相对于什么呢？下面来具体分析。 百分比的具体分析（1）子元素height和width的百分比 子元素的height或width中使用百分比，是相对于子元素的直接父元素，width相对于父元素的width，height相对于父元素的height。比如：123456789101112&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;child&quot;&gt;&lt;/div&gt;&lt;/div&gt;如果设置：.father&#123;width:200px;height:100px;&#125;.child&#123;width:50%;height:50%;&#125; 展示的效果为：(2) top和bottom 、left和right 子元素的top和bottom如果设置百分比，则相对于直接非static定位(默认定位)的父元素的高度，同样 子元素的left和right如果设置百分比，则相对于直接非static定位(默认定位的)父元素的宽度。 展示的效果为：（3）padding 子元素的padding如果设置百分比，不论是垂直方向或者是水平方向，都相对于直接父亲元素的width，而与父元素的height无关。 举例来说：12345678910111213.parent&#123; width:200px; height:100px; background:green;&#125;.child&#123; width:0px; height:0px; background:blue; color:white; padding-top:50%; padding-left:50%;&#125; 展示的效果为：子元素的初始宽高为0，通过padding可以将父元素撑大，上图的蓝色部分是一个正方形，且边长为100px,说明padding不论宽高，如果设置成百分比都相对于父元素的width。 （4）margin 跟padding一样，margin也是如此，子元素的margin如果设置成百分比，不论是垂直方向还是水平方向，都相对于直接父元素的width。这里就不具体举例。 （5）border-radius border-radius不一样，如果设置border-radius为百分比，则是相对于自身的宽度，举例来说：1&lt;div class=&quot;trangle&quot;&gt;&lt;/div&gt; 设置border-radius为百分比：1234567.trangle&#123; width:100px; height:100px; border-radius:50%; background:blue; margin-top:10px;&#125; 展示效果为： 百分比单位布局应用百分比单位在布局上应用还是很广泛的，这里介绍一种应用。比如我们要实现一个固定长宽比的长方形，比如要实现一个长宽比为4:3的长方形,我们可以根据padding属性来实现，因为padding不管是垂直方向还是水平方向，百分比单位都相对于父元素的宽度，因此我们可以设置padding-top为百分比来实现，长宽自适应的长方形：1&lt;div class=&quot;trangle&quot;&gt;&lt;/div&gt; 设置样式让其自适应：12345.trangle&#123; height:0; width:100%; padding-top:75%;&#125; 通过设置padding-top：75%,相对比宽度的75%，因此这样就设置了一个长宽高恒定比例的长方形，具体效果 百分比单位缺点从上述对于百分比单位的介绍我们很容易看出如果全部使用百分比单位来实现响应式的布局，有明显的以下两个缺点：（1）计算困难，如果我们要定义一个元素的宽度和高度，按照设计稿，必须换算成百分比单位。（2）从小节1可以看出，各个属性中如果使用百分比，相对父元素的属性并不是唯一的。比如width和height相对于父元素的width和height，而margin、padding不管垂直还是水平方向都相对比父元素的宽度、border-radius则是相对于元素自身等等，造成我们使用百分比单位容易使布局问题变得复杂。 自适应场景下的rem解决方案 rem单位 首先来看，什么是rem单位。rem是一个灵活的、可扩展的单位，由浏览器转化像素并显示。与em单位不同，rem单位无论嵌套层级如何，都只相对于浏览器的根元素（HTML元素）的font-size。默认情况下，html元素的font-size为16px，所以：11 rem = 12px 为了计算方便，通常可以将html的font-size设置成：1html&#123; font-size: 62.5% &#125; 这种情况下：11 rem = 10px 2.通过rem来实现响应式布局 rem单位都是相对于根元素html的font-size来决定大小的,根元素的font-size相当于提供了一个基准，当页面的size发生变化时，只需要改变font-size的值，那么以rem为固定单位的元素的大小也会发生响应的变化。因此，如果通过rem来实现响应式的布局，只需要根据视图容器的大小，动态的改变font-size即可。12345678function refreshRem() &#123; var docEl = doc.documentElement; var width = docEl.getBoundingClientRect().width; var rem = width / 10; docEl.style.fontSize = rem + &apos;px&apos;; flexible.rem = win.rem = rem;&#125;win.addEventListener(&apos;resize&apos;, refreshRem); 上述代码中将视图容器分为10份，font-size用十分之一的宽度来表示，最后在header标签中执行这段代码，就可以动态定义font-size的大小，从而1rem在不同的视觉容器中表示不同的大小，用rem固定单位可以实现不同容器内布局的自适应。 rem2px和px2rem 如果在响应式布局中使用rem单位，那么存在一个单位换算的问题，rem2px表示从rem换算成px，这个就不说了，只要rem乘以相应的font-size中的大小，就能换算成px。更多的应用是px2rem，表示的是从px转化为rem。 比如给定的视觉稿为750px（物理像素），如果我们要将所有的布局单位都用rem来表示，一种比较笨的办法就是对所有的height和width等元素，乘以相应的比例，现将视觉稿换算成rem单位，然后一个个的用rem来表示。另一种比较方便的解决方法就是，在css中我们还是用px来表示元素的大小，最后编写完css代码之后，将css文件中的所有px单位，转化成rem单位。 px2rem的原理也很简单，重点在于预处理以px为单位的css文件，处理后将所有的px变成rem单位。可以通过两种方式来实现： 1） webpack loader的形式：1npm install px2rem-loader 在webpack的配置文件中：1234567891011121314151617181920module.exports = &#123; // ... module: &#123; rules: [&#123; test: /\\.css$/, use: [&#123; loader: &apos;style-loader&apos; &#125;, &#123; loader: &apos;css-loader&apos; &#125;, &#123; loader: &apos;px2rem-loader&apos;, // options here options: &#123; remUni: 75, remPrecision: 8 &#125; &#125;] &#125;] &#125;&#125; 2）webpack中使用postcss plugin1npm install postcss-loader 在webpack的plugin中:123456789101112131415var px2rem = require(&apos;postcss-px2rem&apos;);module.exports = &#123; module: &#123; loaders: [ &#123; test: /\\.css$/, loader: &quot;style-loader!css-loader!postcss-loader&quot; &#125; ] &#125;, postcss: function() &#123; return [px2rem(&#123;remUnit: 75&#125;)]; &#125;&#125; rem 布局应用举例 网易新闻的移动端页面使用了rem布局，具体例子如下： rem 布局的缺点 通过rem单位，可以实现响应式的布局，特别是引入相应的postcss相关插件，免去了设计稿中的px到rem的计算。rem单位在国外的一些网站也有使用，这里所说的rem来实现布局的缺点，或者说是小缺陷是： 在响应式布局中，必须通过js来动态控制根元素font-size的大小。 也就是说css样式和js代码有一定的耦合性。且必须将改变font-size的代码放在css样式之前。 通过vw/vh来实现自适应 什么是vw/vh ? css3中引入了一个新的单位vw/vh，与视图窗口有关，vw表示相对于视图窗口的宽度，vh表示相对于视图窗口高度，除了vw和vh外，还有vmin和vmax两个相关的单位。各个单位具体的含义如下： 单位 含义 vw 相对于视窗的宽度，视窗宽度是100vw vh 相对于视窗的高度，视窗高度是100vh vmin vw和vh中的较小值 vmax vw和vh中的较大值 这里我们发现视窗宽高都是100vw／100vh，那么vw或者vh，下简称vw，很类似百分比单位。vw和%的区别为： 单位 含义 % 大部分相对于祖先元素，也有相对于自身的情况比如（border-radius、translate等) vw/vh 相对于视窗的尺寸 从对比中我们可以发现，vw单位与百分比类似，单确有区别，前面我们介绍了百分比单位的换算困难，这里的vw更像”理想的百分比单位”。任意层级元素，在使用vw单位的情况下，1vw都等于视图宽度的百分之一。 vw单位换算 同样的，如果要将px换算成vw单位，很简单，只要确定视图的窗口大小（布局视口），如果我们将布局视口设置成分辨率大小，比如对于iphone6/7 375*667的分辨率，那么px可以通过如下方式换算成vw：11px = （1/375）*100 vw 此外，也可以通过postcss的相应插件，预处理css做一个自动的转换，postcss-px-to-viewport可以自动将px转化成vw。postcss-px-to-viewport的默认参数为：123456789var defaults = &#123; viewportWidth: 320, viewportHeight: 568, unitPrecision: 5, viewportUnit: &apos;vw&apos;, selectorBlackList: [], minPixelValue: 1, mediaQuery: false&#125;; 通过指定视窗的宽度和高度，以及换算精度，就能将px转化成vw。 vw/vh单位的兼容性可以在https://caniuse.com/ 查看各个版本的浏览器对vw单位的支持性。从上图我们发现，绝大多数的浏览器支持vw单位，但是ie9-11不支持vmin和vmax，考虑到vmin和vmax单位不常用，vw单位在绝大部分高版本浏览器内的支持性很好，但是opera浏览器整体不支持vw单位，如果需要兼容opera浏览器的布局，不推荐使用vw。 小结本文介绍在布局中常用的单位，比如px、%、rem和vw等等，以及不同的单位在响应式布局中的优缺点。 画一条0.5px的线 采用meta viewport的方式 采用 border-image的方式 采用transform: scale()的方式 link标签和import标签的区别 link属于html标签，而@import是css提供的 页面被加载时，link会同时被加载，而@import引用的css会等到页面加载结束后加载。 link是html标签，因此没有兼容性，而@import只有IE5以上才能识别。 link方式样式的权重高于@import的。 transition和animation的区别Animation和transition大部分属性是相同的，他们都是随时间改变元素的属性值，他们的主要区别是transition需要触发一个事件才能改变属性，而animation不需要触发任何事件的情况下才会随时间改变属性值，并且transition为2帧，从from …. to，而animation可以一帧一帧的。 Flex布局文章链接：http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?utm_source=tuicool（语法篇）http://www.ruanyifeng.com/blog/2015/07/flex-examples.html（实例篇） Flex是Flexible Box的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。布局的传统解决方案，基于盒状模型，依赖 display属性 + position属性 + float属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。 简单的分为容器属性和元素属性容器的属性： flex-direction：决定主轴的方向（即子item的排列方法）.box {flex-direction: row | row-reverse | column | column-reverse;}flex-wrap：决定换行规则.box{flex-wrap: nowrap | wrap | wrap-reverse;}flex-flow：.box {flex-flow: || ;}justify-content：对其方式，水平主轴对齐方式align-items：对齐方式，竖直轴线方向项目的属性（元素的属性）： order属性：定义项目的排列顺序，顺序越小，排列越靠前，默认为0flex-grow属性：定义项目的放大比例，即使存在空间，也不会放大flex-shrink属性：定义了项目的缩小比例，当空间不足的情况下会等比例的缩小，如果定义个item的flow-shrink为0，则为不缩小flex-basis属性：定义了在分配多余的空间，项目占据的空间。flex：是flex-grow和flex-shrink、flex-basis的简写，默认值为0 1 auto。align-self：允许单个项目与其他项目不一样的对齐方式，可以覆盖align-items，默认属性为auto，表示继承父元素的align-items比如说，用flex实现圣杯布局 BFC（块级格式化上下文，用于清除浮动，防止margin重叠等）直译成：块级格式化上下文，是一个独立的渲染区域，并且有一定的布局规则。 BFC区域不会与float box重叠BFC是页面上的一个独立容器，子元素不会影响到外面计算BFC的高度时，浮动元素也会参与计算哪些元素会生成BFC： 根元素 float不为none的元素 position为fixed和absolute的元素 display为inline-block、table-cell、table-caption，flex，inline-flex的元素 overflow不为visible的元素 BFC定义 1、 boxbox是css布局的基本单位，元素的类型和display属性决定了box的类型。不同的类型的盒子会参与不同的formatting context。block-level box :display属性为block、list-item(作为列表显示的元素)、table的元素会生成block-level box。2、formatting context它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用 BFC（block formatting context）为块级格式化上下文，他是一个独立渲染区域，并且只有block-level box参与，规定了block-level box内部的布局方式。 布局规则 1、内部的box会在垂直方向上一个接一个的放置 12&lt;div class=\"div1\"&gt;&lt;/div&gt;&lt;div class=\"div2\"&gt;&lt;/div&gt; 2、同一个bfc内，两个相邻box元素的margin会产生重叠，重叠距离为数值大的margin值给div1设置margin: 20px 0,给div2设置margin: 30px 0,此时div1和div2之间的间距为30px。 解决方式 让两个元素不属于同一个BFC3、BFC区域不会与浮动元素重叠12&lt;div class=\"left\"&gt;&lt;/div&gt;&lt;div class=\"main\"&gt;&lt;/div&gt; 此时main元素没有产生bfc,left元素浮动，效果如下：给main元素设置overflow:hidden变为bfc,效果如下： 4、计算BFC的高度时，浮动元素也参与计算 5、每个元素的margin box的左边， 与 包含块 border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此 6、BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素 3、产生BFC的方式 1、overflow属性不是visible 2、float属性不为none 3、display属性为inline-block、table-cell、flex、inline-flex、table-caption 4、position为absolute、fixed 5、body根元素 关于js动画和css3动画的差异性渲染线程分为main thread和compositor thread，如果css动画只改变transform和opacity，这时整个CSS动画得以在compositor trhead完成（而js动画则会在main thread执行，然后出发compositor thread进行下一步操作），特别注意的是如果改变transform和opacity是不会layout或者paint的。区别： 功能涵盖面，js比css大 实现/重构难度不一，CSS3比js更加简单，性能跳优方向固定 对帧速表现不好的低版本浏览器，css3可以做到自然降级 css动画有天然事件支持 css3有兼容性问题 块元素和行元素HTML可以将元素分类方式分为行内元素、块状元素和行内块状元素三种。首先需要说明的是，这三者是可以互相转换的，使用display属性能够将三者任意转换： (1)display:inline;转换为行内元素 (2)display:block;转换为块状元素 (3)display:inline-block;转换为行内块状元素块元素：独占一行，并且有自动填满父元素，可以设置margin和pading以及高度和宽度行元素：不会独占一行，width和height会失效，并且在垂直方向的padding和margin会失效。1.块状元素 块状元素代表性的就是div，其他如p、nav、aside、header、footer、section、article、ul-li、address等等，都可以用div来实现。不过为了可以方便程序员解读代码，一般都会使用特定的语义化标签，使得代码可读性强，且便于查错。 块状元素特征：(1)能够识别宽高 (2)margin和padding的上下左右均对其有效 (3)可以自动换行 (4)多个块状元素标签写在一起，默认排列方式为从上至下2.块状元素 块状元素代表性的就是div，其他如p、nav、aside、header、footer、section、article、ul-li、address等等，都可以用div来实现。不过为了可以方便程序员解读代码，一般都会使用特定的语义化标签，使得代码可读性强，且便于查错。 块状元素特征：(1)能够识别宽高 (2)margin和padding的上下左右均对其有效 (3)可以自动换行 (4)多个块状元素标签写在一起，默认排列方式为从上至下3.行内块状元素 行内块状元素综合了行内元素和块状元素的特性，但是各有取舍。因此行内块状元素在日常的使用中，由于其特性，使用的次数也比较多。 行内块状元素特征：(1)不自动换行 (2)能够识别宽高 (3)默认排列方式为从左到右 多行元素的文本省略号1234display: -webkit-box-webkit-box-orient:vertical-webkit-line-clamp:3overflow:hidden visibility=hidden, opacity=0，display:noneopacity=0，该元素隐藏起来了，但不会改变页面布局，并且，如果该元素已经绑定一些事件，如click事件，那么点击该区域，也能触发点击事件的visibility=hidden，该元素隐藏起来了，但不会改变页面布局，但是不会触发该元素已经绑定的事件display=none，把元素隐藏起来，并且会改变页面布局，可以理解成在页面中把该元素删除掉一样。 双边距重叠问题（外边距折叠）多个相邻（兄弟或者父子关系）普通流的块元素垂直方向marigin会重叠 折叠的结果为： 两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值。两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值。两个外边距一正一负时，折叠结果是两者的相加的和。 position static 默认。位置设置为 static 的元素，它始终会处于页面流给予的位置（static 元素会忽略任何 top、bottom、left 或 right 声明）。 relative 位置被设置为 relative 的元素，可将其移至相对于其正常位置的地方，因此 “left:20” 会将元素移至元素正常位置左边 20 个像素的位置。 absolute 位置设置为 absolute 的元素，可定位于相对于包含它的元素的指定坐标。此元素的位置可通过 “left”、”top”、”right” 以及 “bottom” 属性来规定。 fixed 位置被设置为 fixed 的元素，可定位于相对于浏览器窗口的指定坐标。此元素的位置可通过 “left”、”top”、”right” 以及”bottom” 属性来规定。不论窗口滚动与否，元素都会留在那个位置。工作于 IE7（strict 模式）。 sticky 基于用户的滚动位置来定位。粘性定位的元素是依赖于用户的滚动，在position:relative 与 position:fixed定位之间切换。它的行为就像position:relative;而当页面滚动超出目标区域时，它的表现就像 position:fixed;，它会固定在目标位置。元素定位表现为在跨越特定阈值前为相对定位，之后为固定定位。 animation语法1@keyframes animationname &#123;keyframes-selector &#123;css-styles;&#125;&#125; 下面的表格列出了 @keyframes 规则和所有动画属性： 属性 描述 CSS @keyframes 规定动画。 3 animation 所有动画属性的简写属性，除了 animation-play-state 属性。 3 animation-name 规定 @keyframes 动画的名称。 3 animation-duration 规定动画完成一个周期所花费的秒或毫秒。默认是 0。 3 animation-timing-function 规定动画的速度曲线。默认是 “ease”。 3 animation-delay 规定动画何时开始。默认是 0。 3 animation-iteration-count 规定动画被播放的次数。默认是 1。 3 animation-direction 规定动画是否在下一周期逆向地播放。默认是 “normal”。 3 animation-play-state 规定动画是否正在运行或暂停。默认是 “running”。 3 animation-fill-mode 规定对象动画时间之外的状态。 3 伪元素伪类 css3为了区分伪类和伪元素，伪元素采用双冒号写法。 伪类 – :hover, :link, :active, :visited, :first-child, :last-child, nth-child(n), :not(), :focus伪元素 – ::before, ::after, ::first-letter, ::first-line, ::selection 定义: 伪类：用于向某些选择器添加特殊的效果伪元素：用于将特殊的效果添加到某些选择器 区别 例子来理解1234&lt;p&gt; &lt;em&gt;This&lt;/em&gt; &lt;em&gt;is a text&lt;/em&gt;&lt;/p&gt; 如果我们想要第一个em标签字体颜色变红怎么做呢使用我们熟悉的伪类很简单123em:first-child &#123; color: red;&#125; 但是如果不存在伪类我们怎么做呢这是我们就需要为第一个em标签添加类12345678&lt;p&gt; &lt;em class=&quot;first-child&quot;&gt;This&lt;/em&gt; &lt;em&gt;is a text&lt;/em&gt;&lt;/p&gt;em.first-child &#123; color: red;&#125; 可以实现同样的效果1234&lt;p&gt; &lt;em&gt;This&lt;/em&gt; &lt;em&gt;is a text&lt;/em&gt;&lt;/p&gt; 还是这个例子现在我想让这个段落的第一个字母变红 这回我们需要使用伪元素123p::first-letter &#123; color: red;&#125; 同样假设伪元素不存在的情况这时我们只能嵌套span标签来实现12345678&lt;p&gt; &lt;em&gt;&lt;span&gt;T&lt;/span&gt;his&lt;/em&gt; &lt;em&gt;is a text&lt;/em&gt;&lt;/p&gt;p span &#123; color: red;&#125; 看到这里，相信大家已经清楚了为什么一个叫做伪类，一个叫做伪元素伪类的效果可以通过添加实际的类来实现伪元素的效果可以通过添加实际的元素来实现 它们的本质区别就是是否抽象创造了新元素伪元素是可以设置content属性的，类似于标签，但是伪类只能设置样式不能设置内容。注意伪类就像真正的类一样，可以叠加使用没有数量上限，只要不是互斥的比如这样123em:first-child:hover &#123; color: red;&#125; 但注意，这里是“与”的关系也就是说既要满足“first-child”第一个子元素又要满足“hover”光标悬浮伪元素就要严格的多伪元素在一个选择器中只能出现一次，并且只能出现在末尾（这里有同学误会了，所以我作出了修改）像下面的样式是无法生效的123456p::first-letter:hover &#123; /*错误的写法：伪元素不是末尾*/ color: red;&#125;p::first-letter::selection &#123; /*错误的写法：伪元素出现了多个*/ color: red;&#125; 关于它们的优先级在计算权重的时候伪类与类优先级相同伪元素与标签优先级相同 总结 伪类与伪元素都是用于向选择器加特殊效果 伪类与伪元素的本质区别就是是否抽象创造了新元素 伪类只要不是互斥可以叠加使用 伪元素在一个选择器中只能出现一次，并且只能出现在末尾 伪类与伪元素优先级分别与类、标签优先级相同","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://xdd7130.github.io/categories/Web前端/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://xdd7130.github.io/tags/CSS/"}]}],"categories":[{"name":"笔记","slug":"笔记","permalink":"http://xdd7130.github.io/categories/笔记/"},{"name":"D3","slug":"D3","permalink":"http://xdd7130.github.io/categories/D3/"},{"name":"hexo","slug":"hexo","permalink":"http://xdd7130.github.io/categories/hexo/"},{"name":"Vue3","slug":"Vue3","permalink":"http://xdd7130.github.io/categories/Vue3/"},{"name":"Cesium","slug":"Cesium","permalink":"http://xdd7130.github.io/categories/Cesium/"},{"name":"nginx","slug":"nginx","permalink":"http://xdd7130.github.io/categories/nginx/"},{"name":"webgis","slug":"webgis","permalink":"http://xdd7130.github.io/categories/webgis/"},{"name":"React","slug":"React","permalink":"http://xdd7130.github.io/categories/React/"},{"name":"Web前端","slug":"Web前端","permalink":"http://xdd7130.github.io/categories/Web前端/"},{"name":"Vue","slug":"Vue","permalink":"http://xdd7130.github.io/categories/Vue/"},{"name":"其他","slug":"其他","permalink":"http://xdd7130.github.io/categories/其他/"},{"name":"SVG","slug":"SVG","permalink":"http://xdd7130.github.io/categories/SVG/"},{"name":"Node","slug":"Node","permalink":"http://xdd7130.github.io/categories/Node/"},{"name":"ArcGIS","slug":"ArcGIS","permalink":"http://xdd7130.github.io/categories/ArcGIS/"},{"name":"小程序","slug":"小程序","permalink":"http://xdd7130.github.io/categories/小程序/"},{"name":"python","slug":"python","permalink":"http://xdd7130.github.io/categories/python/"},{"name":"git","slug":"git","permalink":"http://xdd7130.github.io/categories/git/"}],"tags":[{"name":"node","slug":"node","permalink":"http://xdd7130.github.io/tags/node/"},{"name":"D3","slug":"D3","permalink":"http://xdd7130.github.io/tags/D3/"},{"name":"hexo","slug":"hexo","permalink":"http://xdd7130.github.io/tags/hexo/"},{"name":"Vue,Vue3,element-plus","slug":"Vue-Vue3-element-plus","permalink":"http://xdd7130.github.io/tags/Vue-Vue3-element-plus/"},{"name":"Cesium","slug":"Cesium","permalink":"http://xdd7130.github.io/tags/Cesium/"},{"name":"Cesium,Vue,Vite","slug":"Cesium-Vue-Vite","permalink":"http://xdd7130.github.io/tags/Cesium-Vue-Vite/"},{"name":"Vue Router4.X,Vue,Vue3","slug":"Vue-Router4-X-Vue-Vue3","permalink":"http://xdd7130.github.io/tags/Vue-Router4-X-Vue-Vue3/"},{"name":"nginx,linux","slug":"nginx-linux","permalink":"http://xdd7130.github.io/tags/nginx-linux/"},{"name":"webgis","slug":"webgis","permalink":"http://xdd7130.github.io/tags/webgis/"},{"name":"笔记","slug":"笔记","permalink":"http://xdd7130.github.io/tags/笔记/"},{"name":"mock,linux","slug":"mock-linux","permalink":"http://xdd7130.github.io/tags/mock-linux/"},{"name":"React","slug":"React","permalink":"http://xdd7130.github.io/tags/React/"},{"name":"ES6","slug":"ES6","permalink":"http://xdd7130.github.io/tags/ES6/"},{"name":"Promise","slug":"Promise","permalink":"http://xdd7130.github.io/tags/Promise/"},{"name":"Vue","slug":"Vue","permalink":"http://xdd7130.github.io/tags/Vue/"},{"name":"PROBLEM","slug":"PROBLEM","permalink":"http://xdd7130.github.io/tags/PROBLEM/"},{"name":"Node.js","slug":"Node-js","permalink":"http://xdd7130.github.io/tags/Node-js/"},{"name":"IIS服务器","slug":"IIS服务器","permalink":"http://xdd7130.github.io/tags/IIS服务器/"},{"name":"SVG","slug":"SVG","permalink":"http://xdd7130.github.io/tags/SVG/"},{"name":"大屏","slug":"大屏","permalink":"http://xdd7130.github.io/tags/大屏/"},{"name":"安全","slug":"安全","permalink":"http://xdd7130.github.io/tags/安全/"},{"name":"vue","slug":"vue","permalink":"http://xdd7130.github.io/tags/vue/"},{"name":"ArcGIS","slug":"ArcGIS","permalink":"http://xdd7130.github.io/tags/ArcGIS/"},{"name":"小程序","slug":"小程序","permalink":"http://xdd7130.github.io/tags/小程序/"},{"name":"js","slug":"js","permalink":"http://xdd7130.github.io/tags/js/"},{"name":"WebSocket","slug":"WebSocket","permalink":"http://xdd7130.github.io/tags/WebSocket/"},{"name":"python基础","slug":"python基础","permalink":"http://xdd7130.github.io/tags/python基础/"},{"name":"ArcGIS API for JS","slug":"ArcGIS-API-for-JS","permalink":"http://xdd7130.github.io/tags/ArcGIS-API-for-JS/"},{"name":"git","slug":"git","permalink":"http://xdd7130.github.io/tags/git/"},{"name":"前端工作流","slug":"前端工作流","permalink":"http://xdd7130.github.io/tags/前端工作流/"},{"name":"tcp","slug":"tcp","permalink":"http://xdd7130.github.io/tags/tcp/"},{"name":"CSS","slug":"CSS","permalink":"http://xdd7130.github.io/tags/CSS/"},{"name":"居中","slug":"居中","permalink":"http://xdd7130.github.io/tags/居中/"},{"name":"盒模型","slug":"盒模型","permalink":"http://xdd7130.github.io/tags/盒模型/"},{"name":"JS","slug":"JS","permalink":"http://xdd7130.github.io/tags/JS/"},{"name":"闭包","slug":"闭包","permalink":"http://xdd7130.github.io/tags/闭包/"},{"name":"数组","slug":"数组","permalink":"http://xdd7130.github.io/tags/数组/"},{"name":"cookie","slug":"cookie","permalink":"http://xdd7130.github.io/tags/cookie/"},{"name":"跨域","slug":"跨域","permalink":"http://xdd7130.github.io/tags/跨域/"},{"name":"http","slug":"http","permalink":"http://xdd7130.github.io/tags/http/"},{"name":"缓存","slug":"缓存","permalink":"http://xdd7130.github.io/tags/缓存/"},{"name":"原型，继承","slug":"原型，继承","permalink":"http://xdd7130.github.io/tags/原型，继承/"}]}